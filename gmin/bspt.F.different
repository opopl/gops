!  GMIN: A program for finding global minima
!  Copyright (C) 1999-2006 David J. Wales
!  This file is part of GMIN.
!
!  GMIN is free software; you can redistribute it and/or modify
!  it under the terms of the GNU General Public License as published by
!  the Free Software Foundation; either version 2 of the License, or
!  (at your option) any later version.
!
!  GMIN is distributed in the hope that it will be useful,
!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  GNU General Public License for more details.
!
!  You should have received a copy of the GNU General Public License
!  along with this program; if not, write to the Free Software
!  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
!
! 
!---======================================---
      SUBROUTINE PTBASINSAMPLING

      USE MODCHARMM
      USE COMMONS
      USE TETHERFUNC

      IMPLICIT NONE

#ifdef MPI

      INCLUDE 'mpif.h'
       
      INTEGER, PARAMETER :: NHIST=100, NHISTE=1000
      INTEGER :: IACCEPT(0:NTRAJ-1), MPIERR, I,J,K, IS(MPI_STATUS_SIZE)
      INTEGER NHISTQ4(NHIST,0:NTRAJ-1), NDUMMY, NTYPEA, NTOT, NH, IMESG, IQE, IQ4, IQ6, J1, J2, J3, J4,
     1        NHISTQ6(NHIST,0:NTRAJ-1), NHISTQE(NHISTE, 0:NTRAJ-1), IENR, 
     2        NACCEPTPT(0:NTRAJ-1), NOUT(0:NTRAJ-1), ITRAJ, ITRAJO,NEACCEPT, RNDSEED, NUPDATE,
     3        CONVERGED,LBFGS_ITERATIONS, JD, BININDEX, MINIMANUMBER(HBINS,0:NTRAJ-1),
     4        NHISTALLQ(NHIST, NHIST, 0:NTRAJ-1), CUNIT, IBININDEX, IBININDEX2, LOWESTDIRECT(HBINS),
     5        NHISTGRAND(NHISTE, NHIST, NHIST, 0:NTRAJ-1),LBFGS_ITERATIONSO,LVISITS(NENRPER),PEVISITS2(NENRPER, HBINS, 0:NTRAJ-1),
     6        QVISITS(HBINS, 0:NTRAJ-1), PEVISITS(NENRPER,0:NTRAJ-1), ! PEVISITS3(NENRPER, HBINS, 0:NTRAJ-1),
     7        NOUTQBIN, NOUTPEBIN, LBFGS_ITERATIONSSAVE

      DOUBLE PRECISION V(NATOMS), VO(NATOMS), TEMPTRAJ(0:NTRAJ-1), H(0:NTRAJ-1), BETA(0:NTRAJ-1), 
     1        EAV(0:NTRAJ-1), EAV2(0:NTRAJ-1), Q(3,NATOMS), Q4AV(0:NTRAJ-1), Q4AV2(0:NTRAJ-1), 
     2        Q6AV(0:NTRAJ-1), Q6AV2(0:NTRAJ-1), VENR(NENRPER), 
     3        HINIT(0:NTRAJ-1), EPSAB, EPSBB, SIGAB, SIGBB, X(NATOMS), Y(NATOMS), Z(NATOMS), 
     4        CTE, T, VOLD,VNEW, POTEL, GRAD(3*NATOMS), Q4, Q6, RANDOM, DPRAND, Q4MAX, Q6MAX , 
     5	      DQ4, DQ6, DHISTE, ENUL, XO(NATOMS), YO(NATOMS), ZO(NATOMS), DDX, DDY, DDZ, DE, 
     6        W, WCOMP, WAC, E, ER, DBETA, DELTA, CV, FQ4, FQ6, RMAX, DDXN, DDYN, DDZN, R2, 
     7        DUMMY,BINLABEL(HBINS), VNEWSAVE, DIHEORDERPARAM,SASAORDERPARAM, PEINT, HISTINT, 
     8        DIHEORDERPARAM_AV(0:NTRAJ-1), SASAORDERPARAM_AV(0:NTRAJ-1), MINCOORDS(3*NATOMS,NTRAJ), INTERIMCOORDS(3*NATOMS,1),
     9        INTERIMCOORDS2(3*NATOMS,1), DIST, VOLDSAVE, LESAVE, DOSSTATS(MAXIT,2), DOSSTATSO(MAXIT,2), 
     A        DCOORDS(3*NATOMS), DOSSTATSDUM(MAXIT,2)

       DOUBLE PRECISION DIHEORDERPARAM_MIN, DIHEORDERPARAM_MAX, SASAORDERPARAM_MIN, SASAORDERPARAM_MAX, 
     1          DDIHE, DSASA, RGYR_MIN, RGYR_MAX, EINT_MIN, EINT_MAX, DRGYR, DEINT,
     2          RGYR_AV(0:NTRAJ-1), EINT_AV(0:NTRAJ-1), RGYR_AV2(0:NTRAJ-1), EINT_AV2(0:NTRAJ-1),
     3          ORDERPARAM1, ORDERPARAM2, DISTANCE(HBINS, 0:NTRAJ-1),
     4          DISTANCE_AV(HBINS,0:NTRAJ-1), DISTANCEOLD, NORM_PJ(0:NTRAJ-1), PJ(HBINS,0:NTRAJ-1),
     5          VMINOLD, VMINNEW, DELTA_EAV(0:NTRAJ-1), CX, CY, CZ,
     6        DIHEORDERPARAM_AV2(0:NTRAJ-1), SASAORDERPARAM_AV2(0:NTRAJ-1), RGYR, EINT, VMINNEWSAVE

      CHARACTER (LEN =256)  FILENAME, FILENAME2,FILENAME3,FILENAME4,FILENAME5,FILENAME6,
     1                      FILENAME7,FILENAME8,FILENAME9, FILENAME10, FILENAME11, FILENAME12, 
     2                      FILENAME100,FILENAME101,FILENAME102, FILENAME103, FILENAME104, FILENAME105 
      CHARACTER (LEN= 15)  ISTR, CDUMMY
      CHARACTER (LEN= 14)  CFNAME
      LOGICAL EXCHANGE, EXCHANGEACCEPT, FITS, NEWENERGY, EVAP, EVAPREJECT, RECOUNT, YESNO

      COMMON /BIN/ EPSAB, EPSBB, SIGAB, SIGBB, NTYPEA
      COMMON /MYPOT/ POTEL
      COMMON /EV/ EVAP, EVAPREJECT

      CALL MPI_COMM_SIZE(MPI_COMM_WORLD,NDUMMY,MPIERR)
      IF ((NDUMMY.NE.NPAR).OR.(NDUMMY.NE.NTRAJ)) THEN
         WRITE(MYUNIT,'(A)')  'Number of temperature trajectories does not correspond to the number of processors. Stop.'
         RETURN
      ENDIF
      CALL MPI_COMM_RANK(MPI_COMM_WORLD,MYNODE,MPIERR)
      NOUTQBIN=0
      NOUTPEBIN=0

      WRITE(MYUNIT, '(A,I10,A,I10)') "bspt> This is processor", mynode+1, " of", NPAR
      WRITE(MYUNIT, '(A,I10)') 'bspt> Number of atoms', natoms
      IF (PERIODIC) THEN
         WRITE(MYUNIT, '(A,6G20.10)') 'bspt> Binary data', ntypea, epsab, epsbb, sigab, sigbb, cutoff
         WRITE(MYUNIT, '(A,3G20.10)') 'bspt> Box data', boxlx, boxly, boxlz
      ELSEIF(CHRMMT) THEN
         WRITE(MYUNIT, '(A)') 'bspt> CHARMM job'
         IF (FIXSTEP(MYNODE+1).OR.FIXBOTH(MYNODE+1)) THEN
            WRITE(MYUNIT, '(A,G20.10,A)') 'bspt> Starting stepsize ', STEP(MYNODE+1),' (fixed)'
         ELSE
            WRITE(MYUNIT, '(A,G20.10,A)') 'bspt> Starting stepsize ', STEP(MYNODE+1),
     &                            ' (will be dynamically adjusted during equilibration)'
         ENDIF
      ELSE
         WRITE(MYUNIT, '(A,2G20.10)') 'bspt> Radius and Radius**2: ',SQRT(RADIUS),radius
      ENDIF

      IF (CHRMMT) THEN
         IF (HISTRESTART) THEN
           WRITE (ISTR, '(i10)') MYNODE+1
           FILENAME12="xyz_out."//trim(adjustl(istr))
           OPEN(UNIT=1986+MYNODE,FILE=FILENAME12, STATUS="old", form="formatted")
               READ(1986+MYNODE, '(A,G20.10)') cdummy, dummy
            DO J1=1,NATOMS
               J2=3*(J1-1)
               READ(1986+MYNODE,*) COORDS(J2+1,MYNODE+1), COORDS(J2+2,MYNODE+1), COORDS(J2+3,MYNODE+1)
            ENDDO
            CLOSE(1986+MYNODE)
         ELSE
             DO J1=1,NATOMS
                COORDS(3*(J1-1)+1,MYNODE+1)=COORDS(3*(J1-1)+1,1)
                COORDS(3*(J1-1)+2,MYNODE+1)=COORDS(3*(J1-1)+2,1)
                COORDS(3*(J1-1)+3,MYNODE+1)=COORDS(3*(J1-1)+3,1)
             ENDDO
         ENDIF
      ENDIF

      ITRAJ=MYNODE
      NEACCEPT=0
      MINIMANUMBER=0
      IENR=0 ! DJW APPEARED TO BE UNINITIALISED ?
      PEINT=(PTEMAX-PTEMIN)/NENRPER
!     IF (QUENCHDOS) MAXEFALL=-PEINT ! to prevent a minimisation jumping over PE bins
      MAXEFALL=-1.0D100
      HISTINT=(HISTMAX-HISTMIN)/HBINS
      DO I=1, HBINS
!        BINLABEL(I)=HISTMIN + HISTINT*(I-0.5D0) ! these energies point to the middle of the quench bin
         BINLABEL(I)=HISTMIN + HISTINT*(I-1.0D0) ! these energies point to the bottom of the quench bin
      ENDDO

! Initialisation

      CUNIT=900+MYNODE+1
      WRITE(CFNAME,'(A7,I3,A4)') 'config.',CUNIT,'.xyz'
!     OPEN(UNIT=CUNIT,FILE=CFNAME,STATUS='UNKNOWN')

      DO I=1,NATOMS
         X(I)=COORDS(3*(I-1)+1,MYNODE+1)
         Y(I)=COORDS(3*(I-1)+2,MYNODE+1)
         Z(I)=COORDS(3*(I-1)+3,MYNODE+1)
      ENDDO
      DO I=1,NATOMS
         Q(1,I)=X(I)
         Q(2,I)=Y(I)
         Q(3,I)=Z(I)
      ENDDO

      CTE=(LOG(PTTMAX/PTTMIN))/(NTRAJ-1)
      CTE=EXP(CTE)

      DO I=0, NTRAJ-1
         TEMPTRAJ(I)=PTTMIN*CTE**I
         T=TEMPTRAJ(I)
         BETA(I)=1.0D0/T
      ENDDO

      CALL POTENTIAL(COORDS(:,MYNODE+1),GRAD, POTEL, .TRUE., .FALSE.)
      VOLD=POTEL
      WRITE(MYUNIT,'(2(A,G20.10))') 'bspt> Initial configuration energy is ',VOLD
!     WRITE(MYUNIT,'(2(A,G20.10))') 'bspt> NOT QUENCHING initial config'
      CALL QUENCH(.FALSE.,MYNODE+1,LBFGS_ITERATIONS,DUMMY,NDUMMY,CONVERGED,COORDS(:,MYNODE+1),DOSSTATS)
      WRITE(MYUNIT,'(A,G20.10)') 'bspt> Initial configuration has been quenched to energy ',POTEL
      LBFGS_ITERATIONS=0
      LBFGS_ITERATIONSO=0 ! so that we don't use quench DoS statistics from arbitrary high energy
      VOLD=POTEL
      DO I=1,NATOMS
         X(I)=COORDS(3*(I-1)+1,MYNODE+1)
         Y(I)=COORDS(3*(I-1)+2,MYNODE+1)
         Z(I)=COORDS(3*(I-1)+3,MYNODE+1)
      ENDDO
      DO I=1,NATOMS
         Q(1,I)=X(I)
         Q(2,I)=Y(I)
         Q(3,I)=Z(I)
      ENDDO

      IF (PERIODIC) THEN
         CALL QORDER_BLJ(Q,Q4,Q6)
      ELSE IF (CHRMMT) THEN
           IF (ODIHET) CALL CHCALCDIHE(DIHEORDERPARAM,COORDS(1:3*NATOMS,MYNODE+1))
           IF (OSASAT) CALL ORDER_SASA(SASAORDERPARAM,RPRO,COORDS(1:3*NATOMS:3,MYNODE+1),
     1             COORDS(2:3*NATOMS:3,MYNODE+1),COORDS(3:3*NATOMS:3,MYNODE+1))
           IF (ORGYT) CALL CHCALCRGYR(RGYR,COORDS(1:3*NATOMS:3,MYNODE+1),
     1             COORDS(2:3*NATOMS:3,MYNODE+1),COORDS(3:3*NATOMS:3,MYNODE+1),.FALSE.) 
           IF (OEINTT) CALL CHCALCEINT(EINT,COORDS(1:3*NATOMS:3,MYNODE+1),
     1             COORDS(2:3*NATOMS:3,MYNODE+1),COORDS(3:3*NATOMS:3,MYNODE+1),POTEL)
      ELSE
         CALL QORDER_LJ(Q,Q4,Q6)
      ENDIF

      WRITE(MYUNIT, '(A,2G20.10)') 'bspt> Temperature range', TEMPTRAJ(0), TEMPTRAJ(NTRAJ-1)
      WRITE(MYUNIT, '(A,G20.10)') 'bspt> This temperature trajectory=', TEMPTRAJ(MYNODE)
      VMINOLD=VOLD
      IF (PERIODIC) WRITE(MYUNIT, '(A, 2G20.10)') 'bspt> Starting Q4, Q6=', Q4, Q6
      IF (CHRMMT) THEN
        IF (OSASAT)  WRITE(MYUNIT, '(A, 2G20.10)') 'bspt> Starting Met-enk order params=', 
     1                                         DIHEORDERPARAM, SASAORDERPARAM 
        IF (ORGYT)  WRITE(MYUNIT, '(A, G20.10)') 'bspt> Starting Rgyr order params=', 
     1                                          RGYR 
        IF (OEINTT) WRITE(MYUNIT, '(A, G20.10)') 'bspt> Starting Eint order params=',
     1                                          EINT
      ENDIF

! Initialisation complete

      RNDSEED=2002+MYNODE
      CALL SDPRND(RNDSEED)
      RANDOM=DPRAND()
      WRITE(MYUNIT, '(A, G20.10)') 'bspt> Starting random number=', RANDOM
      IF (FIXSTEP(MYNODE+1).OR.FIXBOTH(MYNODE+1)) THEN
         WRITE(MYUNIT, '(A,G20.10,A)') 'bspt> Starting stepsize ', STEP(MYNODE+1),' (fixed)'
      ELSE
         WRITE(MYUNIT, '(A,G20.10,A)') 'bspt> Starting stepsize ', STEP(MYNODE+1),' (will be dynamically adjusted)'
      ENDIF
      CALL FLUSH(MYUNIT)

      NTOT=0

      NACCEPTPT(MYNODE)=0
      IACCEPT(MYNODE)=0
      EAV(MYNODE)=0.
      EAV2(MYNODE)=0.
      Q4AV(MYNODE)=0.
      Q6AV(MYNODE)=0.
      Q4AV2(MYNODE)=0.
      Q6AV2(MYNODE)=0.
      DIHEORDERPARAM_AV(MYNODE)=0.
      SASAORDERPARAM_AV(MYNODE)=0.
      DIHEORDERPARAM_AV2(MYNODE)=0.
      SASAORDERPARAM_AV2(MYNODE)=0.
      RGYR_AV(MYNODE)=0.
      EINT_AV(MYNODE)=0.
      RGYR_AV2(MYNODE)=0.
      EINT_AV2(MYNODE)=0.
      DO I=1,NHIST
         NHISTQ4(I,MYNODE)=0
         NHISTQ6(I,MYNODE)=0
      ENDDO
      DO I=1,NHISTE
         NHISTQE(I,MYNODE)=0
      ENDDO
      NHISTALLQ(:,:,MYNODE)=0
      NHISTGRAND(:,:,:,MYNODE)=0
      QVISITS(:,MYNODE)=0
      PEVISITS(:,MYNODE)=0
      PEVISITS2(:,:,MYNODE)=0
      DISTANCE(:,MYNODE)=0.0D0
      DISTANCE_AV(:,MYNODE)=0.0D0
      DELTA_EAV(MYNODE)=0.0D0

      Q4MAX=0.1
      Q6MAX=0.5 ! WILL HAVE TO CHANGE AS IS RATHER SYSTEM-SPECIFIC
      DIHEORDERPARAM_MIN=0.4D0
      DIHEORDERPARAM_MAX=1.0D0
      SASAORDERPARAM_MIN=300.0D0
      SASAORDERPARAM_MAX=800.0D0
      RGYR_MIN=4.0D0
      RGYR_MAX=12.0D0
      EINT_MIN=-35.0
      EINT_MAX=10.0
      DDIHE=(DIHEORDERPARAM_MAX-DIHEORDERPARAM_MIN)/(NHIST-1)
      DSASA=(SASAORDERPARAM_MAX-SASAORDERPARAM_MIN)/(NHIST-1)
      DRGYR=(RGYR_MAX-RGYR_MIN)/(NHIST-1)
      DEINT=(EINT_MAX-EINT_MIN)/(NHIST-1)
      DQ4=Q4MAX/(NHIST-1)
      DQ6=Q6MAX/(NHIST-1)
      DHISTE=(PTEMAX-PTEMIN)/(NHISTE-1)

      ENUL=VOLD

      IF (MYNODE.EQ.0) THEN
         OPEN(UNIT=10, FILE='distributions.header', FORM='formatted')
         WRITE(10,*) NATOMS
         WRITE(10,*) NTRAJ, PTSTEPS/NENRPER, NENRPER
         WRITE(10,*) ENUL
         CLOSE(10)
      ENDIF 
!
! NUPDATE specifies the interval for dynamically altering the maximum step size.
! Only used if step size isn't fixed.
!
      NUPDATE=100
!
! Main loop over steps.
!
      DO I=1,PTSTEPS+NEQUIL
         RECOUNT=.FALSE.
         IF (CHRMMT) THEN
            DO K=1,NATOMS
              COORDS(3*(K-1)+1,MYNODE+1)=X(K)
              COORDS(3*(K-1)+2,MYNODE+1)=Y(K)
              COORDS(3*(K-1)+3,MYNODE+1)=Z(K)
            ENDDO
            DO K=1, NATOMS
               XO(K)=X(K)
               YO(K)=Y(K)
               ZO(K)=Z(K)
            ENDDO
            IF (FIXEDENDMOVET) THEN 
! step in internal coordinates
               IF(CHRIGIDROTT) CALL MKRIGIDROT(MYNODE+1)
               IF(CHRIGIDTRANST) CALL MKRIGIDTRANS(MYNODE+1)
               CALL TAKESTEPCH(MYNODE+1)
! new geometry is now in coords
               IF (FIXCOM) CALL CENTRECOM(COORDS(1:3*NATOMS,MYNODE+1))
               DO K=1,NATOMS
                  X(K)=COORDS(3*(K-1)+1,MYNODE+1)
                  Y(K)=COORDS(3*(K-1)+2,MYNODE+1)
                  Z(K)=COORDS(3*(K-1)+3,MYNODE+1)
               ENDDO
               FITS=.TRUE.
            ENDIF
         ELSE 
            DO K=1, NATOMS
               XO(K)=X(K)
               YO(K)=Y(K)
               ZO(K)=Z(K)
            ENDDO
!
! If a move is rejected, the result for the current configuration
! should be recounted. This allows for the unsymmetrical forward
! and backward move probabilities for an atom near the surface of
! the constraining sphere.
!             
            DO K=1,NATOMS
               RANDOM=DPRAND()
               X(K) = X(K) + 2.0D0*RANDOM*STEP(MYNODE+1)-STEP(MYNODE+1)  
               RANDOM=DPRAND()
               Y(K) = Y(K) + 2.0D0*RANDOM*STEP(MYNODE+1)-STEP(MYNODE+1)  
               RANDOM=DPRAND()
               Z(K) = Z(K) + 2.0D0*RANDOM*STEP(MYNODE+1)-STEP(MYNODE+1)  
            ENDDO
!
! Should probably worry about centre of coordinates versus centre of mass
! for heteroatomic systems.
!
            IF (CENT) THEN
               CX=0.0D0; CY=0.0D0; CZ=0.0D0
               DO K=1,NATOMS
                  CX=CX+X(K); CY=CY+Y(K); CZ=CZ+Z(K)
               ENDDO
               CX=CX/NATOMS; CY=CY/NATOMS; CZ=CZ/NATOMS
               DO K=1,NATOMS
                  X(K)=X(K)-CX; Y(K)=Y(K)-CY; Z(K)=Z(K)-CZ
               ENDDO
            ENDIF 
            cloop: DO K=1,NATOMS
               DIST=X(K)**2+Y(K)**2+Z(K)**2
               IF (DIST.GT.RADIUS) THEN
                  IF (MOD(I-1,PRTFRQ).EQ.0) WRITE(MYUNIT,'(A,I6,A)') 'bstp> Perturbed atom ',K,
     &                       ' outside container, recount previous configuration results'
                  RECOUNT=.TRUE. ! The right way to deal with rejected steps!
                  EXIT cloop
               ENDIF
            ENDDO cloop
                   
            DO K=1,NATOMS
               COORDS(3*(K-1)+1,MYNODE+1)=X(K)
               COORDS(3*(K-1)+2,MYNODE+1)=Y(K)
               COORDS(3*(K-1)+3,MYNODE+1)=Z(K)
            ENDDO
         ENDIF
!
! At this point all we have done is take a step. The perturbed coordinates are in both
! COORDS and X, Y, Z. The old coordinates are in XO, YO, ZO.
!
! New and old quench energies will be in        VMINNEW VMINOLD
! New and old instantaneous energies will be in    VNEW    VOLD
!
         CALL POTENTIAL(COORDS(:,MYNODE+1),GRAD, POTEL, .TRUE., .FALSE.)
         VNEW=POTEL
         WCOMP=(VNEW-VOLD)*BETA(MYNODE) ! use difference in instantaneous energies
         W=MIN(1.0D0,EXP(-WCOMP))
         RANDOM=DPRAND()
         IF (RANDOM.GT.W) RECOUNT=.TRUE. ! RECOUNT is initialised to .FALSE. at the top of the loop
!
! Quenching part if required.
! COORDSO saves the perturbed coordinates before the quench in order to calculate
! a quench distance. Should no longer be needed. COORDS are used as scratch for quenches.
!
         COORDSO(:,MYNODE+1)=COORDS(:,MYNODE+1) 
         IF (RECOUNT.AND.BSPT) THEN
            VMINNEW=0.0D0
            LBFGS_ITERATIONS=0
         ENDIF
         IF ((.NOT.RECOUNT).AND.BSPT) THEN 
            IF (MOD(I,QUENCHFRQ).EQ.0) THEN 
               WRITE(MYUNIT, '(A)') 'bspt> calling quench'
               CALL QUENCH(.FALSE.,MYNODE+1,LBFGS_ITERATIONS,DUMMY,NDUMMY,CONVERGED,COORDS(:,MYNODE+1),DOSSTATS)
               IF (CONVERGED.NE.1) WRITE(MYUNIT, '(A)') 'bspt> WARNING - quench did not converge' 
               VMINNEW=POTEL
               NQ(MYNODE+1)=NQ(MYNODE+1)+1
               MINCOORDS(:,MYNODE+1)=COORDS(:,MYNODE+1) ! MINCOORDS contains quench coords
            ELSE
               VMINNEW=0.0D0
               LBFGS_ITERATIONS=0
               EVAPREJECT=.FALSE.
               CONVERGED=1
               POTEL=HUGE(1.0D0)
            ENDIF
         ELSEIF (RECOUNT.AND.BSPT.AND.(VMINOLD.EQ.0.0D0).AND.(MOD(I,QUENCHFRQ).EQ.0)) THEN
!
! We might not have quenched at the step to be recounted, so we have to do so here.
!
            IF (DEBUG) WRITE(MYUNIT, '(A,G20.10,A)') 'bspt> recounting step for previous configuration with VMINOLD=',
     &                                     VMINOLD,' need to call quench'
            DO K=1,NATOMS
              COORDS(3*(K-1)+1,MYNODE+1)=XO(K)
              COORDS(3*(K-1)+2,MYNODE+1)=YO(K)
              COORDS(3*(K-1)+3,MYNODE+1)=ZO(K)
            ENDDO
            WRITE(MYUNIT, '(A)') 'bspt> calling quench for recount'
            CALL QUENCH(.FALSE.,MYNODE+1,LBFGS_ITERATIONS,DUMMY,NDUMMY,CONVERGED,COORDS(:,MYNODE+1),DOSSTATS)
            NQ(MYNODE+1)=NQ(MYNODE+1)+1
            MINCOORDS(:,MYNODE+1)=COORDS(:,MYNODE+1) ! MINCOORDS contains quench coords
            VMINOLD=POTEL
            IF (CONVERGED.NE.1) WRITE(MYUNIT, '(A)') 'bspt> WARNING - quench did not converge' 
            IF (DEBUG) WRITE(MYUNIT, '(A,G20.10)') 'bspt> VMINOLD set to ',VMINOLD
         ENDIF

         VMINNEWSAVE=VMINNEW
         LBFGS_ITERATIONSSAVE=LBFGS_ITERATIONS
         VNEWSAVE=VNEW        ! this value is saved so it can be printed if the step is rejected
         IF ((CONVERGED.NE.1).OR.EVAPREJECT) RECOUNT=.TRUE. ! reject and recount
         IF (RECOUNT) THEN ! reject move
            DO K=1, NATOMS
               X(K)=XO(K)
               Y(K)=YO(K)
               Z(K)=ZO(K)
            ENDDO
            DO K=1,NATOMS
              COORDS(3*(K-1)+1,MYNODE+1)=X(K)
              COORDS(3*(K-1)+2,MYNODE+1)=Y(K)
              COORDS(3*(K-1)+3,MYNODE+1)=Z(K)
            ENDDO
            VMINNEW=VMINOLD
            VNEW=VOLD
            DOSSTATS(1:MAXIT,1:2)=DOSSTATSO(1:MAXIT,1:2)
            LBFGS_ITERATIONS=LBFGS_ITERATIONSO
            IF (.NOT.FITS) NOUT(MYNODE)=NOUT(MYNODE)+1
         ELSE ! accept move
            NACCEPTPT(MYNODE)=NACCEPTPT(MYNODE)+1
            IACCEPT(MYNODE)=IACCEPT(MYNODE)+1
         ENDIF
         IF (.NOT.RECOUNT) THEN
            IF (MOD(I-1,PRTFRQ).EQ.0) WRITE(MYUNIT, '(I10,A,G16.6,A,G16.6,A,G16.6,A,G16.6,A,I6,A)') 
     &        I,' En= ', VMINNEWSAVE, ' Eo= ',VMINOLD, ' Vn=', VNEWSAVE,' Vo=',VOLD,' iter ',LBFGS_ITERATIONSSAVE,' ACC'
         ELSE
            IF (MOD(I-1,PRTFRQ).EQ.0) WRITE(MYUNIT, '(I10,A,G16.6,A,G16.6,A,G16.6,A,G16.6,A,I6,A)') 
     &        I,' En= ', VMINNEWSAVE, ' Eo= ',VMINOLD, ' Vn=', VNEWSAVE,' Vo=',VOLD,' iter ',LBFGS_ITERATIONSSAVE,' REJ'
         ENDIF
         IF (DEBUG) THEN
            CALL POTENTIAL(COORDS(:,MYNODE+1),GRAD, POTEL, .TRUE., .FALSE.)
            WRITE(MYUNIT,'(A,G20.10)') 'bspt> potential energy after acc/rej=',POTEL
         ENDIF
         CALL FLUSH(MYUNIT)
!
!  At this point the quench and instantaneous energies for the current
!  configuration in the Markov chain are VMINNEW and VNEW.
!
         IF (MOD(I,QUENCHFRQ).EQ.0) BININDEX=INT((VMINNEW-HISTMIN)/HISTINT)+1
         IBININDEX=INT((VNEW-PTEMIN)/PEINT)+1

         IF (BSPT.AND.(MOD(I,QUENCHFRQ).EQ.0)) THEN ! BININDEX could be out of range otherwise
            IF ((MOD(I, SAVENTH).EQ.0).AND.(.NOT.RECOUNT)) THEN 
               CALL SAVEBINSTRUCTURESMPI(POTEL,MINCOORDS(:,MYNODE+1),BININDEX,.TRUE.,MYNODE,NEWENERGY)
               IF (NEWENERGY) THEN
                   MINIMANUMBER(BININDEX, MYNODE)=MINIMANUMBER(BININDEX, MYNODE)+1
               ENDIF
            ENDIF
         ENDIF
!
!  Must not accumulate statistics until we have equilibrated for NEQUIL steps.
!
         IF (I.GT.NEQUIL) THEN
            IF (BSPT.AND.(MOD(I,QUENCHFRQ).EQ.0)) THEN
               IF ((BININDEX.GT.HBINS).OR.(BININDEX.LT.1)) THEN
                  WRITE(MYUNIT,'(A,I6,A,G20.10,A,I8)') 'bspt> WARNING in node ',MYNODE,
     &                ' quench energy is out of range, energy=',VMINNEW,' would be bin ',BININDEX
                  NOUTQBIN=NOUTQBIN+1
               ENDIF
            ENDIF
            IF ((IBININDEX.GT.NENRPER).OR.(IBININDEX.LT.1)) THEN
               WRITE(MYUNIT,'(A,I6,A,G20.10,A,I8)') 'bspt> WARNING in node ',MYNODE,
     &                ' potential energy is out of range, energy=',VNEW,' would be bin ',IBININDEX
               NOUTPEBIN=NOUTPEBIN+1
            ENDIF
            IF (BSPT.AND.(MOD(I,QUENCHFRQ).EQ.0)) THEN
               IF ((BININDEX.GT.HBINS).OR.(BININDEX.LT.1)) GOTO 888
            ENDIF
            IF ((IBININDEX.GT.NENRPER).OR.(IBININDEX.LT.1)) GOTO 888

            PEVISITS(IBININDEX,MYNODE)=PEVISITS(IBININDEX,MYNODE)+1
            IF (BSPT.AND.(MOD(I,QUENCHFRQ).EQ.0)) THEN ! otherwise BININDEX could be out of range
               QVISITS(BININDEX,MYNODE)=QVISITS(BININDEX,MYNODE)+1
               PEVISITS2(IBININDEX,BININDEX,MYNODE)=PEVISITS2(IBININDEX,BININDEX,MYNODE)+1
            ENDIF
            
            IF (BSPT.AND.(MOD(I,QUENCHFRQ).EQ.0)) THEN
               DISTANCEOLD=CALCULATEDDISTANCE(COORDS(:,MYNODE+1), COORDSO(:,MYNODE+1))
               DISTANCE(BININDEX,MYNODE)=DISTANCE(BININDEX,MYNODE)+DISTANCEOLD
            ENDIF
         ENDIF
!
! If we are not calculating distances then the following lines may be unnecessary.
!
! I don't believe that CALCULATEDDISTANCE changes COORDS and COORDSO anyway!
!
888      DO K=1,NATOMS ! COORDS have to be resaved because we have to use noreset to be able to calc distance 
            COORDS(3*(K-1)+1,MYNODE+1)=X(K)
            COORDS(3*(K-1)+2,MYNODE+1)=Y(K)
            COORDS(3*(K-1)+3,MYNODE+1)=Z(K)
         ENDDO
!
!  VMINOLD is now set to VMINNEW and VOLD to VNEW.
!
         VOLD=VNEW
         VMINOLD=VMINNEW 

         DOSSTATSO(1:MAXIT,1:2)=DOSSTATS(1:MAXIT,1:2)
         LBFGS_ITERATIONSO=LBFGS_ITERATIONS

C        IF ((I.LE.100000).AND.(MOD(I,NUPDATE).EQ.0)) THEN ! DJW test !!!
         IF ((I.LE.NEQUIL).AND.(MOD(I,NUPDATE).EQ.0)) THEN ! update MC step size if not fixed
            WAC=1.0*IACCEPT(MYNODE)/NUPDATE
            IF (.NOT.(FIXSTEP(MYNODE+1).OR.FIXBOTH(MYNODE+1))) THEN
               IF (WAC.LT.0.4) THEN
                  STEP(MYNODE+1)=STEP(MYNODE+1)*0.9D0
               ENDIF
               IF (WAC.GT.0.6) THEN
                  STEP(MYNODE+1)=STEP(MYNODE+1)*1.1D0
               ENDIF
            ENDIF
            IACCEPT(MYNODE)=0
            WRITE(MYUNIT,'(A,G20.10)') 'bspt> maximum step size is now ',STEP(MYNODE+1)
         ENDIF
         WRITE(MYUNIT,'(A,G20.10,A,2I8)') 'bspt> maximum step size is now ',STEP(MYNODE+1),' I,NEQUIL=',I,NEQUIL
!
!  Replica exchange part follows. 

         E=VNEW
         IF (MYNODE.EQ.0) THEN
            RANDOM=DPRAND()
            J=(NTRAJ-1)*RANDOM
            RANDOM=DPRAND()
            IF (RANDOM.GT.EXCHPROB) THEN 
               J=-2
               EXCHANGE=.FALSE.
            ELSE
               EXCHANGE=.TRUE.
            ENDIF
         ENDIF
!
! J is set to -2 for no exchange. Should really just skip the next part?!
! We try to exchange with trajectory J+1. J starts from 0.
!
         CALL MPI_BCAST(J,1,MPI_INTEGER,0,MPI_COMM_WORLD, MPIERR)
         IF (MYNODE.EQ.(J+1)) THEN
             CALL MPI_SEND(E,1,MPI_DOUBLE_PRECISION,J,0,MPI_COMM_WORLD,MPIERR)
         ENDIF
         IF (MYNODE.EQ.J) THEN
            CALL MPI_RECV(ER,1,MPI_DOUBLE_PRECISION,J+1,0,MPI_COMM_WORLD,IS,MPIERR)

            DBETA=BETA(J)-BETA(J+1)
            DELTA=E-ER
            W=MIN(1.0D0,DEXP(DELTA*DBETA))
            NTOT=NTOT+1 
            RANDOM=DPRAND()
            LESAVE=E
            IF (W.GT.RANDOM) THEN
               EXCHANGEACCEPT=.TRUE.
               IMESG=1
               CALL MPI_SEND(IMESG,1,MPI_INTEGER,J+1,0,MPI_COMM_WORLD,MPIERR)
               CALL MPI_SEND(ITRAJ,1,MPI_INTEGER,J+1,0,MPI_COMM_WORLD,MPIERR)
               CALL MPI_SEND(X,NATOMS,MPI_DOUBLE_PRECISION,J+1,1,MPI_COMM_WORLD,MPIERR)
               CALL MPI_SEND(Y,NATOMS,MPI_DOUBLE_PRECISION,J+1,1,MPI_COMM_WORLD,MPIERR)
               CALL MPI_SEND(Z,NATOMS,MPI_DOUBLE_PRECISION,J+1,1,MPI_COMM_WORLD,MPIERR)
               CALL MPI_SEND(VMINNEW,1,MPI_DOUBLE_PRECISION,J+1,1,MPI_COMM_WORLD,MPIERR)
               CALL MPI_SEND(VNEW,1,MPI_DOUBLE_PRECISION,J+1,1,MPI_COMM_WORLD,MPIERR)
               CALL MPI_SEND(DOSSTATS,2*MAXIT,MPI_DOUBLE_PRECISION,J+1,1,MPI_COMM_WORLD,MPIERR)
               CALL MPI_SEND(LBFGS_ITERATIONS,1,MPI_INTEGER,J+1,1,MPI_COMM_WORLD,MPIERR)
               CALL MPI_RECV(ITRAJ,1,MPI_INTEGER,J+1,0,MPI_COMM_WORLD,IS,MPIERR)
               CALL MPI_RECV(X,NATOMS,MPI_DOUBLE_PRECISION,J+1,1,MPI_COMM_WORLD,IS,MPIERR)
               CALL MPI_RECV(Y,NATOMS,MPI_DOUBLE_PRECISION,J+1,1,MPI_COMM_WORLD,IS,MPIERR)
               CALL MPI_RECV(Z,NATOMS,MPI_DOUBLE_PRECISION,J+1,1,MPI_COMM_WORLD,IS,MPIERR)
               CALL MPI_RECV(VMINNEW,1,MPI_DOUBLE_PRECISION,J+1,1,MPI_COMM_WORLD,IS,MPIERR)
               CALL MPI_RECV(VNEW,1,MPI_DOUBLE_PRECISION,J+1,1,MPI_COMM_WORLD,IS,MPIERR)
               CALL MPI_RECV(DOSSTATS,2*MAXIT,MPI_DOUBLE_PRECISION,J+1,1,MPI_COMM_WORLD,IS,MPIERR)
               CALL MPI_RECV(LBFGS_ITERATIONS,1,MPI_DOUBLE_PRECISION,J+1,1,MPI_COMM_WORLD,IS,MPIERR)
               E=ER
               NEACCEPT=NEACCEPT+1
               DOSSTATSO(1:MAXIT,1:2)=DOSSTATS(1:MAXIT,1:2)
               LBFGS_ITERATIONSO=LBFGS_ITERATIONS
               VMINOLD=VMINNEW ! these variables are the same at this point in the program
               VOLD=VNEW
            ELSE
               EXCHANGEACCEPT=.FALSE.
               IMESG=0
               CALL MPI_SEND(IMESG,1,MPI_INTEGER,J+1,0,MPI_COMM_WORLD,MPIERR)
            ENDIF
            IF (EXCHANGEACCEPT) THEN
               IF (MOD(I-1,PRTFRQ).EQ.0) WRITE(MYUNIT,'(A,I5,A,G16.6,A,I5,A,G16.6,A)') 
     &                        'bspt> Exchange from this replica ',J,' energy ',LESAVE,
     &                                                         ' to replica ',J+1,' energy ',ER,' ACC'
               IF (DEBUG) THEN
                  WRITE(MYUNIT,'(A,G20.10)') 'bspt> Instantaneous PE is now ',VOLD

                  DO K=1,NATOMS
                     COORDS(3*(K-1)+1,MYNODE+1)=X(K)
                     COORDS(3*(K-1)+2,MYNODE+1)=Y(K)
                     COORDS(3*(K-1)+3,MYNODE+1)=Z(K)
                  ENDDO
                  CALL POTENTIAL(COORDS(:,MYNODE+1),GRAD, POTEL, .TRUE., .FALSE.)
                  WRITE(MYUNIT,'(A,G20.10)') 'bspt> Recalculated PE is ',POTEL,' VNEW=',VNEW
               ENDIF

            ELSE
               IF (MOD(I-1,PRTFRQ).EQ.0) WRITE(MYUNIT,'(A,I5,A,G16.6,A,I5,A,G16.6,A)') 
     &                    'bspt> Exchange from this replica ',J,' energy ',E,' to replica ',
     &                           J+1,' energy ',ER,' REJ'
            ENDIF
         ENDIF
         IF (MYNODE.EQ.(J+1)) THEN
            CALL MPI_RECV(IMESG,1,MPI_INTEGER,J,0,MPI_COMM_WORLD,IS,MPIERR)
            NTOT=NTOT+1
            ER=E
            IF (IMESG.EQ.1) THEN
!
!  Here we receive first, so we need to save variables that would otherwise be overwritten
!  before they are sent to the other replica. Or use XO, YO, ZO in the case of X, Y, Z.
!
               VOLDSAVE=VOLD
               DOSSTATSO(1:MAXIT,1:2)=DOSSTATS(1:MAXIT,1:2)
               LBFGS_ITERATIONSO=LBFGS_ITERATIONS
               CALL MPI_RECV(ITRAJO,1,MPI_INTEGER,J,0,MPI_COMM_WORLD,IS,MPIERR)
               CALL MPI_RECV(XO,NATOMS,MPI_DOUBLE_PRECISION,J,1,MPI_COMM_WORLD,IS,MPIERR)
               CALL MPI_RECV(YO,NATOMS,MPI_DOUBLE_PRECISION,J,1,MPI_COMM_WORLD,IS,MPIERR)
               CALL MPI_RECV(ZO,NATOMS,MPI_DOUBLE_PRECISION,J,1,MPI_COMM_WORLD,IS,MPIERR)
               CALL MPI_RECV(VMINOLD,1,MPI_DOUBLE_PRECISION,J,1,MPI_COMM_WORLD,IS,MPIERR)
               CALL MPI_RECV(VOLD,1,MPI_DOUBLE_PRECISION,J,1,MPI_COMM_WORLD,IS,MPIERR)
               CALL MPI_RECV(DOSSTATS,2*MAXIT,MPI_DOUBLE_PRECISION,J,1,MPI_COMM_WORLD,IS,MPIERR)
               CALL MPI_RECV(LBFGS_ITERATIONS,1,MPI_INTEGER,J,1,MPI_COMM_WORLD,IS,MPIERR)
               CALL MPI_SEND(ITRAJ,1,MPI_INTEGER,J,0,MPI_COMM_WORLD,MPIERR)
               CALL MPI_SEND(X,NATOMS,MPI_DOUBLE_PRECISION,J,1,MPI_COMM_WORLD,MPIERR)
               CALL MPI_SEND(Y,NATOMS,MPI_DOUBLE_PRECISION,J,1,MPI_COMM_WORLD,MPIERR)
               CALL MPI_SEND(Z,NATOMS,MPI_DOUBLE_PRECISION,J,1,MPI_COMM_WORLD,MPIERR)
               CALL MPI_SEND(VMINNEW,1,MPI_DOUBLE_PRECISION,J,1,MPI_COMM_WORLD,IS,MPIERR)
               CALL MPI_SEND(VNEW,1,MPI_DOUBLE_PRECISION,J,1,MPI_COMM_WORLD,IS,MPIERR)
               CALL MPI_SEND(DOSSTATSO,2*MAXIT,MPI_DOUBLE_PRECISION,J,1,MPI_COMM_WORLD,IS,MPIERR)
               CALL MPI_SEND(LBFGS_ITERATIONSO,1,MPI_DOUBLE_PRECISION,J,1,MPI_COMM_WORLD,IS,MPIERR)
               DO K=1, NATOMS
                  X(K)=XO(K)
                  Y(K)=YO(K)
                  Z(K)=ZO(K)
               ENDDO
               ITRAJ=ITRAJO
               NEACCEPT=NEACCEPT+1
               DOSSTATSO(1:MAXIT,1:2)=DOSSTATS(1:MAXIT,1:2)
               LBFGS_ITERATIONSO=LBFGS_ITERATIONS
               IF (MOD(I-1,PRTFRQ).EQ.0) WRITE(MYUNIT,'(A,I5,A,G16.6,A,I5,A,G16.6,A)') 
     &                     'bspt> Exchange from replica ',MYNODE-1,' energy ',VOLD,
     &                                                         ' to this replica ',MYNODE,' energy ',VNEW,' ACC'
               VMINNEW=VMINOLD ! these variables are the same at this point in the program
               VNEW=VOLD
               IF (DEBUG) THEN
                  WRITE(MYUNIT,'(A,G20.10)') 'bspt> Instantaneous PE is now ',VOLD,' and VNEW=',VNEW

                  DO K=1,NATOMS
                     COORDS(3*(K-1)+1,MYNODE+1)=X(K)
                     COORDS(3*(K-1)+2,MYNODE+1)=Y(K)
                     COORDS(3*(K-1)+3,MYNODE+1)=Z(K)
                  ENDDO
                  CALL POTENTIAL(COORDS(:,MYNODE+1),GRAD, POTEL, .TRUE., .FALSE.)
                  WRITE(MYUNIT,'(A,G20.10)') 'bspt> Recalculated PE is ',POTEL
               ENDIF

            ELSE
               IF (MOD(I-1,PRTFRQ).EQ.0) WRITE(MYUNIT,'(A,I5,A,I5,A,G16.6,A)') 
     &                   'bspt> Exchange from      replica ',MYNODE-1,
     &                   ' energy not available to this replica ',MYNODE,' energy ',VOLD,' REJ'
            ENDIF
         ENDIF

!        IF (PTMC) VOLD=E
!        IF (BSPT) VMINOLD=E
!        VOLD=E

         IF (I.GT.NEQUIL) THEN 
            EAV(MYNODE)=EAV(MYNODE)+E
            EAV2(MYNODE)=EAV2(MYNODE)+E**2
            IQE=INT((E-PTEMIN)/DHISTE+1)
            IF (IQE.GT.0.AND.IQE.LT.NHISTE) THEN
               NHISTQE(IQE,MYNODE)=NHISTQE(IQE,MYNODE)+1
            ENDIF
            DO K=1,NATOMS
               Q(1,K)=X(K)
               Q(2,K)=Y(K)
               Q(3,K)=Z(K)
            ENDDO
            IF (PERIODIC) THEN
               CALL QORDER_BLJ(Q,Q4,Q6)
            ELSE IF (CHRMMT) THEN
                 IF (ODIHET) CALL CHCALCDIHE(DIHEORDERPARAM,COORDS(1:3*NATOMS,MYNODE+1))
                 IF (OSASAT) CALL ORDER_SASA(SASAORDERPARAM,RPRO,COORDS(1:3*NATOMS:3,MYNODE+1),
     1                   COORDS(2:3*NATOMS:3,MYNODE+1),COORDS(3:3*NATOMS:3,MYNODE+1))
                 IF (ORGYT) CALL CHCALCRGYR(RGYR,COORDS(1:3*NATOMS:3,MYNODE+1),
     1                   COORDS(2:3*NATOMS:3,MYNODE+1),COORDS(3:3*NATOMS:3,MYNODE+1),.FALSE.) 
                 IF (OEINTT) CALL CHCALCEINT(EINT,COORDS(1:3*NATOMS:3,MYNODE+1),
     1                   COORDS(2:3*NATOMS:3,MYNODE+1),COORDS(3:3*NATOMS:3,MYNODE+1),POTEL)
            ELSE
               CALL QORDER_LJ(Q,Q4,Q6)
            ENDIF
            Q4AV(MYNODE)=Q4AV(MYNODE)+Q4
            Q4AV2(MYNODE)=Q4AV2(MYNODE)+Q4**2
            Q6AV(MYNODE)=Q6AV(MYNODE)+Q6
            Q6AV2(MYNODE)=Q6AV2(MYNODE)+Q6**2

            DIHEORDERPARAM_AV(MYNODE)=DIHEORDERPARAM_AV(MYNODE)+DIHEORDERPARAM
            DIHEORDERPARAM_AV2(MYNODE)=DIHEORDERPARAM_AV2(MYNODE)+DIHEORDERPARAM**2
            SASAORDERPARAM_AV(MYNODE)=SASAORDERPARAM_AV(MYNODE)+SASAORDERPARAM
            SASAORDERPARAM_AV2(MYNODE)=SASAORDERPARAM_AV2(MYNODE)+SASAORDERPARAM**2
            RGYR_AV(MYNODE)=RGYR_AV(MYNODE)+RGYR
            RGYR_AV2(MYNODE)=RGYR_AV2(MYNODE)+RGYR**2
            EINT_AV(MYNODE)=EINT_AV(MYNODE)+EINT
            EINT_AV2(MYNODE)=EINT_AV2(MYNODE)+EINT**2
            IF (CHRMMT) THEN
               IF (ODIHET) THEN
                  IQ4=INT((DIHEORDERPARAM-DIHEORDERPARAM_MIN)/DDIHE+1)
                  IF (IQ4.GT.0.AND.IQ4.LT.NHIST) THEN
                     NHISTQ4(IQ4,MYNODE)=NHISTQ4(IQ4,MYNODE)+1
                  ENDIF
                  IQ6=INT((SASAORDERPARAM-SASAORDERPARAM_MIN)/DSASA+1)             
                  IF (IQ6.GT.0.AND.IQ6.LT.NHIST) THEN
                     NHISTQ6(IQ6,MYNODE)=NHISTQ6(IQ6,MYNODE)+1
                  ENDIF
               ELSE IF (ORGYT) THEN
                  IQ4=INT((RGYR-RGYR_MIN)/DRGYR+1)
                  IF (IQ4.GT.0.AND.IQ4.LT.NHIST) THEN
                     NHISTQ4(IQ4,MYNODE)=NHISTQ4(IQ4,MYNODE)+1
                  ENDIF
                  IQ6=INT((EINT-EINT_MIN)/DEINT+1)             
                  IF (IQ6.GT.0.AND.IQ6.LT.NHIST) THEN
                     NHISTQ6(IQ6,MYNODE)=NHISTQ6(IQ6,MYNODE)+1
                  ENDIF
               ENDIF 
            ELSE
               IQ4=INT(Q4/DQ4+1)
               IF (IQ4.GT.0.AND.IQ4.LT.NHIST) THEN
                  NHISTQ4(IQ4,MYNODE)=NHISTQ4(IQ4,MYNODE)+1
               ENDIF
               IQ6=INT(Q6/DQ6+1)             
               IF (IQ6.GT.0.AND.IQ6.LT.NHIST) THEN
                  NHISTQ6(IQ6,MYNODE)=NHISTQ6(IQ6,MYNODE)+1
               ENDIF
            ENDIF

! Free energy statistic

            IF (IQ4.GT.0.AND.IQ4.LT.NHIST.AND.IQ6.GT.0.AND.IQ6.LT.NHIST) THEN
               NHISTALLQ(IQ4,IQ6,MYNODE)=NHISTALLQ(IQ4,IQ6,MYNODE)+1
            ENDIF
            IF (IQ4.GT.0.AND.IQ4.LT.NHIST.AND.IQ6.GT.0.AND.IQ6.LT.NHIST.AND.
     1         IQE.GT.0.AND.IQE.LT.NHISTE) THEN
               NHISTGRAND(IQE,IQ4,IQ6,MYNODE)=NHISTGRAND(IQE,IQ4,IQ6,MYNODE)+1
            ENDIF
              
            IENR=IENR+1
!           IF (PTMC) THEN
!              IF (IENR.EQ.NENRPER) THEN
!                 IENR=0
!                 CALL FLUSH(11+MYNODE)
!                 WRITE(11+MYNODE,*) '#E=',E
!                 DO K=1,NATOMS
!                    WRITE(11+MYNODE,*) X(K),Y(K),Z(K)
!                 ENDDO
!              ENDIF 
!           ENDIF
         ENDIF                   
!
! Dump visits histograms. 
! 
         IF (MOD(I,BSPTDUMPFRQ).EQ.0) THEN
            IF ((I.LT.10000).OR.(I.GE.100000000)) GOTO 111 ! I out of range for intermediate dump
            IF (MYNODE.GE.10) THEN
               IF (I.GE.10000000) THEN
                  WRITE (ISTR, '(I2,A1,I8)') MYNODE, '.', I
               ELSEIF (I.GE.1000000) THEN
                  WRITE (ISTR, '(I2,A1,I7)') MYNODE, '.', I
               ELSEIF (I.GE.100000) THEN
                  WRITE (ISTR, '(I2,A1,I6)') MYNODE, '.', I
               ELSEIF (I.GE.10000) THEN
                  WRITE (ISTR, '(I2,A1,I5)') MYNODE, '.', I
               ENDIF
            ELSE
               IF (I.GE.10000000) THEN
                  WRITE (ISTR, '(I1,A1,I8)') MYNODE, '.', I
               ELSEIF (I.GE.1000000) THEN
                  WRITE (ISTR, '(I1,A1,I7)') MYNODE, '.', I
               ELSEIF (I.GE.100000) THEN
                  WRITE (ISTR, '(I1,A1,I6)') MYNODE, '.', I
               ELSEIF (I.GE.10000) THEN
                  WRITE (ISTR, '(I1,A1,I5)') MYNODE, '.', I
               ENDIF
            ENDIF

            FILENAME101="Visits.his."//trim(adjustl(istr))
            OPEN(UNIT=1986+MYNODE,FILE=FILENAME101, STATUS="unknown", form="formatted")
            WRITE(1986+MYNODE, '(G20.10)') TEMPTRAJ(MYNODE)
            WRITE(1986+MYNODE, '(A)') 'Visits to instantaneous PE bins without quench contributions'
            DO K=1, NENRPER
               WRITE(1986+MYNODE, '(2G20.10,I10)') PTEMIN+(K-1)*PEINT,PEVISITS(K,MYNODE)
            ENDDO
            WRITE(1986+MYNODE, '(A)') 'Visits to quench bins'
            DO K=1, HBINS
                 WRITE(1986+MYNODE, '(G20.10,I10)') BINLABEL(K), QVISITS(K,MYNODE)
            ENDDO
            CLOSE(1986+MYNODE)

            IF (BSPT) THEN
               FILENAME101="Visits2.his."//trim(adjustl(istr))
               OPEN(UNIT=1986+MYNODE,FILE=FILENAME101, STATUS="unknown", form="formatted")
               WRITE(1986+MYNODE, '(G20.10)') TEMPTRAJ(MYNODE)
               DO K=1, NENRPER
                  WRITE(1986+MYNODE, '(A,G20.10)') 'Visits to quench bins for instantaneous PE ',PTEMIN+(K-1)*PEINT
                  DO J1=1, HBINS
                       WRITE(1986+MYNODE, '(G20.10,I10)') BINLABEL(J1), PEVISITS2(K,J1,MYNODE)
                  ENDDO
               ENDDO
               CLOSE(1986+MYNODE)
            ENDIF
111         CONTINUE
         ENDIF
      ENDDO 
 
! End of main loop over BSPT or PT steps.
 
! compute the averages

      EAV(MYNODE)=EAV(MYNODE)/PTSTEPS
      EAV2(MYNODE)=EAV2(MYNODE)/PTSTEPS
      CV=(EAV2(MYNODE)-EAV(MYNODE)**2)*BETA(MYNODE)**2

      WRITE (ISTR, '(i10)') MYNODE+1
      FILENAME3="T.Ev.Cv.Ev2.Steps."//trim(adjustl(istr))
      OPEN(UNIT=41+MYNODE,FILE=FILENAME3, STATUS="unknown", form="formatted")
      IF (CHRMMT) THEN
         WRITE(41+MYNODE,'(6G20.10)') TEMPTRAJ(MYNODE),TEMPTRAJ(MYNODE)/0.001987, 
     &                                EAV(MYNODE), CV, EAV2(MYNODE),PTSTEPS
      ELSE
         WRITE(41+MYNODE,'(5G20.10)') TEMPTRAJ(MYNODE),EAV(MYNODE),CV, EAV2(MYNODE),PTSTEPS
      ENDIF
      CALL FLUSH(41+MYNODE)
      CLOSE(41+MYNODE)

      Q4AV(MYNODE)=Q4AV(MYNODE)/PTSTEPS
      Q6AV(MYNODE)=Q6AV(MYNODE)/PTSTEPS
      Q4AV2(MYNODE)=Q4AV2(MYNODE)/PTSTEPS
      Q6AV2(MYNODE)=Q6AV2(MYNODE)/PTSTEPS
      DIHEORDERPARAM_AV(MYNODE)=DIHEORDERPARAM_AV(MYNODE)/PTSTEPS
      SASAORDERPARAM_AV(MYNODE)=SASAORDERPARAM_AV(MYNODE)/PTSTEPS
      DIHEORDERPARAM_AV2(MYNODE)=DIHEORDERPARAM_AV2(MYNODE)/PTSTEPS
      SASAORDERPARAM_AV2(MYNODE)=SASAORDERPARAM_AV2(MYNODE)/PTSTEPS
      RGYR_AV(MYNODE)=RGYR_AV(MYNODE)/PTSTEPS
      EINT_AV(MYNODE)=EINT_AV(MYNODE)/PTSTEPS
      RGYR_AV2(MYNODE)=RGYR_AV2(MYNODE)/PTSTEPS
      EINT_AV2(MYNODE)=EINT_AV2(MYNODE)/PTSTEPS
      FQ4=SQRT(Q4AV2(MYNODE)-Q4AV(MYNODE)**2)
      FQ6=SQRT(Q6AV2(MYNODE)-Q6AV(MYNODE)**2)
      IF (BINARY) THEN  
         FILENAME4="T.Q4Av.Q6Av.Q4Av2.Q6Av2.Steps."//trim(adjustl(istr))
         OPEN(UNIT=1980,FILE=FILENAME4, STATUS="unknown", form="formatted")
         WRITE(1980,'(6G20.10)') TEMPTRAJ(MYNODE), Q4AV(MYNODE), Q6AV(MYNODE), Q4AV2(MYNODE),Q6AV2(MYNODE), PTSTEPS
         CLOSE(1980)
      ENDIF
      IF (CHRMMT) THEN 
         IF (ODIHET) THEN 
            FILENAME4="T.DiheAv.SasaAv.DiheAv2.SasaAv2.Steps."//trim(adjustl(istr))
            OPEN(UNIT=1980,FILE=FILENAME4, STATUS="unknown", form="formatted")
            WRITE(1980,'(6G20.10)') TEMPTRAJ(MYNODE), DIHEORDERPARAM_AV(MYNODE), 
     &              SASAORDERPARAM_AV(MYNODE), DIHEORDERPARAM_AV2(MYNODE),SASAORDERPARAM_AV2(MYNODE), PTSTEPS
            CLOSE(1980)
            ELSE IF (ORGYT) THEN
            FILENAME4="T.RgyrAv.EintAv.RgyrAv2.Eint2.Steps."//trim(adjustl(istr))
            OPEN(UNIT=1980,FILE=FILENAME4, STATUS="unknown", form="formatted")
            WRITE(1980,'(6G20.10)') TEMPTRAJ(MYNODE), RGYR_AV(MYNODE),EINT_AV(MYNODE), RGYR_AV2(MYNODE),  
     &              EINT_AV2(MYNODE), PTSTEPS
            CLOSE(1980)
         ENDIF
      ENDIF

      FILENAME5="profile_E."//trim(adjustl(istr)) 
      OPEN(UNIT=1981,FILE=FILENAME5, STATUS="unknown", form="formatted")
      DO K=1,NHISTE
         WRITE(1981,'(2G20.10)') PTEMIN+(K-1)*DHISTE,NHISTQE(K,MYNODE)
      ENDDO
      CLOSE(1981)

      IF (BINARY) THEN
         FILENAME6="profile_Q4."//trim(adjustl(istr))
         FILENAME7="profile_Q6."//trim(adjustl(istr))
         OPEN(UNIT=1982,FILE=FILENAME6, STATUS="unknown", form="formatted")
         OPEN(UNIT=1983,FILE=FILENAME7, STATUS="unknown", form="formatted")
         DO K=1,NHIST
            WRITE(1982,'(2G20.10)') (K-1)*DQ4,NHISTQ4(K,MYNODE)
            WRITE(1983,'(2G20.10)') (K-1)*DQ6,NHISTQ6(K,MYNODE)
         ENDDO
         CLOSE(1982)
         CLOSE(1983)
      ELSE IF (CHRMMT) THEN
         IF (ODIHET) THEN
            FILENAME6="profile_dihe."//trim(adjustl(istr))
            FILENAME7="profile_sasa."//trim(adjustl(istr))
            OPEN(UNIT=1982,FILE=FILENAME6, STATUS="unknown", form="formatted")
            OPEN(UNIT=1983,FILE=FILENAME7, STATUS="unknown", form="formatted")
            DO K=1,NHIST
               WRITE(1982,'(2G20.10)') diheorderparam_min+(K-1)*Ddihe,NHISTQ4(K,MYNODE)
               WRITE(1983,'(2G20.10)') SASAorderparam_min+(K-1)*Dsasa,NHISTQ6(K,MYNODE)
            ENDDO
            CLOSE(1982)
            CLOSE(1983)
         ELSE IF (ORGYT) THEN
            FILENAME6="profile_rgyr."//trim(adjustl(istr))
            FILENAME7="profile_eint."//trim(adjustl(istr))
            OPEN(UNIT=1982,FILE=FILENAME6, STATUS="unknown", form="formatted")
            OPEN(UNIT=1983,FILE=FILENAME7, STATUS="unknown", form="formatted")
            DO K=1,NHIST
               WRITE(1982,'(2G20.10)') rgyr_min+(K-1)*Drgyr,NHISTQ4(K,MYNODE)
               WRITE(1983,'(2G20.10)') eint_min+(K-1)*Deint,NHISTQ6(K,MYNODE)
            ENDDO
            CLOSE(1982)
            CLOSE(1983)
         ENDIF
      ENDIF

      WRITE(MYUNIT, '(A,G20.10,A,G20.10,A,F15.5,A)') 'bspt> ',NACCEPTPT(MYNODE), ' steps accepted out of ', 
     &            PTSTEPS+NEQUIL, ' i.e. ',NACCEPTPT(MYNODE)*100.0D0/(PTSTEPS+NEQUIL),'%'
      WRITE(MYUNIT, '(A,G20.10)') 'bspt> Final stepsize ', STEP(MYNODE+1)
      WRITE(MYUNIT, '(A,G20.10,A,G20.10)') 'bspt> ',NEACCEPT, ' PT exchanges accepted out of ', NTOT
      IF (BSPT) WRITE(MYUNIT, '(A,G20.10,A,G20.10)') 'bspt> ',NOUTQBIN, ' quenches outside quench bin range'
      WRITE(MYUNIT, '(A,I8,A,G20.10,A)') 'bspt> ',NOUTPEBIN, ' potential energies outside bin range: ',
     &                                      NOUTPEBIN*100.0D0/(PTSTEPS+NEQUIL),' %'
      WRITE(MYUNIT, '(A,I8,A,G20.10,A)') 'bspt> ',NOUTPEBIN, ' potential energies outside bin range: ',
     &                                      NOUTPEBIN*100.0D0/(PTSTEPS+NEQUIL),' %'
      WRITE(MYUNIT, '(A,I8)') 'bspt> total number of quenches=',NQ(MYNODE+1)

      DO K=1,NATOMS
         Q(1,K)=X(K)
         Q(2,K)=Y(K)
         Q(3,K)=Z(K)
      ENDDO
      IF (PERIODIC) THEN
         CALL QORDER_BLJ(Q,Q4,Q6)
      ELSE
         CALL QORDER_LJ(Q,Q4,Q6)
      ENDIF

!     IF (PTMC) THEN
!        WRITE (ISTR, '(i10)') MYNODE+1
!        FILENAME5="FreeEnStatHistO1.HistO2."//trim(adjustl(istr)) 
!        OPEN(UNIT=747+MYNODE,FILE=FILENAME5, STATUS="unknown", form="formatted")
!           DO J=1,NHIST
!              DO I=1,NHIST
!                  WRITE(747+MYNODE,'(G20.10)') NHISTALLQ(i,j,MYNODE)
!              ENDDO
!           ENDDO
!        CLOSE(747+MYNODE)
!        WRITE (ISTR, '(i10)') MYNODE+1
!        FILENAME12="FreeEnStatHistE.HistO1.HistO2."//trim(adjustl(istr))
!        OPEN(UNIT=447+MYNODE,FILE=FILENAME12, STATUS="unknown", form="formatted")
!        DO K=1,NHISTE
!           DO J=1,NHIST
!              DO I=1,NHIST
!                 IF (NHISTGRAND(K,I,J,MYNODE).NE.0) THEN
!                 WRITE(447+MYNODE,'(4I10)') k,i,j,NHISTGRAND(k,i,j,MYNODE)
!                 ENDIF
!              ENDDO
!           ENDDO
!        ENDDO
!        CLOSE(447+MYNODE)
!     ENDIF
!
! Dump visits histograms. Energies are written for the middle of the bins.
! This is the really important part!
!
      WRITE (ISTR, '(i10)') MYNODE 
      FILENAME101="Visits.his."//trim(adjustl(istr))
      OPEN(UNIT=1986+MYNODE,FILE=FILENAME101, STATUS="unknown", form="formatted")
      WRITE(1986+MYNODE, '(G20.10)') TEMPTRAJ(MYNODE)
      WRITE(1986+MYNODE, '(A)') 'Visits to instantaneous PE bins without quench contributions'
      DO K=1, NENRPER
         WRITE(1986+MYNODE, '(2G20.10,I10)') PTEMIN+(K-1)*PEINT,PEVISITS(K,MYNODE)
      ENDDO
      WRITE(1986+MYNODE, '(A)') 'Visits to quench bins'
      DO K=1, HBINS
           WRITE(1986+MYNODE, '(G20.10,I10)') BINLABEL(K), QVISITS(K,MYNODE)
      ENDDO
      CLOSE(1986+MYNODE)

      IF (BSPT) THEN
         FILENAME101="Visits2.his."//trim(adjustl(istr))
         OPEN(UNIT=1986+MYNODE,FILE=FILENAME101, STATUS="unknown", form="formatted")
         WRITE(1986+MYNODE, '(G20.10)') TEMPTRAJ(MYNODE)
         DO K=1, NENRPER
            WRITE(1986+MYNODE, '(A,G20.10)') 'Visits to quench bins for instantaneous PE ',PTEMIN+(K-1)*PEINT
            DO J1=1, HBINS
                 WRITE(1986+MYNODE, '(G20.10,I10)') BINLABEL(J1), PEVISITS2(K,J1,MYNODE)
            ENDDO
         ENDDO
         CLOSE(1986+MYNODE)
      ENDIF

      IF (HISTRESTART) THEN
         WRITE (ISTR, '(i10)') MYNODE+1
         FILENAME9="xyz_out."//trim(adjustl(istr))
      ELSE
         WRITE (ISTR, '(i10)') MYNODE+1
         FILENAME9="xyz_out."//trim(adjustl(istr))
      ENDIF
      OPEN(UNIT=1985+MYNODE,FILE=FILENAME9, STATUS="unknown", form="formatted")
      WRITE(1985+MYNODE,*) '#E=', E
      DO I=1,NATOMS
         WRITE(1985+MYNODE,*) X(I),Y(I),Z(I)
      ENDDO
      CLOSE(1985+MYNODE)
      CLOSE(11+MYNODE)

#else
      RETURN
#endif
      END SUBROUTINE PTBASINSAMPLING
