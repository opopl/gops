C   GMIN: A PROGRAM FOR FINDING GLOBAL MINIMA
C   COPYRIGHT (C) 1999-2006 DAVID J. WALES
C   THIS FILE IS PART OF GMIN.
C
C   GMIN IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C   IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C   THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C   (AT YOUR OPTION) ANY LATER VERSION.
C
C   GMIN IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
C   BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
C   GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C   YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C   ALONG WITH THIS PROGRAM; IF NOT, WRITE TO THE FREE SOFTWARE
C   FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330, BOSTON, MA  02111-1307  USA
C
C
C  CONJUGATE GRADIENT MINIMIZATION.
C
      SUBROUTINE CGMIN(MAXI,P,CFLAG,ITER,EREAL,NP)
      USE COMMONS
      IMPLICIT NONE


      INTEGER I, J, MAXI, NP, J1
      DOUBLE PRECISION EPS
      PARAMETER (EPS=1.D-6)
      DOUBLE PRECISION G(3*NATOMS),H(3*NATOMS),GRAD(3*NATOMS),P(3*NATOMS),FP,
     1                 PGSUM,PPGSUM,EDIFF,POTEL,QMAX,
     2                 GSUM,EREAL,VAR,FRET,GG,DGG,GAM,QSTART,QFINISH
      INTEGER ITER, MYPSAVE

      LOGICAL STUCK, FTEST, NOTCALLED, CTEST, CFLAG
      COMMON /ST/ STUCK
      COMMON /MYPOT/ POTEL
      COMMON /FAIL/ FTEST
      COMMON /Q4C/ QSTART, QFINISH

      NOTCALLED=.TRUE.

C     CALL ORDERQ4(NATOMS,P,QSTART)

      IF (DEBUG.AND.DUMPT) THEN
         IF (ARNO) THEN
            WRITE(40,'(I4)') NATOMS+2
            WRITE(40,10) NP,NQ(NP)
            WRITE(40,'(A,F20.10)') 'N 0.0 0.0 ', 0.577D0
            WRITE(40,'(A,F20.10)') 'O 0.0 0.0 ',-0.577D0
            WRITE(40,65) (P(I),I=1,3*(NATOMS-NS))
65          FORMAT('AR ',3F20.10)
         ELSE
            WRITE(40,'(I4)') NATOMS
            WRITE(40,10) NQ(NP)
10          FORMAT(1X,'QUENCH NUMBER ',I6,' INITIAL POINTS IN CGMIN')
            WRITE(40,'(A2,3F20.10)') ('LA ',P(3*(I-1)+1),P(3*(I-1)+2),P(3*(I-1)+3),I=1,NATOMS-NS)
            IF (NS.GT.0) WRITE(40,'(A2,3F20.10)') ('LB',P(3*(I-1)+1),P(3*(I-1)+2),P(3*(I-1)+3),I=NATOMS-NS+1,NATOMS)
         ENDIF
      ENDIF

      CALL POTENTIAL(P,GRAD,EREAL,.TRUE.,.FALSE.)
      POTEL=EREAL

      IF (FTEST) THEN
         CFLAG=.FALSE.
         RETURN
      ENDIF

      FP=EREAL
      GSUM=RMS
      PGSUM=0.0D0
      PPGSUM=0.0D0
      DO J=1,3*NATOMS
        G(J)=-GRAD(J)
        H(J)=G(J)
        GRAD(J)=H(J)
      ENDDO

      DO ITER=1,MAXI

C        WRITE(40,'(I4)') NATOMS
C        WRITE(40,'(A,I4,A,F15.5)') 'AT STEP NUMBER ',ITER,' ENERGY=',EREAL
C        WRITE(40,'(A2,3F20.10)') ('LA ',P(3*(I-1)+1),P(3*(I-1)+2),P(3*(I-1)+3),I=1,NATOMS-NSEED)

C        PRINT*,'VARIABLES:'
C        WRITE(*,'(5F20.10)') (P(J1),J1=1,3*NATOMS)
C        PRINT*,'GRADIENT:'
C        WRITE(*,'(5F20.10)') (GRAD(J1),J1=1,3*NATOMS)

         STUCK=.FALSE.

         IF ((DABS(GSUM-PGSUM)/GSUM.LT.1.0D-5).AND.
     1       (DABS(GSUM-PPGSUM)/GSUM.LT.1.0D-5).AND.(MOD(ITER,3).EQ.0)) THEN
            PRINT*,'STUCK'
            STUCK=.TRUE.
            IF (AMBER.AND.(RMS.GT.1.0D0)) THEN
               EREAL=0.0D0
               POTEL=0.0D0
               RMS=1.0D0
               WRITE(*,'(A)') ' STUCK - STEP DISCARDED'
               RETURN
C
C  SHORT RANGE MORSE POTENTIALS CAN GET STUCK THROUGH ATOMS GETTING TOO FAR OUT
C  OF THE CORE. TRY CONTRACTING.
C
            ELSE IF (MORSET.AND.RHO.GT.6.0D0) THEN
               DO I=1,NATOMS-NSEED
                  P(3*(I-1)+1)=P(3*(I-1)+1)*0.9D0   
                  P(3*(I-1)+2)=P(3*(I-1)+2)*0.9D0   
                  P(3*(I-1)+3)=P(3*(I-1)+3)*0.9D0   
               ENDDO
            ELSE IF (CENT.AND.(.NOT.SEEDT)) THEN
               CALL CENTRE2(P)
            ELSE IF (FIXCOM.AND.(.NOT.SEEDT)) THEN
               CALL CENTRECOM(P)
            ELSE
               CFLAG=.FALSE.
               RETURN
            ENDIF
         ENDIF

         IF (DEBUG) WRITE(6,'(A,G20.10,A,G15.5,A,I4,A)') 
     1                    ' POTENTIAL ENERGY=',EREAL,' RMS FORCE=',GSUM,' AFTER ',ITER-1,' CG STEPS'

         FIXIMAGE=.TRUE.
         FRET=EREAL
C        CALL MYLINMIN(P,GRAD,NATOMS,FRET)
         CALL LINMIN(ITER,P,GRAD,NATOMS,FRET)
         FIXIMAGE=.FALSE.
         IF (ITER.EQ.1) MYPSAVE=MYPOWER
         IF (FTEST) THEN
            CFLAG=.FALSE.
            RETURN
         ENDIF
         QMAX=1.0D-10
         VAR=QMAX*(ABS(FRET)+ABS(FP)+EPS)
         EDIFF=DABS(FRET-FP)
         IF (NATOMS-NSEED.EQ.1) THEN
            IF (GSUM.LT.GMAX/10.0D0) THEN
               CFLAG=.TRUE.
               RETURN
            ENDIF
         ELSE
            IF (GSUM.LT.GMAX) THEN
               CFLAG=.TRUE.
               RETURN
            ENDIF
         ENDIF
         CALL POTENTIAL(P,GRAD,EREAL,.TRUE.,.FALSE.)
         POTEL=EREAL
         IF (EREAL.GT.FP) THEN
            EREAL=0.0D0
            POTEL=0.0D0
            RMS=1.0D0
            WRITE(*,'(A)') ' ENERGY INCREASED IN QUENCH - STEP DISCARDED'
            RETURN
         ENDIF

C
C  CATCH COLD FUSION FOR IONIC POTENTIALS AND DISCARD.
C
C  CHANGED EREAL FOR COLD FUSION TO 1.0D6 RATHER THAN 0.0D0, WHICH COULD RESULT IN STEPS BEING ACCEPTED
C  FOR SYSTEMS WITH POSITIVE ENERGIES. - KHS26 26/11/09
C
         IF ((TOSI.OR.WELCH.OR.RGCL2.OR.AMBER.OR.ARNO.OR.PACHECO).AND.(EREAL.LT.-1.0D3)) THEN
            EREAL=0.0D6
            POTEL=0.0D6
            RMS=1.0D0
            WRITE(*,'(A)') ' COLD FUSION DIAGNOSED - STEP DISCARDED'
!     CSW34> SET COLDFUSION=.TRUE. SO THAT ATEST=.FALSE. IN MC
            COLDFUSION=.TRUE.
            RETURN
         ENDIF
!        IF ((AMBER.AND.NOTCALLED).AND.(RMS.LT.1.0D0)) THEN
!           CALL CHIRALTEST(CTEST,P)
!           IF (CTEST) THEN
!              WRITE(*,'(A)') ' CHANGE IN CHIRALITY DETECTED - STEP REJECTED'
!              POTEL=1.0D6
!              EREAL=1.0D6
!              RMS=1.0D0
!              RETURN
!           ENDIF
!           NOTCALLED=.FALSE.
!        ENDIF
         FP=EREAL
         GG=0.0D0
         DGG=0.0D0
         DO J=1,3*NATOMS
            GG=GG+G(J)**2
C
C  THIS IS FLETCHER-REEVES
C
C           DGG=DGG+GRAD(J)**2
C
C  THIS IS POLAK-RIBIERE
C
            DGG=DGG+(GRAD(J)+G(J))*GRAD(J)
         ENDDO
         GAM=DGG/GG
         PPGSUM=PGSUM
         PGSUM=GSUM
         GSUM=RMS
         DO J=1,3*NATOMS
            G(J)=-GRAD(J)
            H(J)=G(J)+GAM*H(J)
            GRAD(J)=H(J)
         ENDDO
      ENDDO
 
      CFLAG=.FALSE.

      RETURN
      END
