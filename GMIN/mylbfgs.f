C   GMIN: A PROGRAM FOR FINDING GLOBAL MINIMA
C   COPYRIGHT (C) 1999-2006 DAVID J. WALES
C   THIS FILE IS PART OF GMIN.
C
C   GMIN IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C   IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C   THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C   (AT YOUR OPTION) ANY LATER VERSION.
C
C   GMIN IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
C   BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
C   GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C   YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C   ALONG WITH THIS PROGRAM; IF NOT, WRITE TO THE FREE SOFTWARE
C   FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330, BOSTON, MA  02111-1307  USA
C
C
C        LIMITED MEMORY BFGS METHOD FOR LARGE SCALE OPTIMIZATION
C                          JORGE NOCEDAL
C                        *** JULY 1990 ***
C
C        LINE SEARCH REMOVED PLUS SMALL MODIFICATIONS, DJW 2001
C
      SUBROUTINE MYLBFGS(N,M,XCOORDS,DIAGCO,EPS,MFLAG,ENERGY,ITMAX,ITDONE,RESET,NP)
      USE COMMONS
      USE MODAMBER
      USE MODAMBER9, ONLY : STEEREDMINT, LOCALSTEEREDMINT, SMINK, SMINKINC, SMINKCURRENT
      USE MODCHARMM
      USE PORFUNCS
      IMPLICIT NONE
      INTEGER N,M,J1,ITMAX,ITDONE,NP,J2,J3,NFAIL,NDECREASE,NGUESS,NDUMMY
      DOUBLE PRECISION XCOORDS(3*NATOMS),GRAD(3*NATOMS),SLENGTH,DDOT,EPLUS,EMINUS,DIFF,DUMMY,WTEMP(3*NATOMS)
      DOUBLE PRECISION TMPANG(3*NATOMS), TMPCOORDS(3*NATOMS)
      DOUBLE PRECISION EPS,ENERGY,ENEW,GNEW(3*NATOMS),OVERLAP,OLDX(3*NATOMS),OLDOLDX(3*NATOMS),VGUESS(3),
     1                 X1, Y1, Z1, X2, Y2, Z2, TRY(3*NATOMS), D1, D2, RBCOORDS(18), DUMMY2, DIST, DIST1
      DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) :: DIAG, W
      LOGICAL DIAGCO, YESNO, RESET, NOTCALLED, CTEST, MFLAG
      DOUBLE PRECISION GNORM,STP,YS,YY,SQ,YR,BETA,POTEL,QSTART,QFINISH
      DOUBLE PRECISION OLDCART(3*NATOMS), DELTAQ(N),DELTACART(3*NATOMS),LEPSILON,DOT1,DOT2
      DOUBLE PRECISION LCART(3*NATOMS),OLDQ(N),NEWQ(N),OLDGINT(N),GINT(N),XINT(N),XSAVE(N),SMINKCURRENTP
      DOUBLE PRECISION, ALLOCATABLE :: FRAMES(:,:), PE(:), MODGRAD(:)
      LOGICAL NOCOOR, FAILED, COREDONE
      INTEGER ITER,POINT,ISPT,IYPT,BOUND,NPT,CP,INMC,IYCN,ISCN
      INTEGER KD, NNZ
      COMMON /MYPOT/ POTEL
      COMMON /Q4C/ QSTART, QFINISH
      LOGICAL EVAP, GUIDECHANGET, GUIDET, EVAPREJECT, SMINKCHANGET, CSMDOGUIDET
      COMMON /GD/ GUIDECHANGET, GUIDET, CSMDOGUIDET
      COMMON /EV/ EVAP, EVAPREJECT
      SAVE W, DIAG, ITER, POINT, ISPT, IYPT, NPT

      IF (.NOT.ALLOCATED(DIAG)) ALLOCATE(DIAG(N))       ! SAVE DOESN'T WORK OTHERWISE FOR SUN
      IF (.NOT.ALLOCATED(W)) ALLOCATE(W(N*(2*M+1)+2*M)) ! SAVE DOESN'T WORK OTHERWISE FOR SUN
!     IF (QUENCHDOS) ALLOCATE(FRAMES(N,ITMAX), PE(ITMAX), MODGRAD(ITMAX))
      IF (SIZE(W,1).NE.N*(2*M+1)+2*M) THEN ! MUSTN'T CALL MYLBFGS WITH CHANGING NUMBER OF VARIABLES!!!
         WRITE(MYUNIT, '(A,I10,A,I10,A)') 'ERROR, DIMENSION OF W=',SIZE(W,1),' BUT N*(2*M+1)+2*M=',N*(2*M+1)+2*M,' IN MYLBFGS'
         CALL EXIT(10)
      ENDIF
      COREDONE=.FALSE.
      SMINKCHANGET=.FALSE.
      SMINKCURRENT=0.0D0
      SMINKCURRENTP=0.0D0
      LOCALSTEEREDMINT=.FALSE.
      IF (STEEREDMINT) LOCALSTEEREDMINT=.TRUE.

! FOR CHARMM: UPDATE NONBONDED LIST AT THE START OF EACH MINIMIZATION
      IF(CHRMMT) CALL UPDATENBONDS(XCOORDS)

      NFAIL=0
      IF (GUIDECHANGET) ITER=0
      IF (RESET) ITER=0
      ITDONE=0
      FIXIMAGE=.FALSE.
      IF (DEBUG) THEN
         IF (RESET.OR.GUIDECHANGET) WRITE(MYUNIT,'(A)') 'MYLBFGS> RESETTING LBFGS MINIMISER'
         IF (.NOT.(RESET.OR.GUIDECHANGET)) WRITE(MYUNIT,'(A)') 'MYLBFGS> NOT RESETTING LBFGS MINIMISER'
      ENDIF

      IF (Q4T) CALL ORDERQ4(NATOMS,XCOORDS,QSTART)

      IF (DUMPT) THEN
         IF (ARNO) THEN
            WRITE(DUMPXYZUNIT+NP,'(I4)') NATOMS+2
            WRITE(DUMPXYZUNIT+NP,11) NP,NQ(NP)
            WRITE(DUMPXYZUNIT+NP,'(A,F20.10)') 'N 0.0 0.0 ', 0.577D0
            WRITE(DUMPXYZUNIT+NP,'(A,F20.10)') 'O 0.0 0.0 ',-0.577D0
            WRITE(DUMPXYZUNIT+NP,65) (XCOORDS(J1),J1=1,3*(NATOMS-NS))
65          FORMAT('AR ',3F20.10)
         ELSE IF (TIP) THEN
            WRITE(DUMPXYZUNIT+NP,'(I6)') (NATOMS/2)*3
            WRITE(DUMPXYZUNIT+NP,'(A,I5)') 'LBFGS ITERATION ',ITER
            DO J2=1,NATOMS/2
               CALL TIPIO(XCOORDS(3*(J2-1)+1),XCOORDS(3*(J2-1)+2),XCOORDS(3*(J2-1)+3),
     1              XCOORDS(3*(NATOMS/2+J2-1)+1),XCOORDS(3*(NATOMS/2+J2-1)+2),XCOORDS(3*(NATOMS/2+J2-1)+3),RBCOORDS)
               WRITE(DUMPXYZUNIT+NP,'(A4,3F20.10)') 'O ',RBCOORDS(1),RBCOORDS(2),RBCOORDS(3)
               WRITE(DUMPXYZUNIT+NP,'(A4,3F20.10)') 'H ',RBCOORDS(4),RBCOORDS(5),RBCOORDS(6)
               WRITE(DUMPXYZUNIT+NP,'(A4,3F20.10)') 'H ',RBCOORDS(7),RBCOORDS(8),RBCOORDS(9)
            ENDDO
         ELSE IF (AMBER) THEN
            WRITE(DUMPXYZUNIT+NP,'(I4)') NATOMS
            WRITE(DUMPXYZUNIT+NP,11) NP,NQ(NP)
            DO J2=1,NATOMS
               WRITE(DUMPXYZUNIT+NP,'(A,3F20.10)') TYPECH(J2)(1:1),(XCOORDS(3*(J2-1)+J3),J3=1,3)
            ENDDO
         ELSEIF (NCORE(NP).GT.0) THEN
            WRITE(DUMPXYZUNIT+NP,'(I4)') NATOMS
            WRITE(DUMPXYZUNIT+NP,11) NQ(NP)
            WRITE(DUMPXYZUNIT+NP,'(A2,3F20.10)') ('LB',XCOORDS(3*(I-1)+1),XCOORDS(3*(I-1)+2),XCOORDS(3*(I-1)+3),
     &                                               I=1,NATOMS-NCORE(NP))
            IF (NCORE(NP).GT.0) WRITE(DUMPXYZUNIT+NP,'(A2,3F20.10)') 
     &            ('LA ',XCOORDS(3*(I-1)+1),XCOORDS(3*(I-1)+2),XCOORDS(3*(I-1)+3),I=NATOMS-NCORE(NP)+1,NATOMS)
         ELSE
            WRITE(DUMPXYZUNIT+NP,'(I4)') NATOMS
            WRITE(DUMPXYZUNIT+NP,11) NQ(NP)
11          FORMAT(1X,'QUENCH NUMBER ',I6,' INITIAL POINTS IN MYLBFGS')
            WRITE(DUMPXYZUNIT+NP,'(A2,3F20.10)') ('LA ',XCOORDS(3*(J1-1)+1),XCOORDS(3*(J1-1)+2),XCOORDS(3*(J1-1)+3),J1=1,NATOMS-NS)
            IF (NS.GT.0) WRITE(DUMPXYZUNIT+NP,'(A2,3F20.10)') 
     1          ('LB',XCOORDS(3*(J1-1)+1),XCOORDS(3*(J1-1)+2),XCOORDS(3*(J1-1)+3),J1=NATOMS-NS+1,NATOMS)
         ENDIF
      ENDIF
      CALL POTENTIAL(XCOORDS,GRAD,ENERGY,.TRUE.,.FALSE.)
C
C  CATCH COLD FUSION FOR IONIC POTENTIALS AND DISCARD.
C
C  CHANGED EREAL FOR COLD FUSION TO 1.0D6 RATHER THAN 0.0D0, WHICH COULD RESULT IN STEPS BEING ACCEPTED
C  FOR SYSTEMS WITH POSITIVE ENERGIES. - KHS26 26/11/09
C
      IF ((TOSI.OR.WELCH.OR.RGCL2.OR.AMBER.OR.ARNO.OR.PACHECO.OR.TIP.OR.CHRMMT.OR.AMBERT 
     &   .OR.PYGPERIODICT.OR.PYBINARYT.OR.MULTISITEPYT.OR.JMT) 
     &   .AND.(ENERGY.LT.COLDFUSIONLIMIT)) THEN
         WRITE(MYUNIT,'(A,G20.10)') 'ENERGY=',ENERGY
         ENERGY=1.0D6
         POTEL=1.0D6
         RMS=1.0D0
         WRITE(MYUNIT,'(A)') ' COLD FUSION DIAGNOSED - STEP DISCARDED'
!     CSW34> SET COLDFUSION=.TRUE. SO THAT ATEST=.FALSE. IN MC
         COLDFUSION=.TRUE.
!        IF (QUENCHDOS) DEALLOCATE(FRAMES, PE, MODGRAD)
         RETURN
      ENDIF

!     IF (QUENCHDOS) THEN
!        MODGRAD(1)=DSQRT(DDOT(N,GRAD,1,GRAD,1))
!        PE(1)=ENERGY
!        FRAMES(1:N,1)=XCOORDS(1:N)
!     ENDIF
!
! STOP THE CORE FROM CHANGING MORPHOLOGY EASILY, BUT ALLOW IT TO RELAX
!
!     IF ((NCORE(NP).GT.0).AND.(.NOT.COREDONE)) THEN
!        DUMMY2=0.0D0
!        DO J1=1,3*(NATOMS-NCORE(NP))
!           DUMMY2=DUMMY2+GRAD(J1)**2
!        ENDDO
!        DUMMY2=DSQRT(DUMMY2/(3*NATOMS))
!        IF (DUMMY2.GT.EPS*2.0D0) THEN
!           GRAD(3*(NATOMS-NCORE(NP))+1:3*NATOMS)=0.0D0
!        ELSE
!           COREDONE=.TRUE.
!        ENDIF
!     ENDIF

      IF (CHRMMT .AND. GCHARMMFAIL) THEN
          WRITE(MYUNIT,'(A)') 'FAILURE IN CHARMM ENERGY/GRADIENT EVALUATION - GEOMETRY DISCARDED.'
!         IF (QUENCHDOS) DEALLOCATE(FRAMES, PE, MODGRAD)
          RETURN
      ENDIF

C
C  IF INTMINT AND CHRMMT NEED TO TRANSFORM TO INTERNAL COORDINATES
C  SEE COPTIM.2.3 FOR SWITCHING TO INTERNALS FROM CARTESIANS USING LIMINCUT.
C
      IF (INTMINT) THEN
         OLDCART(1:3*NATOMS)=XCOORDS(1:3*NATOMS) ! STORE CARTESIANS IN OLDCART FOR BOTH CHARMM AND UNRES
C         IF (UNRST) THEN
CC
CC STORE INTERNALS (IN OLDQ) AND UPDATE X TO CONTAIN INTERNALS
CC
C            CALL GEOM_TO_VAR(N,OLDQ)
C            XCOORDS(1:N)=OLDQ(1:N)
C         ELSE IF (CHRMMT) THEN
            CALL GETKD(KD) ! GET WIDTH OF SPARSE BAND IN G MATRIX KD
            CALL GETNNZ(NNZ) ! GET NUMBER OF NON-ZERO ELEMENTS IN B-MATRIX
            NOCOOR=.FALSE. ! CALCULATE INTERNALS THEREFORE NOCOOR IS FALSE
            GINT(1:N)=0.0D0 ! TO PREVENT NAN'S FOR SUN!
            XINT(1:N)=0.0D0 ! TO PREVENT NAN'S FOR SUN!
            CALL TRANSFORM(XCOORDS,GRAD,XINT,GINT,N,3*NATOMS,NNZ,NOCOOR,KD)
            OLDQ(1:N)=XINT(1:N)    ! STORE INTERNALS
            OLDGINT(1:N)=GINT(1:N) ! STORE GRADIENT IN INTERNALS
C         ENDIF
      ENDIF
C
C  FOR CHRMMT:
C  XCOORDS CONTAINS CURRENT CARTESIANS
C  GRAD    CONTAINS CURRENT GRADIENT
C  XINT    CONTAINS CURRENT INTERNALS
C  GINT    CONTAINS CURRENT GRADIENT IN INTERNALS
C  OLDQ    CONTAINS INTERNALS FOR INITIAL GEOMETRY
C  OLDGINT CONTAINS GRADIENT IN INTERNALS FOR INITIAL GEOMETRY
C  OLDCART CONTAINS CARTESIAN COORDINATES FOR INITIAL GEOMETRY
C
      IF (EVAPREJECT) RETURN
      POTEL=ENERGY

      IF (DEBUG) WRITE(MYUNIT,'(A,F20.10,G20.10,A,I6,A)') ' ENERGY AND RMS FORCE=',ENERGY,RMS,' AFTER ',ITDONE,' LBFGS STEPS'

C
C  CATCH COLD FUSION FOR IONIC POTENTIALS AND DISCARD.
C
      IF ((DBPT.OR.DBPTDT.OR.MSTBINT.OR.MSSTOCKT.OR.MULTPAHAT.OR.NPAHT.OR.PAHW99T.OR.PYGT.OR.TDHDT) .AND.(ENERGY.LT.-5.0D4)) THEN
         WRITE(MYUNIT,'(A,G20.10)') 'ENERGY=',ENERGY
         ENERGY=0.0D0
         POTEL=0.0D0
         RMS=1.0D0
         WRITE(MYUNIT,'(A)') ' COLD FUSION DIAGNOSED - STEP DISCARDED'
         RETURN
      ENDIF
C
C  TERMINATION TEST. 
C
10    CALL FLUSH(MYUNIT)
      MFLAG=.FALSE.
      IF (RMS.LE.EPS) THEN
         IF (CHRMMT.AND.ACESOLV) THEN
            NCHENCALLS=ACEUPSTEP-1
            CALL POTENTIAL(XCOORDS,GRAD,ENERGY,.TRUE.,.FALSE.)
            IF (DEBUG) WRITE(*,'(A,2G20.10,A)') ' MYLBFGS> ENERGY AND RMS FORCE=',ENERGY,RMS,' AFTER ACE UPDATE'
            IF (RMS.LE.EPS) MFLAG=.TRUE.
         ELSE
            MFLAG=.TRUE.
         ENDIF
         IF (EVAP) MFLAG=.FALSE. ! DO NOT ALLOW CONVERGENCE IF WE HAPPEN TO HAVE A SMALL RMS AND EVAP IS TRUE'
         IF (MFLAG) THEN
            FIXIMAGE=.FALSE.
            IF (DEBUG) WRITE(MYUNIT,'(A,F20.10,G20.10,A,I6,A)') ' ENERGY AND RMS FORCE=',ENERGY,RMS,' AFTER ',ITDONE,' LBFGS STEPS'

!             IF (QUENCHDOS) THEN
!                DO J1=1,ITDONE+1
!                   DIST=0.0D0
!                   DO J2=1,N
!                      DIST=DIST+(FRAMES(J2,J1)-FRAMES(J2,ITDONE+1))**2
!                   ENDDO
!                   DIST=SQRT(DIST)
!                   IF (J1.EQ.1) DIST1=DIST
! !                   DOSSTATS(J1,1)=PE(J1)
!                   IF ((MODGRAD(J1).GT.0.0D0).AND.(DIST.GT.0.0D0)) THEN
! !                    DOSSTATS(J1,2)=(MODGRAD(1)/MODGRAD(J1))*(DIST/DIST1)**(N-1)
! !                    DOSSTATS(J1,2)=(N-1)*LOG(DIST)-LOG(MODGRAD(J1))
!                      DOSSTATS(J1,2)=DIST**(N-1)/MODGRAD(J1)
!                   ELSE
!                      DOSSTATS(J1,2)=0.0D0
!                   ENDIF
! !                 WRITE(MYUNIT,'(A,I6,4G18.8)') 'LBFGS> J1,MODGRAD,DIST,DOSSTATS(J1,2),DOSSTATS(J1,1)=',
! !    &                      J1,MODGRAD(J1),DIST,DOSSTATS(J1,2),DOSSTATS(J1,1)
!                ENDDO
!                DEALLOCATE(FRAMES, PE, MODGRAD)
!             ENDIF

            RETURN
         ENDIF
      ENDIF

      IF (ITDONE.EQ.ITMAX) THEN
         IF (DEBUG) FIXIMAGE=.FALSE.
         IF (DEBUG) WRITE(MYUNIT,'(A,F20.10)') ' DIAGONAL INVERSE HESSIAN ELEMENTS ARE NOW ',DIAG(1)
!        IF (QUENCHDOS) DEALLOCATE(FRAMES, PE, MODGRAD)
         RETURN
      ENDIF

      IF (ITER.EQ.0) THEN
         IF (N.LE.0.OR.M.LE.0) THEN
            WRITE(MYUNIT,240)
 240        FORMAT(' IMPROPER INPUT PARAMETERS (N OR M ARE NOT POSITIVE)')
            STOP
         ENDIF
         POINT=0
         MFLAG=.FALSE.
         IF (DIAGCO) THEN
            WRITE(MYUNIT,'(A)') 'USING ESTIMATE OF THE INVERSE DIAGONAL ELEMENTS'
            DO J1=1,N
               IF (DIAG(J1).LE.0.0D0) THEN
                  WRITE(MYUNIT,235) J1
 235              FORMAT(' THE',I5,'-TH DIAGONAL ELEMENT OF THE',/,
     1                   ' INVERSE HESSIAN APPROXIMATION IS NOT POSITIVE')
                  STOP
               ENDIF
            ENDDO
         ELSE
C           INQUIRE(FILE='DIAG',EXIST=YESNO)
C           IF (YESNO) THEN
C              OPEN(UNIT=34,FILE='DIAG',STATUS='OLD')
C              READ(34,*) (DIAG(J1),J1=1,N)
C              PRINT*,'DIAG READ IN LBFGS'
C              WRITE(*,'(6F15.5)') (DIAG(J1),J1=1,N)
C           ELSE
            DO J1=1,N
               DIAG(J1)=DGUESS
            ENDDO
         ENDIF
C
C     THE WORK VECTOR W IS DIVIDED AS FOLLOWS:
C     ---------------------------------------
C     THE FIRST N LOCATIONS ARE USED TO STORE THE GRADIENT AND
C         OTHER TEMPORARY INFORMATION.
C     LOCATIONS (N+1)...(N+M) STORE THE SCALARS RHO.
C     LOCATIONS (N+M+1)...(N+2M) STORE THE NUMBERS ALPHA USED
C         IN THE FORMULA THAT COMPUTES H*G.
C     LOCATIONS (N+2M+1)...(N+2M+NM) STORE THE LAST M SEARCH
C         STEPS.
C     LOCATIONS (N+2M+NM+1)...(N+2M+2NM) STORE THE LAST M
C         GRADIENT DIFFERENCES.
C
C     THE SEARCH STEPS AND GRADIENT DIFFERENCES ARE STORED IN A
C     CIRCULAR ORDER CONTROLLED BY THE PARAMETER POINT.
C
         ISPT= N+2*M    ! INDEX FOR STORAGE OF SEARCH STEPS
         IYPT= ISPT+N*M ! INDEX FOR STORAGE OF GRADIENT DIFFERENCES
C
C  NR STEP FOR DIAGONAL INVERSE HESSIAN
C
         IF (CHRMMT.AND.INTMINT) THEN
            DO I=1,N
               W(ISPT+I)= -GINT(I)*DIAG(I)
               W(I)= -GINT(I)*DIAG(I)
            ENDDO
            GNORM= DSQRT(DDOT(N,GINT,1,GINT,1))
         ELSE
            DO J1=1,N
               DUMMY=-GRAD(J1)*DIAG(J1)
               W(ISPT+J1)=DUMMY
               W(J1)=DUMMY
            ENDDO
            GNORM=DSQRT(DDOT(N,GRAD,1,GRAD,1))
         ENDIF
C
C  MAKE THE FIRST GUESS FOR THE STEP LENGTH CAUTIOUS.
C
         STP=MIN(1.0D0/GNORM,GNORM)
      ELSE 
         BOUND=ITER
         IF (ITER.GT.M) BOUND=M
         YS= DDOT(N,W(IYPT+NPT+1),1,W(ISPT+NPT+1),1)
C
C  UPDATE ESTIMATE OF DIAGONAL INVERSE HESSIAN ELEMENTS
C
         IF (.NOT.DIAGCO) THEN
            YY= DDOT(N,W(IYPT+NPT+1),1,W(IYPT+NPT+1),1)
            IF (YY.EQ.0.0D0) THEN
               WRITE(MYUNIT,'(A)') 'WARNING, RESETTING YY TO ONE IN MYLBFGS'
               YY=1.0D0
            ENDIF
            IF (YS.EQ.0.0D0) THEN
               WRITE(MYUNIT,'(A)') 'WARNING, RESETTING YS TO ONE IN MYLBFGS'
               YS=1.0D0
            ENDIF
C           WRITE(*,'(A,2F20.10)') 'YS/YY,STP=',YS/YY,STP
            DO J1=1,N
C              DIAG(J1)= ABS(YS/YY) ! MESSES UP AFTER STEP REVERSALS!
               DIAG(J1)= YS/YY
            ENDDO
         ELSE
            WRITE(MYUNIT,'(A)') 'USING ESTIMATE OF THE INVERSE DIAGONAL ELEMENTS'
            DO J1=1,N
               IF (DIAG(J1).LE.0.0D0) THEN
                  WRITE(MYUNIT,235) J1
                  STOP
               ENDIF
            ENDDO
         ENDIF
C
C     COMPUTE -H*G USING THE FORMULA GIVEN IN: NOCEDAL, J. 1980,
C     "UPDATING QUASI-NEWTON MATRICES WITH LIMITED STORAGE",
C     MATHEMATICS OF COMPUTATION, VOL.24, NO.151, PP. 773-782.
C     ---------------------------------------------------------
C
         CP= POINT
         IF (POINT.EQ.0) CP=M
         W(N+CP)= 1.0D0/YS
         IF (CHRMMT.AND.INTMINT) THEN
            DO I=1,N
               W(I)= -GINT(I)
            ENDDO
         ELSE
            DO J1=1,N
               W(J1)= -GRAD(J1)
            ENDDO
         ENDIF
         CP= POINT
         DO J1= 1,BOUND
            CP=CP-1
            IF (CP.EQ.-1) CP=M-1
            SQ=DDOT(N,W(ISPT+CP*N+1),1,W,1)
            INMC=N+M+CP+1
            IYCN=IYPT+CP*N
            W(INMC)=W(N+CP+1)*SQ
            CALL DAXPY(N,-W(INMC),W(IYCN+1),1,W,1)
         ENDDO
        
         DO J1=1,N
            W(J1)=DIAG(J1)*W(J1)
         ENDDO

         DO J1=1,BOUND
            YR= DDOT(N,W(IYPT+CP*N+1),1,W,1)
            BETA= W(N+CP+1)*YR
            INMC=N+M+CP+1
            BETA= W(INMC)-BETA
            ISCN=ISPT+CP*N
            CALL DAXPY(N,BETA,W(ISCN+1),1,W,1)
            CP=CP+1
            IF (CP.EQ.M) CP=0
         ENDDO
         STP=1.0D0  
      ENDIF
C
C  STORE THE NEW SEARCH DIRECTION
C
      IF (ITER.GT.0) THEN
         DO J1=1,N
            W(ISPT+POINT*N+J1)= W(J1)
         ENDDO
      ENDIF

      IF (CHRMMT.AND.INTMINT) THEN
         DOT1=SQRT(DDOT(N,GINT,1,GINT,1))
      ELSE
         DOT1=SQRT(DDOT(N,GRAD,1,GRAD,1))
      ENDIF
C
C  OVERFLOW HAS OCCASIONALLY OCCURRED HERE.
C  WE ONLY NEED THE SIGN OF THE OVERLAP, SO USE A TEMPORARY ARRAY WITH
C  REDUCED ELEMENTS.
C
      DUMMY=1.0D0
      DO J1=1,N
         IF (ABS(W(J1)).GT.DUMMY) DUMMY=ABS(W(J1))
      ENDDO
      DO J1=1,N
         WTEMP(J1)=W(J1)/DUMMY
      ENDDO
      DOT2=SQRT(DDOT(N,WTEMP,1,WTEMP,1))
      OVERLAP=0.0D0
      IF (DOT1*DOT2.NE.0.0D0) THEN
         IF (CHRMMT.AND.INTMINT) THEN
            OVERLAP=DDOT(N,GINT,1,WTEMP,1)/(DOT1*DOT2)
         ELSE
            OVERLAP=DDOT(N,GRAD,1,WTEMP,1)/(DOT1*DOT2)
        ENDIF
      ENDIF
C     PRINT*,'OVERLAP,DIAG(1)=',OVERLAP,DIAG(1)
C     PRINT*,'GRAD . GRAD=',DDOT(N,GRAD,1,GRAD,1)
C     PRINT*,'W . W=',DDOT(N,W,1,W,1)
      IF (OVERLAP.GT.0.0D0) THEN
C        IF (DEBUG) PRINT*,'SEARCH DIRECTION HAS POSITIVE PROJECTION ONTO GRADIENT - RESETTING'
C        ITER=0
C        GOTO 10
         IF (DEBUG) WRITE(MYUNIT,'(A)') 'SEARCH DIRECTION HAS POSITIVE PROJECTION ONTO GRADIENT - REVERSING STEP'
         DO J1=1,N
            W(ISPT+POINT*N+J1)= -W(J1)  !!! DJW, REVERSES STEP
         ENDDO
      ENDIF

      IF (CHRMMT.AND.INTMINT) THEN
         DO I=1,N
            W(I)=GINT(I)
         ENDDO
      ELSE
         DO J1=1,N
            W(J1)=GRAD(J1)
         ENDDO
      ENDIF
      SLENGTH=0.0D0
      DO J1=1,N
         SLENGTH=SLENGTH+W(ISPT+POINT*N+J1)**2
      ENDDO
      SLENGTH=SQRT(SLENGTH)
      IF (STP*SLENGTH.GT.MAXBFGS) STP=MAXBFGS/SLENGTH
C
C  WE NOW HAVE THE PROPOSED STEP.
C
      IF (CHRMMT.AND.INTMINT) THEN
         DO J1=1,N
            XINT(J1)=XINT(J1)+STP*W(ISPT+POINT*N+J1)
            DELTAQ(J1)=STP*W(ISPT+POINT*N+J1)
         ENDDO
      ELSE
!
! SAVE XCOORDS HERE SO THAT WE CAN UNDO THE STEP RELIABLY INCLUDING THE
! NON-LINEAR PROJECTION FOR THOMSON FOR THE ANGULAR COORDINATES.
!
         XSAVE(1:N)=XCOORDS(1:N) 
         DO J1=1,N
            XCOORDS(J1)=XCOORDS(J1)+STP*W(ISPT+POINT*N+J1)
         ENDDO 
!
! FOR THOMSON TRY PROJECTION FOR THE GEOMETRY AFTER THE STEP.
!
         IF (PROJIT) THEN
            IF (THOMSONT) THEN
               TMPCOORDS(1:N)=XCOORDS(1:N)
               CALL THOMSONANGTOC(TMPCOORDS,NATOMS)
               CALL PROJI(TMPCOORDS,NATOMS)
               CALL THOMSONCTOANG(TMPCOORDS,TMPANG,NATOMS)
               XCOORDS(1:N)=TMPANG(1:N)
            ELSE
               TMPCOORDS(1:N)=XCOORDS(1:N)
               CALL PROJI(TMPCOORDS,NATOMS)
               XCOORDS(1:N)=TMPCOORDS(1:N)
            ENDIF
         ENDIF
         IF (PROJIHT) THEN
            IF (THOMSONT) THEN
               TMPCOORDS(1:N)=XCOORDS(1:N)
               CALL THOMSONANGTOC(TMPCOORDS,NATOMS)
               CALL PROJIH(TMPCOORDS,NATOMS)
               CALL THOMSONCTOANG(TMPCOORDS,TMPANG,NATOMS)
               XCOORDS(1:N)=TMPANG(1:N)
            ELSE
               TMPCOORDS(1:N)=XCOORDS(1:N)
               CALL PROJIH(TMPCOORDS,NATOMS)
               XCOORDS(1:N)=TMPCOORDS(1:N)
            ENDIF
         ENDIF
      ENDIF
C
C  FOR CHARMM INTERNALS MUST TRANSFORM AND BACK-TRANSFORM!
C
      NDECREASE=0
      LEPSILON=1.0D-6

20    IF (INTMINT) THEN
         IF (CHRMMT) THEN
            NEWQ(1:N)=OLDQ(1:N)
            LCART(1:3*NATOMS)=OLDCART(1:3*NATOMS)
C
C NEED TO KEEP OLDQ CONSTANT FOR REPEATED BACK-TRANSFORMATIONS IF FIRST STEP SIZE FAILS.
C THEREFORE PASS DUMMY ARRAY NEWQ THAT CAN CHANGE.
C SIMILARLY WITH LCART AND OLDCART.
C
C           CALL TRANSBACK(XINT,NEWQ,LCART,N,3*NATOMS,NNZ,KD)
            CALL TRANSBACKDELTA(DELTAQ,DELTACART,LCART,N,3*NATOMS,NNZ,KD,FAILED,.FALSE.,LEPSILON) ! TRANSFORM STEP TO CARTESIANS
            IF (FAILED) THEN
C              NCOUNT=NCOUNT+1
C              IF (NCOUNT.GT.1) STOP
C              LEPSILON=1.0D-5*DPRAND()
C              GOTO 21
C OR
               MFLAG=.FALSE.
!              IF (QUENCHDOS) DEALLOCATE(FRAMES, PE, MODGRAD)
               RETURN
            ENDIF
C
C NOW ADD DELTACART TO LCART TO GET NEW CARTESIANS. PUT THESE IN X.
C
            LCART(1:3*NATOMS)=OLDCART(1:3*NATOMS)+DELTACART(1:3*NATOMS)
            XCOORDS(1:3*NATOMS)=OLDCART(1:3*NATOMS)+DELTACART(1:3*NATOMS)
C
C  FOR CHRMMT:
C  LCART    CONTAINS NEW CARTESIANS (AFTER STEP)
C  XCOORDS CONTAINS NEW CARTESIANS (AFTER STEP)
C  XINT    CONTAINS NEW INTERNALS (AFTER STEP)
C  GRAD    CONTAINS OLD GRADIENT
C  GINT    CONTAINS OLD GRADIENT IN INTERNALS
C  OLDQ    CONTAINS OLD INTERNALS
C  OLDGINT CONTAINS OLD GRADIENT IN INTERNALS FOR THE LAST SUCCESSFUL GEOMETRY
C  NEWQ    CONTAINS OLD INTERNALS FOR THE LAST SUCCESSFUL GEOMETRY
C  OLDCART CONTAINS OLD CARTESIANS FOR THE LAST SUCCESSFUL GEOMETRY
C
C         ELSEIF (UNRST) THEN
C            NEWQ(1:N)=X(1:N) ! STORE NEW INTERNALS IN NEWQ
CC
CC NEED A TEMPORARY ARRAY NEWQ HERE AS ARGUMENT TO VAR_TO_GEOM TO KEEP X UNCHANGED IN CASE WE NEED TO
CC MODIFY THE STEP BELOW.
CC
C            CALL VAR_TO_GEOM(N,NEWQ) ! UPDATE INTERNALS
C            CALL CHAINBUILD ! GET CARTESIANS
         ENDIF
      ENDIF

! CSW34> INCREMENT THE FORCE CONSTANT FOR STEERED MINIMISATION
      SMINKCHANGET=.FALSE.
      IF (LOCALSTEEREDMINT) THEN
         SMINKCURRENT=MIN(SMINKCURRENT+SMINKINC,SMINK)
         IF (SMINKCURRENT.NE.SMINKCURRENTP) SMINKCHANGET=.TRUE.
! A BIT OF USEFUL DEBUG PRINTING         
        IF (DEBUG) WRITE(MYUNIT,'(A,2F20.10,L5)') 'SMINKCURRENT,SMINKCURRENTP,SMINKCHANGET=',SMINKCURRENT,SMINKCURRENTP,SMINKCHANGET
      ENDIF

      CALL POTENTIAL(XCOORDS,GNEW,ENEW,.TRUE.,.FALSE.)

!     IF (QUENCHDOS) THEN
!        MODGRAD(ITDONE+2)=DSQRT(DDOT(N,GNEW,1,GNEW,1))
!        PE(ITDONE+2)=ENEW
!        FRAMES(1:N,ITDONE+2)=XCOORDS(1:N)
!     ENDIF
!
! STOP THE CORE FROM CHANGING MORPHOLOGY EASILY, BUT ALLOW IT TO RELAX
!
!     IF ((NCORE(NP).GT.0).AND.(.NOT.COREDONE)) THEN
!        DUMMY2=0.0D0
!        DO J1=1,3*(NATOMS-NCORE(NP))
!           DUMMY2=DUMMY2+GNEW(J1)**2
!        ENDDO
!        DUMMY2=DSQRT(DUMMY2/(3*NATOMS))
!        IF (DUMMY2.GT.EPS*2.0D0) THEN
!           GNEW(3*(NATOMS-NCORE(NP))+1:3*NATOMS)=0.0D0
!        ELSE
!           COREDONE=.TRUE.
!        ENDIF
!     ENDIF

      IF (EVAPREJECT) RETURN
      IF (CHRMMT .AND. GCHARMMFAIL) THEN
          WRITE(MYUNIT,'(A)') 'FAILURE IN CHARMM ENERGY/GRADIENT EVALUATION - STEP DISCARDED.'
!         IF (QUENCHDOS) DEALLOCATE(FRAMES, PE, MODGRAD)
          RETURN
      ENDIF
C
C  CATCH COLD FUSION FOR IONIC POTENTIALS AND DISCARD.
C
C  CHANGED EREAL FOR COLD FUSION TO 1.0D6 RATHER THAN 0.0D0, WHICH COULD RESULT IN STEPS BEING ACCEPTED
C  FOR SYSTEMS WITH POSITIVE ENERGIES. - KHS26 26/11/09
C
      IF ((TOSI.OR.WELCH.OR.RGCL2.OR.AMBER.OR.ARNO.OR.PACHECO.OR.TIP.OR.CHRMMT.OR.AMBERT 
     &   .OR.PYGPERIODICT.OR.PYBINARYT.OR.JMT)
     &   .AND.(ENEW.LT.COLDFUSIONLIMIT)) THEN
         ENERGY=0.0D6
         ENEW=0.0D6
         POTEL=0.0D6
         RMS=1.0D0
         WRITE(MYUNIT,'(A)') ' COLD FUSION DIAGNOSED - STEP DISCARDED'
!     CSW34> SET COLDFUSION=.TRUE. SO THAT ATEST=.FALSE. IN MC
         COLDFUSION=.TRUE.
!        IF (QUENCHDOS) DEALLOCATE(FRAMES, PE, MODGRAD)
         RETURN
      ENDIF
      IF ((DBPT.OR.DBPTDT.OR.MSTBINT.OR.MSSTOCKT.OR.MULTPAHAT.OR.NPAHT.OR.PAHW99T.OR.PYGT.OR.TDHDT) .AND.(ENEW.LT.-5.0D4)) THEN
         ENERGY=0.0D0
         ENEW=0.0D0
         POTEL=0.0D0
         RMS=1.0D0
         WRITE(MYUNIT,'(A)') ' COLD FUSION DIAGNOSED - STEP DISCARDED'
         RETURN
      ENDIF


C
C  WE NEED TO TRANSFORM THE NEWLY OBTAINED CARTESIAN GRADIENT FOR CHARMM AND INTERNALS.
C  NOCOOR IS TRUE BECAUSE WE DONT NEED TO TRANSFORM THE COORDINATES.
C
      IF (CHRMMT.AND.INTMINT) THEN
         NOCOOR=.TRUE.
         CALL TRANSFORM(XCOORDS,GNEW,XINT,GINT,N,3*NATOMS,NNZ,NOCOOR,KD)
      ENDIF

C     IF (TIP) THEN
C           WRITE(DUMPXYZUNIT+NP,'(I6)') (NATOMS/2)*3
C           WRITE(DUMPXYZUNIT+NP,'(A,I5,A,F20.10)') 'LBFGS ITERATION ',ITER,' ENERGY =',ENEW
C           DO J2=1,NATOMS/2
C              CALL TIPIO(XCOORDS(3*(J2-1)+1),XCOORDS(3*(J2-1)+2),XCOORDS(3*(J2-1)+3),
C    1              XCOORDS(3*(NATOMS/2+J2-1)+1),XCOORDS(3*(NATOMS/2+J2-1)+2),XCOORDS(3*(NATOMS/2+J2-1)+3),RBCOORDS)
C              WRITE(DUMPXYZUNIT+NP,'(A4,3F20.10)') 'O ',RBCOORDS(1),RBCOORDS(2),RBCOORDS(3)
C              WRITE(DUMPXYZUNIT+NP,'(A4,3F20.10)') 'H ',RBCOORDS(4),RBCOORDS(5),RBCOORDS(6)
C              WRITE(DUMPXYZUNIT+NP,'(A4,3F20.10)') 'H ',RBCOORDS(7),RBCOORDS(8),RBCOORDS(9)
C           ENDDO
C     ENDIF

C     WRITE(*,'(A,F20.10)') 'ENEW=',ENEW
C     WRITE(*,'(I6,F20.10)') (J1,GNEW(J1),J1=1,N)

C
C CSW34 FORCE ACCEPTANCE OF STEP IF FIXDIHEFLAG IS TRUE
C
      IF (FIXDIHEFLAG) ENERGY=ENEW

      IF (((ENEW-ENERGY.LE.MAXERISE).OR.EVAP.OR.GUIDECHANGET.OR.SMINKCHANGET).AND.(ENEW-ENERGY.GT.MAXEFALL)) THEN
         ITER=ITER+1
         ITDONE=ITDONE+1
         ENERGY=ENEW
         DO J1=1,3*NATOMS
            GRAD(J1)=GNEW(J1)
         ENDDO
         IF (DEBUG) WRITE(MYUNIT,'(A,F20.10,G20.10,A,I6,A,F13.10)') ' ENERGY AND RMS FORCE=',ENERGY,RMS,' AFTER ',ITDONE,
     1           ' LBFGS STEPS, STEP:',STP*SLENGTH
C
C  STEP FINISHED SO CAN RESET OLDQ TO NEW XINT, OLDCART TO NEW LCART,
C  AS WELL AS THE CARTESIAN AND INTERNAL GRADIENTS.
C
         IF (CHRMMT.AND.INTMINT) THEN
            OLDGINT(1:N)=GINT(1:N)
            OLDCART(1:3*NATOMS)=LCART(1:3*NATOMS)
C
C  NEED TO REMAKE XINT BECAUSE STEP WAS ONLY PROJECTED IN CARTESIANS?
C  ACTUALLY, JUST SETTING OLDQ=XINT WITHOUT THIS CORRECTION SEEMS TO
C  BE OK. DUE TO NUMERICAL IMPRECISION, IT MIGHT STILL BE POSSIBLE
C  FOR X AND XINT TO GET OUT OF REGISTER. PERHAPS THIS DOESN'T MATTER
C  BECAUSE THE ENERGY AND GRADIENT ARE ALWAYS CALCULATED IN CARTESIANS.
C
C           IF (BFGSTST) CALL TRANSDELTA(DELTACART,DELTAQ,LCART,N,3*NATOMS,NNZ,KD)
C           OLDQ(1:N)=OLDQ(1:N)+DELTAQ(1:N)
            OLDQ(1:N)=XINT(1:N)
C         ELSEIF (UNRST) THEN
C!           TEST1(1:N)=X(1:N)
C            CALL GEOM_TO_VAR(N,X(1:N)) ! TESTING!!! - TO PUT X BACK INTO REGISTER WITH THE COMMON BLOCK INTERNALS (AND G)
C!           CALL GEOM_TO_VAR(N,TEST1(1:N))
C!           DO J1=1,N
C!           IF (ABS((TEST1(J1)-X(J1))/X(J1))*100.0D0.GT.1.0D-6) PRINT *,'HELLO COORDS ',J1
C!           ENDDO
         ENDIF
C
C  TRY TO TAKE AN EXTRA STEP USING THE TWO PREVIOUS GEOMETRIES.
C 
C          GOTO 112
C          IF (MOD(ITDONE,3).EQ.0) THEN
C             NGUESS=0
C 111         CONTINUE
C             DO J1=1,NATOMS
C                X1=OLDX(3*(J1-1)+1)-OLDOLDX(3*(J1-1)+1)
C                Y1=OLDX(3*(J1-1)+2)-OLDOLDX(3*(J1-1)+2)
C                Z1=OLDX(3*(J1-1)+3)-OLDOLDX(3*(J1-1)+3)
C                X2=XCOORDS(3*(J1-1)+1)-OLDX(3*(J1-1)+1)
C                Y2=XCOORDS(3*(J1-1)+2)-OLDX(3*(J1-1)+2)
C                Z2=XCOORDS(3*(J1-1)+3)-OLDX(3*(J1-1)+3)
C                VGUESS(1)=(X2*(X1*X2 + Y1*Y2 + Z1*Z2))/(SQRT(X1**2 + Y1**2 + Z1**2)*SQRT(X2**2 + Y2**2 + Z2**2)) + 
C      -  ((X2*(Y1*Y2 + Z1*Z2) - X1*(Y2**2 + Z2**2))*
C      -     SQRT(1 - (X1*X2 + Y1*Y2 + Z1*Z2)**2/((X1**2 + Y1**2 + Z1**2)*(X2**2 + Y2**2 + Z2**2))))/
C      -   SQRT((X2*Y1 - X1*Y2)**2 + (X2*Z1 - X1*Z2)**2 + (Y2*Z1 - Y1*Z2)**2)
C                VGUESS(2)=(Y2*(X1*X2 + Y1*Y2 + Z1*Z2))/(SQRT(X1**2 + Y1**2 + Z1**2)*SQRT(X2**2 + Y2**2 + Z2**2)) + 
C      -  ((-(X2**2*Y1) + X1*X2*Y2 + Z2*(Y2*Z1 - Y1*Z2))*
C      -     SQRT(1 - (X1*X2 + Y1*Y2 + Z1*Z2)**2/((X1**2 + Y1**2 + Z1**2)*(X2**2 + Y2**2 + Z2**2))))/
C      -   SQRT((X2*Y1 - X1*Y2)**2 + (X2*Z1 - X1*Z2)**2 + (Y2*Z1 - Y1*Z2)**2)
C                VGUESS(3)=(Z2*(X1*X2 + Y1*Y2 + Z1*Z2))/(SQRT(X1**2 + Y1**2 + Z1**2)*SQRT(X2**2 + Y2**2 + Z2**2)) + 
C      -  ((-(X2**2*Z1) + X1*X2*Z2 + Y2*(-(Y2*Z1) + Y1*Z2))*
C      -     SQRT(1 - (X1*X2 + Y1*Y2 + Z1*Z2)**2/((X1**2 + Y1**2 + Z1**2)*(X2**2 + Y2**2 + Z2**2))))/
C      -   SQRT((X2*Y1 - X1*Y2)**2 + (X2*Z1 - X1*Z2)**2 + (Y2*Z1 - Y1*Z2)**2)
C                D1=SQRT(VGUESS(1)**2+VGUESS(2)**2+VGUESS(3)**2)
C                IF (D1.LT.0.1) THEN
C                   TRY(3*(J1-1)+1)=XCOORDS(3*(J1-1)+1)+VGUESS(1)*1.0D0
C                   TRY(3*(J1-1)+2)=XCOORDS(3*(J1-1)+2)+VGUESS(2)*1.0D0
C                   TRY(3*(J1-1)+3)=XCOORDS(3*(J1-1)+3)+VGUESS(3)*1.0D0
C                ENDIF
C             ENDDO
C             CALL POTENTIAL(TRY,GNEW,EGUESS,.FALSE.,.FALSE.)
C             WRITE(*,'(A,3G20.10)') 'ENEW,EGUESS,CHANGE=',ENEW,EGUESS,EGUESS-ENEW
C             IF (EGUESS-ENEW.LT.0.0D0) THEN
C                NGUESS=NGUESS+1
C                ENEW=EGUESS
C                DO J1=1,N
C                   OLDOLDX(J1)=OLDX(J1)
C                   OLDX(J1)=XCOORDS(J1)
C                   XCOORDS(J1)=TRY(J1)
C                ENDDO
C                IF (NGUESS.LT.6) GOTO 111
C             ENDIF
C          ENDIF
C          DO J1=1,N
C             OLDOLDX(J1)=OLDX(J1)
C             OLDX(J1)=XCOORDS(J1)
C          ENDDO
C 
C 112      CONTINUE
C
C  MAY WANT TO PREVENT THE PE FROM FALLING TOO MUCH IF WE ARE TRYING TO VISIT ALL THE
C  PE BINS. HALVE THE STEP SIZE UNTIL THE ENERGY DECREASE IS IN RANGE.
C
      ELSEIF (ENEW-ENERGY.LE.MAXEFALL) THEN
C
C  ENERGY DECREASED TOO MUCH - TRY AGAIN WITH A SMALLER STEP SIZE
C
         IF (NDECREASE.GT.5) THEN
            NFAIL=NFAIL+1
            WRITE(MYUNIT,'(A,G20.10)') ' IN MYLBFGS LBFGS STEP CANNOT FIND AN ENERGY IN THE REQUIRED RANGE, NFAIL=',NFAIL
            IF (CHRMMT.AND.INTMINT) THEN ! NEED TO RESET X, XINT, G, GINT TO ORIGINAL VALUES
               XINT(1:N)=XINT(1:N)-STP*W(ISPT+POINT*N+1:ISPT+POINT*N+N)
C              XINT=OLDQ ! SHOULD BE THE SAME AS SUBTRACTING THE STEP
               GINT(1:N)=OLDGINT(1:N)
               GRAD(1:3*NATOMS)=GNEW(1:3*NATOMS) ! HERE OPTIM USES GLAST ! DJW
               XCOORDS(1:3*NATOMS)=OLDCART(1:3*NATOMS)
            ELSE
!
! RESETTING TO XSAVE SHOULD BE THE SAME AS SUBTRACTING THE STEP. 
! IF WE HAVE TRIED PROJI WITH THOMSON THEN THE PROJECTION IS NON-LINEAR
! AND WE NEED TO RESET TO XSAVE. THIS SHOULD ALWAYS BE RELIABLE!
!
               XCOORDS(1:N)=XSAVE(1:N)
               GRAD(1:N)=GNEW(1:N) ! GRAD CONTAINS THE GRADIENT AT THE LOWEST ENERGY POINT

!              DO J1=1,N
!                 XCOORDS(J1)=XCOORDS(J1)-STP*W(ISPT+POINT*N+J1)
!              ENDDO

            ENDIF
            ITER=0   !  TRY RESETTING
            IF (NFAIL.GT.20) THEN
               WRITE(MYUNIT,'(A)') ' TOO MANY FAILURES - GIVING UP '
               FIXIMAGE=.FALSE.
!              STOP
!              IF (QUENCHDOS) DEALLOCATE(FRAMES, PE, MODGRAD)
               RETURN
            ENDIF
            GOTO 30
         ENDIF
         IF (CHRMMT.AND.INTMINT) THEN
            DO J1=1,N
               XINT(J1)=XINT(J1)-0.5*STP*W(ISPT+POINT*N+J1)
               DELTAQ(J1)=STP*W(ISPT+POINT*N+J1)*0.5D0
            ENDDO
         ELSE
!
! RESETTING TO XSAVE AND ADDING HALF THE STEP SHOULD BE THE SAME AS SUBTRACTING 
! HALF THE STEP. 
! IF WE HAVE TRIED PROJI WITH THOMSON THEN THE PROJECTION IS NON-LINEAR
! AND WE NEED TO RESET TO XSAVE. THIS SHOULD ALWAYS BE RELIABLE!
!
            XCOORDS(1:N)=XSAVE(1:N)
            DO J1=1,N
               XCOORDS(J1)=XCOORDS(J1)+0.5*STP*W(ISPT+POINT*N+J1)
            ENDDO 
!           DO J1=1,N
!              XCOORDS(J1)=XCOORDS(J1)-0.5*STP*W(ISPT+POINT*N+J1)
!           ENDDO 
!
! FOR THOMSON TRY PROJECTION FOR THE GEOMETRY AFTER THE STEP.
!        
            IF (PROJIT) THEN
               IF (THOMSONT) THEN
                  TMPCOORDS(1:N)=XCOORDS(1:N)
                  CALL THOMSONANGTOC(TMPCOORDS,NATOMS)
                  CALL PROJI(TMPCOORDS,NATOMS)
                  CALL THOMSONCTOANG(TMPCOORDS,TMPANG,NATOMS)
                  XCOORDS(1:N)=TMPANG(1:N)
               ELSE
                  TMPCOORDS(1:N)=XCOORDS(1:N)
                  CALL PROJI(TMPCOORDS,NATOMS)
                  XCOORDS(1:N)=TMPCOORDS(1:N)
               ENDIF
            ENDIF
            IF (PROJIHT) THEN
               IF (THOMSONT) THEN
                  TMPCOORDS(1:N)=XCOORDS(1:N)
                  CALL THOMSONANGTOC(TMPCOORDS,NATOMS)
                  CALL PROJIH(TMPCOORDS,NATOMS)
                  CALL THOMSONCTOANG(TMPCOORDS,TMPANG,NATOMS)
                  XCOORDS(1:N)=TMPANG(1:N)
               ELSE
                  TMPCOORDS(1:N)=XCOORDS(1:N)
                  CALL PROJIH(TMPCOORDS,NATOMS)
                  XCOORDS(1:N)=TMPCOORDS(1:N)
               ENDIF
            ENDIF

         ENDIF
         STP=STP/2.0D0
         NDECREASE=NDECREASE+1
         IF (DEBUG) WRITE(MYUNIT,'(A,F19.10,A,F16.10,A,F15.8)') 
     1                      ' ENERGY DECREASED TOO MUCH FROM ',ENERGY,' TO ',ENEW,' DECREASING STEP TO ',STP*SLENGTH
         
         FIXIMAGE=.TRUE.
         GOTO 20
      ELSE
C
C  ENERGY INCREASED - TRY AGAIN WITH A SMALLER STEP SIZE
C
         IF (NDECREASE.GT.10) THEN ! DJW
            NFAIL=NFAIL+1
            WRITE(MYUNIT,'(A,G20.10)') ' IN MYLBFGS LBFGS STEP CANNOT FIND A LOWER ENERGY, NFAIL=',NFAIL
            IF (CHRMMT.AND.INTMINT) THEN ! NEED TO RESET X, XINT, G, GINT TO ORIGINAL VALUES
               XINT(1:N)=XINT(1:N)-STP*W(ISPT+POINT*N+1:ISPT+POINT*N+N)
C              XINT=OLDQ ! SHOULD BE THE SAME AS SUBTRACTING THE STEP
               GINT(1:N)=OLDGINT(1:N)
               GRAD(1:3*NATOMS)=GNEW(1:3*NATOMS) ! HERE OPTIM USES GLAST ! DJW
               XCOORDS(1:3*NATOMS)=OLDCART(1:3*NATOMS)
            ELSE
!
! RESETTING TO XSAVE SHOULD BE THE SAME AS SUBTRACTING THE STEP. 
! IF WE HAVE TRIED PROJI WITH THOMSON THEN THE PROJECTION IS NON-LINEAR
! AND WE NEED TO RESET TO XSAVE. THIS SHOULD ALWAYS BE RELIABLE!
!
               XCOORDS(1:N)=XSAVE(1:N)
               GRAD(1:N)=GNEW(1:N) ! GRAD CONTAINS THE GRADIENT AT THE LOWEST ENERGY POINT
!              DO J1=1,N
!                 GRAD(J1)=GNEW(J1) ! GRAD CONTAINS THE GRADIENT AT THE LOWEST ENERGY POINT
!                 XCOORDS(J1)=XCOORDS(J1)-STP*W(ISPT+POINT*N+J1)
!              ENDDO
            ENDIF
            ITER=0   !  TRY RESETTING
!            IF (NFAIL.GT.20) THEN
! BS360: SMALLER NFAIL 
             IF (NFAIL.GT.5) THEN         
               WRITE(MYUNIT,'(A)') ' TOO MANY FAILURES - GIVING UP '
               FIXIMAGE=.FALSE.
!              STOP
!              IF (QUENCHDOS) DEALLOCATE(FRAMES, PE, MODGRAD)
               RETURN
            ENDIF
            GOTO 30
         ENDIF
         IF (CHRMMT.AND.INTMINT) THEN
            DO J1=1,N
               XINT(J1)=XINT(J1)-0.9*STP*W(ISPT+POINT*N+J1)
               DELTAQ(J1)=STP*W(ISPT+POINT*N+J1)*0.1D0
            ENDDO
         ELSE
!
! RESETTING TO XSAVE AND ADDING 0.1 OF THE STEP SHOULD BE THE SAME AS SUBTRACTING 
! 0.9 OF THE STEP. 
! IF WE HAVE TRIED PROJI WITH THOMSON THEN THE PROJECTION IS NON-LINEAR
! AND WE NEED TO RESET TO XSAVE. THIS SHOULD ALWAYS BE RELIABLE!
!
            XCOORDS(1:N)=XSAVE(1:N)
            DO J1=1,N
               XCOORDS(J1)=XCOORDS(J1)+0.1D0*STP*W(ISPT+POINT*N+J1)
            ENDDO 

!           DO J1=1,N
!              XCOORDS(J1)=XCOORDS(J1)-0.9*STP*W(ISPT+POINT*N+J1)
!           ENDDO 
!
! FOR THOMSON TRY PROJECTION FOR THE GEOMETRY AFTER THE STEP.
!        
            IF (PROJIT) THEN
               IF (THOMSONT) THEN
                  TMPCOORDS(1:N)=XCOORDS(1:N)
                  CALL THOMSONANGTOC(TMPCOORDS,NATOMS)
                  CALL PROJI(TMPCOORDS,NATOMS)
                  CALL THOMSONCTOANG(TMPCOORDS,TMPANG,NATOMS)
                  XCOORDS(1:N)=TMPANG(1:N)
               ELSE
                  TMPCOORDS(1:N)=XCOORDS(1:N)
                  CALL PROJI(TMPCOORDS,NATOMS)
                  XCOORDS(1:N)=TMPCOORDS(1:N)
               ENDIF
            ENDIF
            IF (PROJIHT) THEN
               IF (THOMSONT) THEN
                  TMPCOORDS(1:N)=XCOORDS(1:N)
                  CALL THOMSONANGTOC(TMPCOORDS,NATOMS)
                  CALL PROJIH(TMPCOORDS,NATOMS)
                  CALL THOMSONCTOANG(TMPCOORDS,TMPANG,NATOMS)
                  XCOORDS(1:N)=TMPANG(1:N)
               ELSE
                  TMPCOORDS(1:N)=XCOORDS(1:N)
                  CALL PROJIH(TMPCOORDS,NATOMS)
                  XCOORDS(1:N)=TMPCOORDS(1:N)
               ENDIF
            ENDIF
         ENDIF
         STP=STP/1.0D1
         NDECREASE=NDECREASE+1
         IF (DEBUG) WRITE(MYUNIT,'(A,F20.10,A,F20.10,A,F20.10)') 
     1                      ' ENERGY INCREASED FROM ',ENERGY,' TO ',ENEW,' DECREASING STEP TO ',STP*SLENGTH
         FIXIMAGE=.TRUE.
         GOTO 20
      ENDIF
C
C     COMPUTE THE NEW STEP AND GRADIENT CHANGE
C
30    NPT=POINT*N

      IF (CHRMMT.AND.INTMINT) THEN
         DO I=1,N
            W(ISPT+NPT+I)= STP*W(ISPT+NPT+I)
            W(IYPT+NPT+I)= GINT(I)-W(I)
         ENDDO
      ELSE
         DO J1=1,N
            W(ISPT+NPT+J1)= STP*W(ISPT+NPT+J1) ! SAVE THE STEP TAKEN
            W(IYPT+NPT+J1)= GRAD(J1)-W(J1)     ! SAVE GRADIENT DIFFERENCE: W(1:N) CONTAINS THE OLD GRADIENT
         ENDDO
      ENDIF
      POINT=POINT+1
      IF (POINT.EQ.M) POINT=0
      FIXIMAGE=.FALSE.
      IF (DUMPT.AND.DEBUG) THEN
         IF (AMBER) THEN
            WRITE(DUMPXYZUNIT+NP,'(I4)') NATOMS
            WRITE(DUMPXYZUNIT+NP,'(A,I4,A,F15.5)') 'AT STEP NUMBER ',ITER,' ENERGY=',ENERGY
            DO J2=1,NATOMS
               WRITE(DUMPXYZUNIT+NP,'(A,3F20.10)') TYPECH(J2)(1:1),(XCOORDS(3*(J2-1)+J3),J3=1,3)
            ENDDO
         ELSE
            WRITE(DUMPXYZUNIT+NP,'(I4)') NATOMS
            WRITE(DUMPXYZUNIT+NP,'(A,I8,A,G20.10)') 'AT STEP ',ITER,' ENERGY=',ENERGY
            WRITE(DUMPXYZUNIT+NP,'(A2,3F20.10)') ('LA ',XCOORDS(3*(J1-1)+1),XCOORDS(3*(J1-1)+2),XCOORDS(3*(J1-1)+3),J1=1,NATOMS-NS)
            IF (NS.GT.0) WRITE(DUMPXYZUNIT+NP,'(A2,3F20.10)') 
     1          ('LB',XCOORDS(3*(J1-1)+1),XCOORDS(3*(J1-1)+2),XCOORDS(3*(J1-1)+3),J1=NATOMS-NS+1,NATOMS)
         ENDIF
      ENDIF
      IF (CENT) CALL CENTRE2(XCOORDS)
      SMINKCURRENTP=SMINKCURRENT
      GOTO 10
!     IF (QUENCHDOS) DEALLOCATE(FRAMES, PE, MODGRAD)

      RETURN
      END
