

C     --------------------- INITIL ----------------------

      SUBROUTINE INITIL

C     INITIL OPEN REQUIRED FILES, READ IN INPUT_AMH 
C            PARAMETERS AND PRINT HEADER

C     ---------------------------------------------------

      USE AMHGLOBALS,  ONLY:SO,IPROLST,IPROLSTSCL,INPUT_AMH,OAMH,OAMHSR,
     * OAMHLR,NUMMEM,MAXMEM,NUMPRO,MAXPRO,NMRES,MAXSIZ,NUMCRD,
     * MAXCRD,NUMTAB,MAXTAB,CRDIXN,I505,HRDRAD,IGOMB,
     * NGOMB,N_LETTERS,MAX_LETTERS,I_ALT_PROX,
     * ALT_PROX_CUT,IEXCLD,ALLOW_NEG,LAMBDAR,ERES,MINMR,MAXMR,MAXS,
     * MAXR,I_RAMA,HBOND,HBSCL,CHRLSCL,DELTA,DELTE,
     * IBIASGAUSS,BIAS_WEIGHT,I_HBOND_EASTWOOD,I_HBOND_CZONG,
     * BIAS_AV,BIAS_VAR,BIAS_PREFACTOR,IBIASPOLY,NBIASPOLY,
     * BIASPOLY,I_QBIAS_A,N_QBIAS_A,QBIASPOLY_A,NMSTEP,ISEED_AMH,
     * IT1,IT2,IT3,
     * IT4,IT5,ICTEMP,CTEMP,NMTEMP,MXTEMP,INCMOV,NMDIF,IRESRT,
     * ISCLTAB,MOVANAL,ITGRD,I1,I2,I503,HYDSCL,
     * AMINOA,IDIGNS,OARCHV,OMOVI,
     *  OREP,IMEMRI,IRES,
     *  OPE_NO_BIAS,OPE_WITH_BIAS,OPE_PLUS_KE,OPE_BACKBONE,OPE_BACKBONE_NORAMA,
     * OHDRGN,ORAMA,OOXY,OCHIRAL,OKE,OCCEV,OOEV,
     * OBIAS_RG,OAMHMR,OHDRGN_S,OHDRGN_M,OHDRGN_L,OHDRGN_SEQ,
     * ONONADD,OCON_P_AP,OOBIASSEGA,OOBIASSEGB,OHARMSPRING,
     * OMOVISEG,PEXCLD,OXEXCLDV,O_EXVMIN,O_EXVMINS,
     * OEXCLDSCL,RAN_FORCE,RAN_FILE,
     * R_RAN,S_RAN,RAN_MIN_SEQ_DIST,SRPLR,OXSCL,RAMASCL,TIMSTP,
     * TOLSHK,RCUT,RCUTAMH,SRCUT,WELSCL,WIDTH_QEXP_A,T1,T2,
     *  T3,T4,T5,TEMGRD,QCHRG,QCHRG2,I_RG_BIAS,N_RG_BIAS,
     *  I_RG_GARYK,I_RG_FIRST, D_RG, T_RG, DELR_RG, M_RG, KAPPA_RG,
     *  RG_SHIFT,RG_SCL,RG_BIASPOLY,I_3RD_IS_CONTACT,
     * MIN_SEQ_SEP,ICLASSWEIGHT,EXVMIN,EXVMINS,EXVMINS_BETA,
     *  R_MIN,R_MAX,GLY_CON,WIDTH_QEXP_B,
     * I_V_TEST,TEST_SITE,RG_BOUNDS,I_RG_COREY,
     * ALPHA_C_OF_N,AB_C_OF_N_OLD,AB_C_OF_N_NEW,NUM_WELL,SIGMA_H,
     * SIGMA_NO,HO_ZERO,MAXSEQ,HOMLFL,
     * AVE_SEQ,AVE_SEQ_HB,AVE_SEQ_AMW,AVE_SEQ_AMC,
     * NUMSEQ,NUMSEQ_HB,NUMSEQ_AMW,NUMSEQ_AMC,
     * NO_ZERO,FOUR_PLUS,I_NON_ADD_CONTACT,I_ETIM_STEP,I_ETIM,QUENCH,
     * KNOWN,PEXCLD_GAMMA,IEXCLD_GAMMA,I_TYPE_EV_GAMMA,IEXCLD_BETA,
     * I_CONTACT_ORDER,I_CONTACT_ORDER_MIN,I_CONTACT_ORDER_MAX,
     * GAMMA_CONTACT_ORDER,R_MIN_CONTACT_ORDER,R_MAX_CONTACT_ORDER,
     * N_CONTACT_ORDER_TERMS,MAX_CONTACT_ORDER_TERMS,
     * I_QBIAS_B,N_QBIAS_B,QBIASPOLY_B,
     * NUM_FOLDON_A,FOLDSTRT_MIN_A, FOLDSTRT_MAX_A,CYCLIC,
     * NUM_FOLDON_B,FOLDSTRT_MIN_B, FOLDSTRT_MAX_B,CONST_MODE,
     * TARG_CONS,MEM_CONS,Q0_SAFE_A,Q0_SAFE_B,ISS_BIAS,
     * I_Q_FORMAT_A, Q0_A, Q_WEIGHT_A,N_Q_ANNEAL_A,Q0_INC_A, Q_CLIP_A,
     * SEGLIST_A,NUMCONST_A,SEGLIST_B,NUMCONST_B,I_BIAS_NATIVE_A,
     * I_Q_FORMAT_B, Q0_B, Q_WEIGHT_B,N_Q_ANNEAL_B,Q0_INC_B, Q_CLIP_B,
     * SS_A,SS_B,
     * CON_LOCAL_A, CON_LOCAL_A_CUT , CON_LOCAL_B, CON_LOCAL_B_CUT,
     * I_BIAS_NATIVE_B,TOTALSSNORM,
     * I_CON_P_AP,I_ATOM_P_AP,WEIGHT_P_AP,R_CUT_P_AP,I_DIFF_P_AP,
     * I_IGNORE_CHAIN_DIRN,MISMATCH,
     * GO_CON, GO_CON_DIST,SSWEIGHT,APS,SS_PATTERN_A,SS_PATTERN_B,
     * I_REP,REP_CUT_OFF,REP_TOL,
     * I_REP_LAMBDA_UNIFORM,REP_LAMBDA,N_LETTERS_CON,DIST_CUT,
     * ITARG_SEQ,TGSEQUENCES,MAXRES,TGSEQUENCES_HB,TGSEQUENCES_AMW,
     * TGSEQUENCES_AMC 

      IMPLICIT NONE

C     INTERNAL VARIABLES:

         INTEGER IUNIT,I,I_HOMLIST,ISEQ,J,K,GAP(MAXSIZ),
     *              TEMPGAP, SWITCH, SS_PAT_ITER_A,
     *              SS_PAT_ITER_B,TEMP_A, ID3,NMRSS,OPEN_STATUS
C     GETVAL

         DOUBLE PRECISION RNORM 

         CHARACTER*5 PROFLINIT

C     LIST REQUIRED SUBROUTINES

         EXTERNAL OPNFIL,QCHRGMK,READ_ALTGAMMA,READ_INPUT_ALT
      
         DATA I_HOMLIST/21/

	IUNIT = 998
	RNORM = 0.0D0

C     --------------------- BEGIN -----------------------


C      WRITE(6,*) 'HERE WE GO INITIL'

C      WRITE(*,*) 'INITIL.F: HERE WE GO INITIL'
      CALL READ_INPUT_ALT()  ! FOR ALTERNATIVE POTENTIAL

C      WRITE(SO,*) 'CALL OPNFIL'

        CALL  OPNFIL(IPROLST,IPROLSTSCL,INPUT_AMH,OARCHV,
     *             OMOVI,OHDRGN,OHDRGN_S,OHDRGN_M,OHDRGN_L,OHDRGN_SEQ,
     *             ORAMA,OOXY,OCHIRAL,OAMH,OAMHSR,OREP,
     *             OPE_NO_BIAS,OPE_WITH_BIAS,OPE_BACKBONE,
     *             OPE_BACKBONE_NORAMA,OAMHLR,OAMHMR,ONONADD,
     *             OCON_P_AP,OCCEV,OOEV,OBIAS_RG,OMOVISEG,
     *             OOBIASSEGA,OOBIASSEGB,OHARMSPRING)


C             WRITE(*,*) 'EXIT OPNFIL'

C       WRITE(SO,*)'IPROLST ',IPROLST
C       WRITE(SO,*)'INPUT_AMH ',INPUT_AMH
C       WRITE(SO,*)'OARCHV ',OARCHV
C       WRITE(SO,*)'OMOVI ',OMOVI
C       WRITE(SO,*)'OHDRGN ',OHDRGN
C       WRITE(SO,*)'OHDRGN_S ',OHDRGN_S
C       WRITE(SO,*)'OHDRGN_M ',OHDRGN_M
C       WRITE(SO,*)'OHDRGN_L ',OHDRGN_L
C       WRITE(SO,*)'OHDRGN_SEQ ',OHDRGN_SEQ
C       WRITE(SO,*)'ORAMA ',ORAMA
C       WRITE(SO,*)'OOXY ',OOXY
C       WRITE(SO,*)'OCHIRAL ',OCHIRAL
C       WRITE(SO,*)'OAMH ',OAMH
C       WRITE(SO,*)'OTOTAL ',OTOTAL
C       WRITE(SO,*)'OAMHSR ',OAMHSR
C       WRITE(SO,*)'OPE ',OPE
C       WRITE(SO,*)'OKE ',OKE
C       WRITE(SO,*)'OAMHLR ',OAMHLR
C       WRITE(SO,*)'OAMHMR ',OAMHMR
C       WRITE(SO,*)'ONONADD ',ONONADD
C       WRITE(SO,*)'OAMHLR ',OAMHLR
C       WRITE(SO,*)'OAMHMR ',OAMHMR
C       WRITE(SO,*)'ONONADD ',ONONADD
C       WRITE(SO,*)'OCON_P_AP',OCON_P_AP
C       WRITE(SO,*)'OBIAS_RG',OBIAS_RG
C      WRITE(SO,*)'OMOVISEG',OMOVISEG
C      WRITE(SO,*)'OCRAP',OCRAP
C      WRITE(SO,*)'OOBIASSEGA',OOBIASSEGA
C      WRITE(SO,*)'OOBIASSEGB',OOBIASSEGB

C   READ IN VARIOUS PARAMETERS AND CHECK THAT THEY ARE CONSISTENT WITH 
C   THE MAXIMUM SPACE ALLOWED
C   NUMMEM IS THE NUMBER OF PROTEIN MEMORIES USED IN THE POTENTIAL

      READ(INPUT_AMH,*)NUMMEM
      IF( NUMMEM.GT.MAXMEM )THEN
         WRITE(OARCHV,720)NUMMEM,MAXMEM
  720    FORMAT('NUMMEM TOO LARGE',2(1X,I3))
         STOP
      ENDIF

C     NUMPRO IS THE NUMBER OF ENSEMBLE PROTEINS 
 
      READ(INPUT_AMH,*)NUMPRO

      WRITE(SO,*)'NUMPRO=',NUMPRO

      IF( NUMPRO.GT.MAXPRO )THEN
         WRITE(OARCHV,721)NUMPRO,MAXPRO
  721    FORMAT('NUMPRO TOO LARGE',2(1X,I3))
         STOP
      ENDIF

C     MAXSIZ IS THE MAXIMUM NUMBER OF AMINO ACID RESIDUES;
C     NMRES IS THE ACTUAL PROTEIN SIZE USED

       READ(INPUT_AMH,*)NMRES

       WRITE(SO,*)'NMRES=',NMRES

      IF( NMRES.GT.MAXSIZ )THEN
         WRITE(OARCHV,722)NMRES,MAXSIZ
         WRITE(SO,722)NMRES,MAXSIZ
  722    FORMAT('NMRES TOO LARGE',2(1X,I3))
         STOP
      ENDIF

      READ(INPUT_AMH,*) KNOWN

C     ASSIGN NUMBER OF COORDINATE TYPES

      NUMCRD=3

C     CHECK THAT THE NUMBER OF SPECIFIED
C     COORDINATE TYPES DOES NOT EXCEED THE MAXIMUM

      IF( NUMCRD.GT.MAXCRD )THEN
         WRITE(OARCHV,236)NUMCRD,MAXCRD
  236    FORMAT(/'NUMBER OF SPECIFIED COORDINATE TYPES ',I3,
     *          ' IS GREATER THAN MAXIMUM ',I3)
         STOP
      ENDIF

C     ASSIGN NUMBER OF DIFFERENT TYPES OF IXNS

      NUMTAB=4
     
C     CHECK THAT THE NUMBER OF SPECIFIED
C     INTERACTIONS DOES NOT EXCEED THE MAXIMUM

      IF( NUMTAB.GT.MAXTAB )THEN
         WRITE(OARCHV,237)NUMTAB,MAXTAB
  237    FORMAT(/'NUMBER OF SPECIFIED TABLES ',I3,
     *          ' IS GREATER THAN MAXIMUM ',I3)
         STOP
      ENDIF

C     ASSIGN COORDINATE TYPES FOR EACH INTERACTION

      CRDIXN(1,1)=1
      CRDIXN(1,2)=1

      CRDIXN(2,1)=1
      CRDIXN(2,2)=2

      CRDIXN(3,1)=2
      CRDIXN(3,2)=1

      CRDIXN(4,1)=2
      CRDIXN(4,2)=2
      
C     READ IN COORDINATE TYPE TO BE USED
C     (BETA OR CENTER OF MASS)

C     SEQUENCE CHARGE SWITCHES AND THEIR WEIGHTS

      READ(INPUT_AMH,*)IGOMB
      READ(INPUT_AMH,*)NGOMB

      WRITE(SO,*) 'NGOMB=',NGOMB

      IF (IGOMB) THEN
        WRITE(OARCHV,1724) NGOMB
1724    FORMAT('MANY-BODY FACTOR NGOMB=',F6.3)
       ENDIF

C      DEGENERACY OF OUR CODE

       READ(INPUT_AMH,*) 
       READ(INPUT_AMH,*)DIST_CUT
       READ(INPUT_AMH,*)
       READ(INPUT_AMH,*)AVE_SEQ_AMC
       READ(INPUT_AMH,*)AVE_SEQ_HB
       READ(INPUT_AMH,*)AVE_SEQ_AMW

C       WRITE(6,*)'AVE_SEQ_AMC ', AVE_SEQ_AMC
C       WRITE(6,*)'AVE_SEQ_HB ', AVE_SEQ_HB
C       WRITE(6,*)'AVE_SEQ_AMW ', AVE_SEQ_AMW

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C     READ IN SEQUENCES TO AVERAGE FORCE OVER, IF AVG_SEQ IS ON
         DO ISEQ = 1,MAXSEQ
           DO ID3 = 1,MAXRES
             TGSEQUENCES(ID3,ISEQ)=0
             TGSEQUENCES_HB(ID3,ISEQ)=0
             TGSEQUENCES_AMW(ID3,ISEQ)=0
              TGSEQUENCES_AMC(ID3,ISEQ)=0
           ENDDO
         ENDDO

         REWIND IPROLST
         READ (IPROLST,1000)PROFLINIT
1000     FORMAT(A5)
         WRITE(SO,*) 'TARGET IN INITIL',PROFLINIT
         REWIND IPROLST
            OPEN(IMEMRI,FILE='PROTEINS/'//PROFLINIT,
     *                    STATUS='OLD',IOSTAT=OPEN_STATUS)
         IF (OPEN_STATUS.NE.0) THEN
           WRITE(SO,*) 'FAILURE TO OPEN FILE IN INITIL',PROFLINIT
           STOP
         ENDIF

         READ(IMEMRI,*)
         READ(IMEMRI,101)NMRSS

C         WRITE(6,*)'NMRSS'
C         WRITE(6,101)NMRSS
101      FORMAT(I5)
         READ(IMEMRI,106)(IRES(I1),I1=1,NMRSS)
106      FORMAT(25(I2,1X))
         CLOSE(IMEMRI)
         WRITE(SO,*)'IN INITIL IRES'
         WRITE(SO,106)(IRES(I1),I1=1,NMRSS)

          IF (AVE_SEQ_AMC .OR. AVE_SEQ_HB .OR. AVE_SEQ_AMW) THEN
           WRITE(6,*)'TARGET_SEQUENCES ITARG_SEQ '
           OPEN(ITARG_SEQ,FILE='TARGET_SEQUENCES',STATUS='OLD')
           READ(ITARG_SEQ,*)NUMSEQ
454          FORMAT(I5)
C           WRITE(6,*)'NUMSEQ ',NUMSEQ
             DO ISEQ = 1,NUMSEQ
                  READ(ITARG_SEQ,999)(TGSEQUENCES(ID3,ISEQ),ID3=1,NMRES)
C                  WRITE(6,999)(TGSEQUENCES(ID3,ISEQ),ID3=1,NMRES)
999               FORMAT(25(I2,1X))

           DO ID3 = 1,NMRES
                IF( (TGSEQUENCES(ID3,ISEQ) .LT. 1) .OR.
     *                    (TGSEQUENCES(ID3,ISEQ) .GT. 20) ) THEN
                    WRITE(6,*)'TARGET_SEQUENCE  OUT OF SEQ RANGE '
                    WRITE(6,*)'RESNUM   ', ID3
                    WRITE(6,*)'SEQNUM   ', ISEQ
                    WRITE(6,*)'TARGET_SEQUENCE  ', TGSEQUENCES(ID3,ISEQ)
                    STOP
                ENDIF
           ENDDO

             ENDDO
            CLOSE(ITARG_SEQ)
C            WRITE(6,*)'ITARG_SEQ CLOSED ',ITARG_SEQ
          ENDIF

          IF  (NUMSEQ.GT.MAXSEQ) THEN
            WRITE(6,*) 'NUMSEQ GREATER THAN MAXSEQ'
            STOP
          ENDIF

         IF ( AVE_SEQ_AMC ) THEN
            NUMSEQ_AMC=NUMSEQ
          ELSE
             NUMSEQ_AMC=1
            TGSEQUENCES_AMC(1:NMRES,1)=IRES(1:NMRES)
          ENDIF
C         WRITE(6,*)'AVE_SEQ_AMC NUMSEQ_AMC ', AVE_SEQ_AMC, NUMSEQ_AMC

         IF ( AVE_SEQ_HB ) THEN
            NUMSEQ_HB=NUMSEQ
          ELSE
            NUMSEQ_HB=1
            TGSEQUENCES_HB(1:NMRES,1)=IRES(1:NMRES)
          ENDIF
C         WRITE(6,*)'AVE_SEQ_HB NUMSEQ_HB ', AVE_SEQ_HB, NUMSEQ_HB

       IF ( AVE_SEQ_AMW) THEN
        NUMSEQ_AMW=NUMSEQ
        WRITE(6,*)'TGSEQUENCES_AMW SEQUENCES'
         DO ISEQ = 1,NUMSEQ_AMW
            DO ID3 = 1,NMRES
              TGSEQUENCES_AMW(ID3,ISEQ) = TGSEQUENCES(ID3,ISEQ)
C              WRITE(6,*)'TGSEQ_AMW AVE_SEQ_AMW ',AVE_SEQ_AMW
C              WRITE(6,*)'NUMSEQ_AMW ', NUMSEQ_AMW
C              WRITE(6,106)(TGSEQUENCES_AMW(I1,ISEQ),I1=1,NMRSS)
            ENDDO
         ENDDO
        ELSE
           NUMSEQ_AMW=1
           TGSEQUENCES_AMW(1:NMRES,1)=IRES(1:NMRES)
C           WRITE(6,*)'TGSEQ_AMW AVE_SEQ_AMW ',AVE_SEQ_AMW
C           WRITE(6,*)'NUMSEQ_AMW ', NUMSEQ_AMW
C           WRITE(6,*)'NUMSEQ ', NUMSEQ
C           WRITE(6,106)(TGSEQUENCES_AMW(I1,1),I1=1,NMRSS)
        ENDIF
C        WRITE(6,*)'AVE_SEQ_AMW NUMSEQ_AMW ', AVE_SEQ_AMW, NUMSEQ_AMW

C        IF (AVE_SEQ_AMW) THEN
C             WRITE(6,*)'TGSEQUENCES_AMW SEQUENCES'
C         DO ISEQ = 1,NUMSEQ_AMW
C          DO ID3 = 1,NMRES
C             TGSEQUENCES_AMW(ID3,ISEQ) = TGSEQUENCES(ID3,ISEQ)
C             WRITE(6,*)'TGSEQUENCES_AMW SEQUENCES'
C             WRITE(6,106)(TGSEQUENCES_AMW(I1,1),I1=1,NMRSS)
C          ENDDO
C         ENDDO
C        ENDIF

       IF (AVE_SEQ_HB) THEN
             WRITE(6,*)'TGSEQUENCES_HB SEQUENCES'
         DO ISEQ = 1,NUMSEQ_HB
          DO ID3 = 1,NMRES
             TGSEQUENCES_HB(ID3,ISEQ) = TGSEQUENCES(ID3,ISEQ)
             WRITE(6,*)'TGSEQUENCES_HB SEQUENCES'
             WRITE(6,106)(TGSEQUENCES_HB(I1,1),I1=1,NMRSS)
          ENDDO
         ENDDO
        ENDIF

        IF ( AVE_SEQ_AMC) THEN
             WRITE(6,*)'TGSEQUENCES_AMC SEQUENCES'
         DO ISEQ = 1,NUMSEQ_AMC
          DO ID3 = 1,NMRES
             TGSEQUENCES_AMC(ID3,ISEQ) = TGSEQUENCES(ID3,ISEQ)
             WRITE(6,*)'TGSEQUENCES_AMC SEQUENCES'
             WRITE(6,106)(TGSEQUENCES_AMC(I1,1),I1=1,NMRSS)
          ENDDO
         ENDDO
        ENDIF
                       
C       WRITE(6,106)(TGSEQUENCES_AMC(I1,1),I1=1,NMRSS)
                                      
       READ(INPUT_AMH,*) TARG_CONS
       READ(INPUT_AMH,*) MEM_CONS
       READ(INPUT_AMH,*)SSWEIGHT
       READ(INPUT_AMH,*)

C           WRITE(6,*) 'TARG_CONS = ',TARG_CONS
C           WRITE(6,*) 'MEM_CONS = ',MEM_CONS
C           WRITE(6,*) 'SSWEIGHT = ',SSWEIGHT
          IF((AVE_SEQ) .AND. (NUMSEQ.GT.MAXSEQ) ) THEN
            WRITE(6,*) 'NUMSEQ GREATER THAN MAXSEQ'
            STOP
          ENDIF

        IF (SSWEIGHT) THEN

        OPEN(ISS_BIAS,FILE='RAMA_SS_BIAS',STATUS='OLD')

        DO I = 1,NMRES
        READ(ISS_BIAS,*)APS(I,5),APS(I,6)
        APS(I,1)=1.0D0
        APS(I,2)=1.0D0
        APS(I,3)=1.0D0
        APS(I,4)=1.0D0
        ENDDO

        CLOSE(ISS_BIAS)
        ELSE

        APS(:,1)=1.0D0
        APS(:,2)=1.0D0
        APS(:,3)=1.0D0
        APS(:,4)=1.0D0
        APS(:,5)=0.0D0
        APS(:,6)=0.0D0
        ENDIF

C   GAMMA AVERAGING

C      IF (AVE_SEQ) THEN
C            OPEN(I_HOMLIST,FILE='TARGET_SEQUENCES',STATUS='OLD')
C         DO ISEQ = 1,NUMSEQ
C             READ (I_HOMLIST,1000)HOMLFL(ISEQ)
C1000         FORMAT(A5)
C             WRITE(SO,*) 'HOMOLOGUE ',HOMLFL(ISEQ)
C         ENDDO
C         CLOSE (I_HOMLIST)
C       ENDIF  !AVE_SEQ  AVG_GAMMAS


       READ(INPUT_AMH,*) N_LETTERS
C       WRITE(SO,*)'N_LETTERS ',N_LETTERS
       IF ((N_LETTERS.NE.2).AND.(N_LETTERS.NE.4)) THEN
         WRITE(SO,*) 'MUST BE 2 OR 4 LETTER CODE, NOT',N_LETTERS
         STOP
       ENDIF
       READ(INPUT_AMH,*) FOUR_PLUS
       WRITE(SO,*)'FOUR_PLUS ',FOUR_PLUS
       READ(INPUT_AMH,*)GO_CON
       READ(INPUT_AMH,*)GO_CON_DIST
       WRITE(SO,*)'GO_CON ',GO_CON
       WRITE(SO,*)'GO_CON_DIST ',GO_CON_DIST
       READ(INPUT_AMH,*)I_IGNORE_CHAIN_DIRN
       READ(INPUT_AMH,*)MISMATCH
       WRITE(SO,*)'MISMATCH ',MISMATCH

       READ(INPUT_AMH,*) I_NON_ADD_CONTACT
       IF (FOUR_PLUS.AND.(N_LETTERS.NE.4)) THEN
         WRITE(SO,*) 'CAN ONLY EXTEND 4 LETTER CODE IF USING IT'
         STOP
       ENDIF

       IF (N_LETTERS.GT.MAX_LETTERS) THEN
          WRITE(SO,*) 'DEGENERACY TOO HIGH'
          STOP
       ENDIF

       READ(INPUT_AMH,*) MIN_SEQ_SEP
       WRITE(SO,*) ' MIN_SEQ_SEP',  MIN_SEQ_SEP
       READ(INPUT_AMH,*) I_3RD_IS_CONTACT
       WRITE(SO,*) 'I_3RD_IS_CONTACT' , I_3RD_IS_CONTACT
       IF (I_3RD_IS_CONTACT.AND.(N_LETTERS.NE.4)) THEN
           WRITE(SO,*) 'CONTACT POTENTIAL FOR 4 LETTER CODE ONLY'
           STOP
       ENDIF

       READ(INPUT_AMH,*) N_LETTERS_CON
       IF (N_LETTERS_CON.NE.4.AND.N_LETTERS_CON.NE.20) THEN
         WRITE(SO,*) 'ONLY 2,4 OR 20 LETTER CONTACT INT SUPPORTED',
     *                                                 N_LETTERS_CON
         STOP
       ENDIF

       READ(INPUT_AMH,*) NUM_WELL
       WRITE(SO,*)'NUM_WELL=',NUM_WELL
       IF (NUM_WELL.NE.2.AND.NUM_WELL.NE.3.AND.NUM_WELL.NE.5
     *                                      .AND.NUM_WELL.NE.10) THEN
         WRITE(SO,*) 'ONLY 3 OR 10 WELL CONTACT POT SUPPORTED',NUM_WELL
         STOP
       ENDIF

       READ(INPUT_AMH,*) GLY_CON
       DO I=1,NUM_WELL
         READ(INPUT_AMH,*) R_MIN(I),R_MAX(I)
         WRITE(SO,*)'R_MIN(I),R_MAX(I)=',R_MIN(I),R_MAX(I)
       ENDDO
       READ(INPUT_AMH,*) I_ALT_PROX
       WRITE(SO,*)'I_ALT_PROX=',I_ALT_PROX
       READ(INPUT_AMH,*) ALT_PROX_CUT
       WRITE(SO,*)'ALT_PROX_CUT=',ALT_PROX_CUT

       IF (I_3RD_IS_CONTACT.AND.(.NOT.I_ALT_PROX)) THEN
           WRITE(SO,*) 'CONATCT POTENTIAL ONLY SUPPORTED'
           WRITE(SO,*) 'IN COREYS ALTERNATIVE PROX CLASS'
           STOP
       ENDIF



C     EXCLUDED VOLUME PARAMETERS

      READ(INPUT_AMH,*)
      READ(INPUT_AMH,*)IEXCLD
      READ(INPUT_AMH,*)IEXCLD_BETA
      READ(INPUT_AMH,*)IEXCLD_GAMMA,I_TYPE_EV_GAMMA
      IF (I_TYPE_EV_GAMMA.NE.1.AND.I_TYPE_EV_GAMMA.NE.2.AND.I_TYPE_EV_GAMMA.NE.3) THEN
        WRITE(SO,*) 'I_TYPE_EV_GAMMA COCK-UP',I_TYPE_EV_GAMMA
        STOP
      ENDIF
C  PEXCLD  PENALTY FOR VIOLATING EXCLUDED VOLUME
      READ(INPUT_AMH,*)PEXCLD
       WRITE(SO,*)'PEXCLD=',PEXCLD
      READ(INPUT_AMH,*)EXVMIN
       WRITE(SO,*)'EXVMIN=',EXVMIN
      READ(INPUT_AMH,*)EXVMINS
       WRITE(SO,*)'EXVMINS=',EXVMINS
      READ(INPUT_AMH,*)EXVMINS_BETA(1:4)
       WRITE(SO,*) 'EXVMINS_BETA(1:4)=',EXVMINS_BETA(1:4)
      READ(INPUT_AMH,*)OXEXCLDV
       WRITE(SO,*)'OXEXCLDV=',OXEXCLDV
      READ(INPUT_AMH,*) O_EXVMIN
       WRITE(SO,*)'O_EXVMIN=',O_EXVMIN
      READ(INPUT_AMH,*) O_EXVMINS(1:4)
       WRITE(SO,*) 'O_EXVMINS(1:4)',O_EXVMINS(1:4)
      READ(INPUT_AMH,*)OEXCLDSCL
      WRITE(SO,*) 'OEXCLDSCL',OEXCLDSCL

      PEXCLD_GAMMA=PEXCLD

         HRDRAD(0,1)=0.0D0
         HRDRAD(0,2)=0.0D0
         DO 505 I505=1,21
            HRDRAD(I505,1)=EXVMIN*0.5D0
            HRDRAD(I505,2)=EXVMIN*0.5D0
  505    CONTINUE
CCCCCCC

      READ(INPUT_AMH,*)

C     RAN_FORCE IS FLAG FOR RANDOM FORCE
      READ(INPUT_AMH,*) RAN_FORCE
      WRITE(SO,*) 'RAN_FORCE ',RAN_FORCE
      IF (RAN_FORCE  .AND. NUMMEM .GT. 1) THEN
        WRITE(SO,*) 'RANDOM FORCE AND >1 MEMORY, SO STOPPING'
        STOP
      ENDIF

C     USE PREVIOUS RANDOM DATA IF RAN_FILE TRUE

      READ(INPUT_AMH,*) RAN_FILE

C     R_RAN  IS EQM DIST FOR RANDOM FORCE

      READ(INPUT_AMH,*) R_RAN

C     S_RAN  IS SD OF RANDON INT

      READ(INPUT_AMH,*) S_RAN

C     RAN_MIN_SEQ_DIST IS MINIMUM SEQ-SEP FOR RANDOM INTS

      READ(INPUT_AMH,*) RAN_MIN_SEQ_DIST

C     ALLOW_NEG ALLOWS NEGATIVE PREFACTORS TO RANDOM POTENTIAL IF TRUE

      READ(INPUT_AMH,*) ALLOW_NEG

C     LAMBDAR IS THE SCALE FACTOR GIVEN TO
C     INCORRECT MEMORIES OR RANDOM INTS

      READ(INPUT_AMH,*) LAMBDAR

      WRITE(SO,*) 'LAMBDAR',LAMBDAR

C     SRPLR IS RATIO OF TOTAL SHORT-MED-LONG RANGE (IN SEQ) ENERGY
C     IN NATIVE STATE IF ICLASSWEIGHT=.TRUE.

      READ(INPUT_AMH,*)
      READ(INPUT_AMH,*)SRPLR

      WRITE(SO,*) 'SRPLR',SRPLR

C     ERES IS THE DESIRED POTENTIAL ENERGY/RESIDUE

      READ(INPUT_AMH,*)ERES

C     SHORT-RANGE IXN CUTOFF
      WRITE(SO,*) 'BOTTOM 2A'

      READ(INPUT_AMH,*)MINMR,MAXMR
      WRITE(SO,*) 'MINMR, MAXMR',MINMR,MAXMR

C     MAXS IS THE R-GRID RESOLUTION

      READ(INPUT_AMH,*)MAXS

C     CHECK THAT MAXS IS LESS THAN OR EQUAL TO THE
C     MAXIMUM NUMBER OF R-GRID POINTS

      IF( MAXS.GT.MAXR )THEN
         WRITE(OARCHV,726)MAXS,MAXR
  726    FORMAT('MAXS TOO LARGE',2(1X,I3))
         STOP
      ENDIF

C     READ SWITCH FOR RAMA POTENTIAL


      READ(INPUT_AMH,*)
      READ(INPUT_AMH,*) I_RAMA

      IF (I_RAMA.NE.0 .AND. I_RAMA.NE.1 .AND. I_RAMA.NE.2 
     *  .AND. I_RAMA.NE.3) THEN
         WRITE(SO,*) 'I_RAMA SET INCORRECTLY',I_RAMA
         STOP
      ENDIF

C     READ HBOND FLAG
      WRITE(SO,*) 'READING HBOND'

      READ(INPUT_AMH,*)HBOND
      READ(INPUT_AMH,*)I_HBOND_EASTWOOD ! OLD DSSP_HBOND
      READ(INPUT_AMH,*)I_HBOND_CZONG

       IF((HBOND.AND.(I_HBOND_EASTWOOD.OR.I_HBOND_CZONG)).OR.
     * (HBOND .AND. (I_HBOND_EASTWOOD .OR. I_HBOND_CZONG))) THEN
         WRITE(SO,*) 'CANNOT HAVE BOTH SORTS OF H-BOND'
         WRITE(SO,*) 'FOR A START THEY USE SAME AVEP ARRAY'
         STOP
       ENDIF

C     INPUT_AMH IN SWITCH FOR OXYGEN POTENTIAL AND SCALING FACTOR
C     AND HBSCL

      WRITE(SO,*) 'READING INPUT_AMH IN SWITCH'
      READ(INPUT_AMH,*)NO_ZERO
      READ(INPUT_AMH,*)SIGMA_NO
      READ(INPUT_AMH,*)HO_ZERO
      READ(INPUT_AMH,*)SIGMA_H
      READ(INPUT_AMH,*)HBSCL(1:17)


C     INPUT_AMH IN SWITCH FOR OXYGEN POTENTIAL AND SCALING FACTOR
C     AND HBSCL

      WRITE(SO,*) 'READING INPUT_AMH IN SWITCH'

      READ(INPUT_AMH,*)OXSCL
      WRITE(SO,*) 'OXSCL',OXSCL
      READ(INPUT_AMH,*)RAMASCL
      WRITE(SO,*) 'RAMASCL', RAMASCL
C     CHIRAL FORCES
      READ(INPUT_AMH,*)CHRLSCL
      WRITE(SO,*)'CHRSCL',CHRLSCL

! READ IN PARAMETERS FOR REPLICA FORCE
      READ(INPUT_AMH,*) 
      READ(INPUT_AMH,*) I_REP
      WRITE(SO,*) I_REP
      READ(INPUT_AMH,*) REP_CUT_OFF
      WRITE(SO,*) REP_CUT_OFF
      READ(INPUT_AMH,*) REP_TOL
      WRITE(SO,*) REP_TOL
      READ(INPUT_AMH,*) I_REP_LAMBDA_UNIFORM,REP_LAMBDA(1)
      WRITE(SO,*) I_REP_LAMBDA_UNIFORM,REP_LAMBDA(1)

C     CENTRAL POTENTIAL SWITCH AND SCALING FACTOR
C     FOR CENTRAL POTENTIAL

      WRITE(SO,*) 'BOTTOM 2B'

C     MD TIMESTEP

      READ(INPUT_AMH,*)
      READ(INPUT_AMH,*)TIMSTP
      WRITE(SO,*) 'TIMSTP',TIMSTP

C     SET TOLERANCE FOR SHAKE ROUTINES
C
C
C CHANGING THIS TEMPORARILY
C TOLSHK=0.2

C        TOLSHK=200000000*TIMSTP
       TOLSHK=0.2*TIMSTP
C     MINIMAL WELL-WIDTH

      READ(INPUT_AMH,*)DELTA

C     EXPONENT FOR WELL-WIDTH AS FUNCTION |I-J-1|

      READ(INPUT_AMH,*)DELTE

C     MAXIMUM INTERACTION DISTANCE

      READ(INPUT_AMH,*)RCUT
      READ(INPUT_AMH,*)RCUTAMH
      READ(INPUT_AMH,*)SRCUT
      READ(INPUT_AMH,*)WELSCL
      WRITE(SO,*) 'RCUT,RCUTAMH,SRCUT,WELSCL',RCUT
     *                              ,RCUTAMH,WELSCL


C     READ PARAMETERS/FLAGS FOR BIASING FUNCTIONS

      READ(INPUT_AMH,*)
      READ(INPUT_AMH,*) IBIASGAUSS           ! FIRST BIASONG FUNCS THAT DEPEND ON E_AMH
      READ(INPUT_AMH,*) BIAS_WEIGHT
      READ(INPUT_AMH,*) BIAS_AV
      READ(INPUT_AMH,*) BIAS_VAR
      BIAS_PREFACTOR=BIAS_WEIGHT/SQRT(2.0*3.1415926*
     *                                        BIAS_VAR)
      IF (.NOT.IBIASGAUSS) BIAS_PREFACTOR=0.0D0
      READ(INPUT_AMH,*) IBIASPOLY
      READ(INPUT_AMH,*) NBIASPOLY
      READ(INPUT_AMH,*) (BIASPOLY(I),I=1,NBIASPOLY)
      IF (NBIASPOLY.GT.100) THEN
         WRITE(SO,*) 'NBIAS TOO HIGH'
         STOP
      ENDIF
      IF (IBIASGAUSS.AND.IBIASPOLY) THEN
        WRITE(SO,*) 'POLYNOMIAL + GAUSSIAN BIAS CANNOT
     *                 BE ON AT SAME TIME'
         STOP
      ENDIF
      DO I=NBIASPOLY+1,100
        BIASPOLY(I)=0.0D0
      ENDDO
CCC  PART FOR PARTIAL CONTSTRAINT
CCC  MODE 1  FOR GENERATE LIST FOR F OF QS
CCC  MODE 2  FOR TWO SEPERATE BITS WITH FLEXIBLE PART IN BETWEEN

       READ(INPUT_AMH,*)
       READ(INPUT_AMH,*)CYCLIC
       WRITE(SO,*)'CYCLIC = ',CYCLIC
       READ(INPUT_AMH,*)CONST_MODE
       WRITE(SO,*)'CONST_MODE = ',CONST_MODE
       READ(INPUT_AMH,*) NUM_FOLDON_A
       WRITE(SO,*)'NUM_FOLDON_A',NUM_FOLDON_A
C        IF (NUM_FOLDON_A .EQ. 0) GOTO 75
         IF (NUM_FOLDON_A .GT. 30) STOP 'TOO MANY FOLDONS: MAX = 30'
       DO I = 1,NUM_FOLDON_A
          READ(INPUT_AMH,*) FOLDSTRT_MIN_A(I),FOLDSTRT_MAX_A(I)
          WRITE(SO,*) FOLDSTRT_MIN_A(I),FOLDSTRT_MAX_A(I),I
          IF( FOLDSTRT_MAX_A(I).GT.NMRES )THEN
          WRITE(OARCHV,724)FOLDSTRT_MAX_A,NMRES
724       FORMAT('FOLDSTRT_MAX_A TOO LARGE',2(1X,I3))
          STOP
          ENDIF
       ENDDO

       IF( CONST_MODE .EQ. 2 )THEN
              READ(INPUT_AMH,*) NUM_FOLDON_B
              WRITE(SO,*) NUM_FOLDON_B
            IF (NUM_FOLDON_B .GT. 20) STOP 'TOO MANY FOLDONS: MAX = 20'
                DO I = 1,NUM_FOLDON_B
                   READ(INPUT_AMH,*) FOLDSTRT_MIN_B(I),FOLDSTRT_MAX_B(I)
                   WRITE(SO,*) FOLDSTRT_MIN_B(I),FOLDSTRT_MAX_B(I)
                IF( FOLDSTRT_MAX_B(I).GT.NMRES )THEN
                    WRITE(OARCHV,725)FOLDSTRT_MAX_B,NMRES
725                 FORMAT('FOLDSTRT_MAX_B TOO LARGE',2(1X,I3))
                     STOP
                 ENDIF
            ENDDO
        ENDIF ! CONST_MODE

      READ(INPUT_AMH,*)
      READ(INPUT_AMH,*) I_QBIAS_A          ! NOW BIASING FUNCS THAT DEP ON Q
      WRITE(SO,*)'IQBIAS_A ',I_QBIAS_A
      READ(INPUT_AMH,*)N_Q_ANNEAL_A, Q0_INC_A
      WRITE(SO,*)'N_Q_ANNEAL_A Q0_INC_A', N_Q_ANNEAL_A, Q0_INC_A
      READ(INPUT_AMH,*)CON_LOCAL_A, CON_LOCAL_A_CUT
      WRITE(SO,*)'CON_LOCAL_A  CON_LOCAL_A_CUT',
     *                             CON_LOCAL_A,CON_LOCAL_A_CUT
      READ(INPUT_AMH,*) I_BIAS_NATIVE_A
      WRITE(SO,*)'I_BIAS_NATIVE_A',  I_BIAS_NATIVE_A
      READ(INPUT_AMH,*) SS_A
      WRITE(SO,*)'SS_A ', SS_A
      WRITE(SO,*)'SIMULATE S.S. UNITS SS_A ', SS_A
      IF (.NOT. SS_A) SS_PAT_ITER_A = 1
      IF (SS_A) SS_PAT_ITER_A = NUM_FOLDON_A 
      WRITE(SO,*)'SS_PAT_ITER_A ',SS_PAT_ITER_A
      READ(INPUT_AMH,*)(SS_PATTERN_A(I),I=1,SS_PAT_ITER_A)
       DO I = 1, SS_PAT_ITER_A
            WRITE(SO,*)'SS_PATTERN_A ',  SS_PATTERN_A(I)
       ENDDO

      READ(INPUT_AMH,*) WIDTH_QEXP_A
      WRITE(SO,*)'WIDTH_QEXP_A',  WIDTH_QEXP_A
      READ(INPUT_AMH,*) N_QBIAS_A
      WRITE(SO,*)'N_QBIAS_A', N_QBIAS_A
      READ(INPUT_AMH,*) I_Q_FORMAT_A
      WRITE(SO,*)'I_Q_FORMAT_A', I_Q_FORMAT_A 

      READ(INPUT_AMH,*) (QBIASPOLY_A(I),I=1,N_QBIAS_A)
      IF (N_QBIAS_A.GT.100) THEN
         WRITE(SO,*) 'N_QBIAS TOO HIGH'
         STOP
      ENDIF
      READ(INPUT_AMH,*) Q0_SAFE_A,Q_WEIGHT_A
      WRITE(SO,*)'Q0_SAFE_A  ', Q0_SAFE_A
      READ(INPUT_AMH,*) Q_CLIP_A
      WRITE(SO,*)'Q_CLIP_A  ', Q_CLIP_A

       Q0_A =  Q0_SAFE_A

      DO I=N_QBIAS_A+1,100
        QBIASPOLY_A(I)=0.0D0
      ENDDO

C  COUNT NUMBER OF CONTACTS FOR SS_A
          IF(SS_A)THEN
            TOTALSSNORM = 0
          DO I = 1,NUM_FOLDON_A
              TEMP_A = 0
           DO J = FOLDSTRT_MIN_A(I), FOLDSTRT_MAX_A(I)
              TEMP_A  = TEMP_A + 1
           ENDDO
              TOTALSSNORM = TOTALSSNORM + (TEMP_A-1)*(TEMP_A-2)
          ENDDO
              WRITE(SO,*)'TOTALSSNORM',TOTALSSNORM
          ENDIF ! SS_A

CCCCCCCCCCCCCCC   NEWNEWNEWNEWNEWNEW

      READ(INPUT_AMH,*)
      READ(INPUT_AMH,*) I_QBIAS_B         ! NOW BIASING FUNCS THAT DEP ON Q
      WRITE(SO,*)'I_QBIAS_B ',I_QBIAS_B
      READ(INPUT_AMH,*)N_Q_ANNEAL_B, Q0_INC_B
      WRITE(SO,*)'N_Q_ANNEAL_B, Q0_INC_B ', N_Q_ANNEAL_B, Q0_INC_B
      READ(INPUT_AMH,*)CON_LOCAL_B, CON_LOCAL_B_CUT
      WRITE(SO,*)'CON_LOCAL_B  CON_LOCAL_B_CUT',
     *                                  CON_LOCAL_B,CON_LOCAL_B_CUT
      READ(INPUT_AMH,*) I_BIAS_NATIVE_B
      WRITE(SO,*)'I_BIAS_NATIVE_B ', I_BIAS_NATIVE_B
      READ(INPUT_AMH,*) SS_B
      WRITE(SO,*)'SIMULATE S.S. UNITS  SS_B ', SS_B 
      IF (.NOT. SS_B) SS_PAT_ITER_B = 1
      IF (SS_B) SS_PAT_ITER_B = NUM_FOLDON_B
      WRITE(SO,*)'SS_PAT_ITER_B ',SS_PAT_ITER_B
      READ(INPUT_AMH,*)(SS_PATTERN_B(I),I=1,SS_PAT_ITER_B)
      READ(INPUT_AMH,*) WIDTH_QEXP_B
      READ(INPUT_AMH,*) N_QBIAS_B
      READ(INPUT_AMH,*) I_Q_FORMAT_B
      READ(INPUT_AMH,*) (QBIASPOLY_B(I),I=1,N_QBIAS_B)

      IF (N_QBIAS_B .GT. 100) THEN
         WRITE(SO,*) 'N_QBIAS_B TOO HIGH'
         STOP
      ENDIF
      READ(INPUT_AMH,*) Q0_SAFE_B,Q_WEIGHT_B
      READ(INPUT_AMH,*) Q_CLIP_B

      Q0_B = Q0_SAFE_B


      DO I=N_QBIAS_B+1,100
        QBIASPOLY_B(I)=0.0D0
      ENDDO

C MAKE CONSTRAINT LISTS

          DO I = 1,  MAXSIZ
             GAP(I) = 0
          ENDDO

          DO I = 1,  NMRES
	                SEGLIST_A(I) = 0
          ENDDO

          IF ( NUM_FOLDON_A .NE. 1 .AND. NUM_FOLDON_A .NE. 0) THEN
             DO I = 1,NUM_FOLDON_A - 1
               GAP(I) = FOLDSTRT_MIN_A(I+1) - FOLDSTRT_MAX_A(I) - 1
             ENDDO
          ENDIF

          DO I = 1,NUM_FOLDON_A
          IF ( I .EQ. 1 .AND. NUM_FOLDON_A .NE. 0 ) THEN
            DO J = FOLDSTRT_MIN_A(I), FOLDSTRT_MAX_A(I)
                SEGLIST_A(J - (FOLDSTRT_MIN_A(I)-1)) = J
                NUMCONST_A = J - (FOLDSTRT_MIN_A(I)-1)
            ENDDO
          ENDIF
          TEMPGAP = 0
          IF ( I .NE. 1 .AND. NUM_FOLDON_A .NE. 0 ) THEN
              DO K = 1 , I - 1
                  TEMPGAP = TEMPGAP + GAP(K)
              ENDDO
              DO J = FOLDSTRT_MIN_A(I), FOLDSTRT_MAX_A(I)
                  SEGLIST_A(J - TEMPGAP -  (FOLDSTRT_MIN_A(1)-1)) = J
                  NUMCONST_A = J - TEMPGAP  - (FOLDSTRT_MIN_A(1)-1)
              ENDDO
          ENDIF   ! IF ( I .NE. 1) THEN
          ENDDO

             WRITE(SO,*)'NUMCONST_A',NUMCONST_A
             DO I = 1, NUMCONST_A
               WRITE(SO,*)'SEGLIST_A ',  SEGLIST_A(I)
             ENDDO


CC CONSTRUCT  SECOND LIST

       IF (CONST_MODE .EQ. 1) THEN
             DO I = 1,  NMRES
                       SEGLIST_B(I)= 0
             ENDDO
             NUMCONST_B  = 0
             DO  266 K = 1 ,  NMRES
                 SWITCH = 0
              IF (NUM_FOLDON_A .EQ. 0) NUMCONST_A = NMRES
                  DO 255 J = 1, NUMCONST_B
                     IF  (SEGLIST_B(J) .EQ. K) SWITCH = 1
255            ENDDO
                 IF (SWITCH .EQ. 0) THEN
                    NUMCONST_B  = NUMCONST_B  + 1
                    SEGLIST_B(NUMCONST_B) =  K
                 ENDIF
266           ENDDO
      ENDIF  !    LISTMODE 1

C   LISTS FOR MANUAL ASSIGNMENT OF TWO LISTS FOR Q CONSTRAINTS

       IF (CONST_MODE .EQ. 2) THEN
             DO I = 1,  NMRES
                       SEGLIST_B(I)= 0
             ENDDO
                NUMCONST_B  = 0

          IF ( NUM_FOLDON_B .NE. 1 .AND. NUM_FOLDON_B .NE. 0) THEN
             DO I = 1,NUM_FOLDON_B - 1
                  GAP(I) = FOLDSTRT_MIN_B(I+1) - FOLDSTRT_MAX_B(I) - 1
             ENDDO
          ENDIF

          DO I = 1,NUM_FOLDON_B
          IF ( I .EQ. 1 .AND. NUM_FOLDON_B .NE. 0 ) THEN
            DO J = FOLDSTRT_MIN_B(I), FOLDSTRT_MAX_B(I)
                SEGLIST_B(J - (FOLDSTRT_MIN_B(I)-1)) = J
                NUMCONST_B = J - (FOLDSTRT_MIN_B(I)-1)
            ENDDO
          ENDIF
          TEMPGAP = 0
          IF ( I .NE. 1 .AND. NUM_FOLDON_B .NE. 0 ) THEN
              DO K = 1 , I - 1
                  TEMPGAP = TEMPGAP + GAP(K)
              ENDDO
              DO J = FOLDSTRT_MIN_B(I), FOLDSTRT_MAX_B(I)
                  SEGLIST_B(J - TEMPGAP -  (FOLDSTRT_MIN_B(1)-1)) = J
                  NUMCONST_B = J - TEMPGAP  - (FOLDSTRT_MIN_B(1)-1)
              ENDDO
          ENDIF   ! IF ( I .NE. 1) THEN
          ENDDO

           WRITE(SO,*)'NUMCONST_B',NUMCONST_B
                  DO I = 1,  NUMCONST_B
             WRITE(SO,*)'SEGLIST_B ',  SEGLIST_B(I)
                  ENDDO

        ENDIF  !    LISTMODE 2

C       IF (CON_LOCAL_A) THEN
C          J = 0 
C          DO I= 1, NUMCONST_A
C           IF((SEGLIST_A(I)+1-SEGLIST_A(I)).LT.CON_LOCAL_A_CUT)THEN
C                J = J  + 1
C           ENDIF
C          ENDDO
C         NUMCONST_A = J
C       ENDIF   ! IF (CON_LOCAL_A)  THEN
C
C
C       IF ( CON_LOCAL_B) THEN
C        J = 0 
C         DO I= 1, NUMCONST_B
C           IF((SEGLIST_B(I)+1 -SEGLIST_B(I)) .LT. CON_LOCAL_B_CUT)THEN 
C             J = J  + 1 
C           ENDIF 
C         ENDDO
C        NUMCONST_B = J 
C       ENDIF   ! IF (CON_LOCAL_B)  THEN
C
CCCCCCCCCCCCCCCCCC NEWNEWNEWNEWNEWNEW

      READ(INPUT_AMH,*)
      READ(INPUT_AMH,*) I_CONTACT_ORDER
      WRITE(SO,*)'I_CONTACT_ORDER ',I_CONTACT_ORDER
      READ(INPUT_AMH,*) N_CONTACT_ORDER_TERMS
      IF (N_CONTACT_ORDER_TERMS.GT.MAX_CONTACT_ORDER_TERMS) THEN
         WRITE(SO,*) 'N_CONTACT_ORDER_TERMS TOO BIG'
         STOP
      ENDIF
      DO I=1,N_CONTACT_ORDER_TERMS
        READ(INPUT_AMH,*) I_CONTACT_ORDER_MIN(I),I_CONTACT_ORDER_MAX(I)
        READ(INPUT_AMH,*) R_MIN_CONTACT_ORDER(I),R_MAX_CONTACT_ORDER(I)
        READ(INPUT_AMH,*) GAMMA_CONTACT_ORDER(I,1:3)
      ENDDO

CCCCCCCCCCCCCCCCCCCCHYDROGOEN BOND PARAMETERS

      READ(INPUT_AMH,*)
      READ(INPUT_AMH,*) I_CON_P_AP,I_ATOM_P_AP
      WRITE(SO,*)'I_CON_P_AP   I_ATOM_P_AP ',I_CON_P_AP, I_ATOM_P_AP
      READ(INPUT_AMH,*) R_CUT_P_AP,I_DIFF_P_AP
      WRITE(SO,*)'R_CUT_P_AP  I_DIFF_P_AP ',R_CUT_P_AP, I_DIFF_P_AP
      READ(INPUT_AMH,*) WEIGHT_P_AP(1:3)

      READ(INPUT_AMH,*)
      READ(INPUT_AMH,*) ALPHA_C_OF_N
      READ(INPUT_AMH,*) AB_C_OF_N_NEW
      READ(INPUT_AMH,*) AB_C_OF_N_OLD
      IF ( (ALPHA_C_OF_N.AND.AB_C_OF_N_NEW) .OR.
     *     (ALPHA_C_OF_N.AND.AB_C_OF_N_OLD) .OR.
     *     (AB_C_OF_N_NEW.AND.AB_C_OF_N_OLD) ) THEN
         WRITE(SO,*) 'C OF N PROBLEM',ALPHA_C_OF_N
         WRITE(SO,*) 'C OF N PROBLEM',AB_C_OF_N_NEW
         WRITE(SO,*) 'C OF N PROBLEM',AB_C_OF_N_OLD
         STOP
      ENDIF

      READ(INPUT_AMH,*)
      READ(INPUT_AMH,*) I_RG_BIAS          ! NOW BIASING FUNCS THAT DEP ON RG
      READ(INPUT_AMH,*) I_RG_COREY
      READ(INPUT_AMH,*) RG_BOUNDS(1)
      READ(INPUT_AMH,*) RG_BOUNDS(2)
      READ(INPUT_AMH,*) RG_SHIFT, RG_SCL
      READ(INPUT_AMH,*) I_RG_GARYK
      READ(INPUT_AMH,*) D_RG, T_RG, DELR_RG, M_RG, KAPPA_RG
      READ(INPUT_AMH,*) N_RG_BIAS
      READ(INPUT_AMH,*) (RG_BIASPOLY(I),I=1,N_RG_BIAS)
      IF (N_RG_BIAS.GT.100) THEN
         WRITE(SO,*) 'N_RG_BIAS TOO HIGH'
         STOP
      ENDIF
                                                                                                     
      IF (I_RG_COREY.AND.I_RG_GARYK) THEN
         WRITE(SO,*)
     *     'RG_BIAS: YOU MUST CHOOSE BETWEEN I_RG_COREY AND I_RG_GARYK'
         STOP
      ENDIF
                                                                                                     
      I_RG_FIRST=.TRUE.

      DO I=N_RG_BIAS+1,100
        RG_BIASPOLY(I)=0.0D0
      ENDDO

C     NMSTEP IS THE NUMBER OF TIME STEPS PER TEMPERATURE

      READ(INPUT_AMH,*)NMSTEP

C     READ SEED VALUES FOR RANDOM NUMBER GENERATORS

      READ(INPUT_AMH,*)ISEED_AMH
      WRITE(SO,*) 'ISEED_AMH',ISEED_AMH

C     IT1-IT5 ARE THEN NUMBER OF T GRID POINTS ALLOCATED TO EACH
C     OF THE INTERVALS [T1,T2], [T2,T3],...

C     T1-T5 ARE THE CUTOFF POINTS IN THE TEMPERATURE-ANNEALING
C     SCHEDULE

      READ(INPUT_AMH,*)
      READ(INPUT_AMH,*)
      READ(INPUT_AMH,*)IT1,T1
      READ(INPUT_AMH,*)IT2,T2
      READ(INPUT_AMH,*)IT3,T3
      READ(INPUT_AMH,*)IT4,T4
      READ(INPUT_AMH,*)IT5,T5

      WRITE(SO,*) IT1,IT2,IT3,IT4,IT5
      WRITE(SO,*) T1,T2,T3,T4,T5

C     IF ICTEMP, THEN THE MINIMIZATION IS PERFORMED AT A
C     CONSTANT TEMPERATURE, CTEMP

      READ(INPUT_AMH,*)ICTEMP
      READ(INPUT_AMH,*)CTEMP

      WRITE(SO,*)'ICTEMP ',ICTEMP
      WRITE(SO,*)'CTEMP  ',CTEMP

C     NMTEMP IS THE NUMBER OF TEMPERATURE GRID POINTS

      NMTEMP=IT1 + IT2 + IT3 + IT4
      IF( MXTEMP.LT.NMTEMP )THEN
         WRITE(OARCHV,981)MXTEMP,NMTEMP
  981    FORMAT(/'MXTEMP ',I6,' TOO SMALL ',I6)
         STOP
      ENDIF

       WRITE(SO,*) 'BOTTOM 3B'

C     INCMOV IS THE INCREMENT FOR THE NUMBER OF
C     STRUCTURES TO BE SAVED FIXED T

      READ(INPUT_AMH,*)
      READ(INPUT_AMH,*)INCMOV
      RNORM=FLOAT(NMTEMP)/FLOAT(INCMOV)
      IF( INT(RNORM).GT.NMDIF )THEN
         WRITE(OARCHV,728)INCMOV
  728    FORMAT(/'INCMOV TOO SMALL ',I3)
         STOP
      ENDIF

      READ(INPUT_AMH,*)

      READ(INPUT_AMH,*) I_V_TEST
      READ(INPUT_AMH,*) TEST_SITE(1),TEST_SITE(2)

      READ(INPUT_AMH,*)


C     IF IRESRT, THEN READ IN PREVIOUSLY GENERATED
C     PROTEINS USED FOR RESTARTING PROGRAM OR ANALYSIS

      READ(INPUT_AMH,*)IRESRT

C     IF ISCLTAB GO INTO SCLTAB

      READ(INPUT_AMH,*) ISCLTAB

C     IF ICLASSWEIGHT SCALE GAMMAS ACCORDING TO SRPLR
      READ(INPUT_AMH,*) ICLASSWEIGHT
      IF (ICLASSWEIGHT.AND.IGOMB) THEN
         WRITE(SO,*) 'CANNOT DIVIDE ENERGIES INTO S/LR IF IGOMB=TRUE'
         STOP
      ENDIF

C      IF MOVANAL, THEN PERFORM ANALYSIS OF MOVIE STRS ONLY

      READ(INPUT_AMH,*) MOVANAL
      READ(INPUT_AMH,*) QUENCH
      WRITE(SO,*) 'QUENCH=',QUENCH 
      READ(INPUT_AMH,*) I_ETIM,I_ETIM_STEP

C     CHECK NMDIF LARGE ENOUGH -- ROLLING D AVERAGE


      RNORM=FLOAT(NMSTEP)/FLOAT(INCMOV)
      IF( INT(RNORM).GT.NMDIF )THEN
         WRITE(OARCHV,251)NMSTEP,INCMOV,NMDIF
  251    FORMAT(/'NMDIF TOO SMALL:NMSTEP ',I5,
     *           ' INCMOV ',I5,' NMDIF ',I5)
         STOP
      ENDIF


C     SET ANNEALING GRID PARAMETERS

      ITGRD(1)=IT1
      ITGRD(2)=IT2
      ITGRD(3)=IT3
      ITGRD(4)=IT4
  
      TEMGRD(1)=T1
      TEMGRD(2)=T2
      TEMGRD(3)=T3
      TEMGRD(4)=T4
      TEMGRD(5)=T5

C     SET CHARGE WEIGHTS



CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C     PRINT HEADER FOR ARCHIVE FILE

      WRITE(SO,*) 'ABOUT TO PRINT HEADER'
 
            IUNIT=OARCHV

C        ECHO RELEVANT PARAMETERS

         IF (MOVANAL) WRITE(IUNIT,*) 'MOVIE STR ANALYSIS ONLY'

C         WRITE(IUNIT,145)
C  145    FORMAT('PARAMETER LIST'/)

C         WRITE(IUNIT,102)NMRES
C  102    FORMAT('PROTEIN LENGTH ',I3)

C         WRITE(IUNIT,103)NUMPRO
C  103    FORMAT('ENSEMBLE SIZE ',I3)

C        POTENTIAL PARAMETERS

        WRITE(IUNIT,151)
  151    FORMAT(/'POTENTIAL PARAMETERS'/)

         WRITE(IUNIT,141)NUMMEM
  141    FORMAT('ACTUAL # PROTEIN MEMORIES ',I4)

         WRITE(IUNIT,270)NUMCRD
  270    FORMAT(/'NUMBER OF COORDINATE TYPES ',I2,
     *          ' BETA-COORDINATES ',L1)

         WRITE(IUNIT,271)NUMTAB,
     *                  ((CRDIXN(I1,I2),I2=1,2),I1=1,NUMTAB)
  271    FORMAT('IXNS: ',I2,' COORDINATES ',4('(',I2,',',I2,')'))

         WRITE(IUNIT,107)TIMSTP
  107    FORMAT(/'TIMSTP ',1PE10.3)
       
         WRITE(IUNIT,378)OXSCL,RAMASCL
  378    FORMAT('OX POT ON: ',' OXY SCL ',F8.3,' RMA SCL ',F8.3)

           WRITE(IUNIT,376)CHRLSCL
  376      FORMAT('CHIRAL POT ON: ',' SCALING FACTOR ',F8.3)

C         WRITE(IUNIT,11379) LAMBDAR
C11379    FORMAT('LAMBDAR: ',F8.3)

C            WRITE (IUNIT,123)
C  123       FORMAT('CHARGES=HYDROPHOBICITY ')

C         WRITE(IUNIT,148)DELTA,DELTE
C  148    FORMAT(/'WELL-WIDTH ',1PE10.3,' EXPONENT ',
C     *          1PE10.3)

C         WRITE(IUNIT,817)IEXCLD,PEXCLD
C  817    FORMAT(/'EXCLUDED VOLUME ',L1,
C     *          ' HARMONIC COEFFICIENT ',1PE10.3)

C	  WRITE(IUNIT,818)OXEXCLDV,OEXCLDSCL
C  818	  FORMAT(/'OX. EXLCUDED VOLUME',L1,
C     *          'SCALE FACTOR ', 1PE10.3)


C       PRINT SEEDS FOR RANDOM NUMBER GENERATORS

C         WRITE(IUNIT,844)
C  844    FORMAT(/'SEEDS FOR RANDOM NUMBER GENERATORS')
C         WRITE(IUNIT,843)ISEED_AMH

C  843    FORMAT('ISEED_AMHS ',4(I10,2X))


C         WRITE(IUNIT,795)WELSCL
C  795    FORMAT('WELL SCALE ',L1)

C        ANNEALING PARAMETERS

C         WRITE(IUNIT,140)
C  140    FORMAT(/'ANNEALING PARAMETERS'/)

C         WRITE(IUNIT,104)NMTEMP,NMSTEP
C  104    FORMAT('# TEMPERATURE SETS ',I8,
C     *          ' # TIME STEPS/T ',I6)

C         WRITE(IUNIT,113)ICTEMP,CTEMP
C  113    FORMAT('FIXED T ',L1,' @T=',1PE12.5)

C         WRITE(IUNIT,114)
C  114    FORMAT('TEMPERATURE-ANNEALING GRID')

C         WRITE(IUNIT,115)(ITGRD(I1),I1=1,4),NMTEMP
C  115    FORMAT(5(I12,1X))

C         WRITE(IUNIT,116)(TEMGRD(I1),I1=1,5)
C  116    FORMAT(5(1PE12.5,1X))


C        PRINT H SCALE

         DO 503 I503=1,20
            HYDSCL(I503,2)=HYDSCL(I503,1)
  503    CONTINUE
         HYDSCL(8,2)=0.0D0

         WRITE(IUNIT,118)
  118    FORMAT(/'HARD-SPHERE RADII'/)

C         WRITE(OARCHV,868)
C  868    FORMAT('REDUCED HARD-SPHERE RADII ON BETA-CARBONS'/)

         WRITE(IUNIT,389)
  389    FORMAT('ALPHA-CARBONS')
         WRITE(IUNIT,119)(AMINOA(I1),HRDRAD(I1,1),I1=1,20)
  119    FORMAT(5(A4,1X,F5.2,2X))
         WRITE(IUNIT,*)
         WRITE(IUNIT,379)
  379    FORMAT('BETA-CARBONS')
         WRITE(IUNIT,119)(AMINOA(I1),HRDRAD(I1,2),I1=1,20)

C     END HEADER
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C     CREATE QCHRG
      CALL QCHRGMK(QCHRG,QCHRG2,OARCHV,N_LETTERS)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C     CREATE ALTERNATIVE GAMMA (OR QCHRG IF YOU WILL)
C      CALL READ_ALTGAMMA()


C     SET DIAGNOSTIC FLAG

      IDIGNS=.TRUE.
C     ---------------------- DONE -----------------------
      RETURN
      END
