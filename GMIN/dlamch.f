      DOUBLE PRECISION FUNCTION DLAMCH( CMACH )
*
*  -- LAPACK AUXILIARY ROUTINE (VERSION 2.0) --
*     UNIV. OF TENNESSEE, UNIV. OF CALIFORNIA BERKELEY, NAG LTD.,
*     COURANT INSTITUTE, ARGONNE NATIONAL LAB, AND RICE UNIVERSITY
*     OCTOBER 31, 1992
*
*     .. SCALAR ARGUMENTS ..
      CHARACTER          CMACH
*     ..
*
*  PURPOSE
*  =======
*
*  DLAMCH DETERMINES DOUBLE PRECISION MACHINE PARAMETERS.
*
*  ARGUMENTS
*  =========
*
*  CMACH   (INPUT) CHARACTER(LEN=1)
*          SPECIFIES THE VALUE TO BE RETURNED BY DLAMCH:
*          = 'E' OR 'E',   DLAMCH := EPS
*          = 'S' OR 'S ,   DLAMCH := SFMIN
*          = 'B' OR 'B',   DLAMCH := BASE
*          = 'P' OR 'P',   DLAMCH := EPS*BASE
*          = 'N' OR 'N',   DLAMCH := T
*          = 'R' OR 'R',   DLAMCH := RND
*          = 'M' OR 'M',   DLAMCH := EMIN
*          = 'U' OR 'U',   DLAMCH := RMIN
*          = 'L' OR 'L',   DLAMCH := EMAX
*          = 'O' OR 'O',   DLAMCH := RMAX
*
*          WHERE
*
*          EPS   = RELATIVE MACHINE PRECISION
*          SFMIN = SAFE MINIMUM, SUCH THAT 1/SFMIN DOES NOT OVERFLOW
*          BASE  = BASE OF THE MACHINE
*          PREC  = EPS*BASE
*          T     = NUMBER OF (BASE) DIGITS IN THE MANTISSA
*          RND   = 1.0 WHEN ROUNDING OCCURS IN ADDITION, 0.0 OTHERWISE
*          EMIN  = MINIMUM EXPONENT BEFORE (GRADUAL) UNDERFLOW
*          RMIN  = UNDERFLOW THRESHOLD - BASE**(EMIN-1)
*          EMAX  = LARGEST EXPONENT BEFORE OVERFLOW
*          RMAX  = OVERFLOW THRESHOLD  - (BASE**EMAX)*(1-EPS)
*
* =====================================================================
*
*     .. PARAMETERS ..
      DOUBLE PRECISION   ONE, ZERO
      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     ..
*     .. LOCAL SCALARS ..
      LOGICAL            FIRST, LRND
      INTEGER            BETA, IMAX, IMIN, IT
      DOUBLE PRECISION   BASE, EMAX, EMIN, EPS, PREC, RMACH, RMAX, RMIN,
     $                   RND, SFMIN, SMALL, T
*     ..
*     .. EXTERNAL FUNCTIONS ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     ..
*     .. EXTERNAL SUBROUTINES ..
      EXTERNAL           DLAMC2
*     ..
*     .. SAVE STATEMENT ..
      SAVE               FIRST, EPS, SFMIN, BASE, T, RND, EMIN, RMIN,
     $                   EMAX, RMAX, PREC
*     ..
*     .. DATA STATEMENTS ..
      DATA               FIRST / .TRUE. /
*     ..
*     .. EXECUTABLE STATEMENTS ..
*
      IF( FIRST ) THEN
         FIRST = .FALSE.
         CALL DLAMC2( BETA, IT, LRND, EPS, IMIN, RMIN, IMAX, RMAX )
         BASE = BETA
         T = IT
         IF( LRND ) THEN
            RND = ONE
            EPS = ( BASE**( 1-IT ) ) / 2
         ELSE
            RND = ZERO
            EPS = BASE**( 1-IT )
         END IF
         PREC = EPS*BASE
         EMIN = IMIN
         EMAX = IMAX
         SFMIN = RMIN
         SMALL = ONE / RMAX
         IF( SMALL.GE.SFMIN ) THEN
*
*           USE SMALL PLUS A BIT, TO AVOID THE POSSIBILITY OF ROUNDING
*           CAUSING OVERFLOW WHEN COMPUTING  1/SFMIN.
*
            SFMIN = SMALL*( ONE+EPS )
         END IF
      END IF
*
      IF( LSAME( CMACH, 'E' ) ) THEN
         RMACH = EPS
      ELSE IF( LSAME( CMACH, 'S' ) ) THEN
         RMACH = SFMIN
      ELSE IF( LSAME( CMACH, 'B' ) ) THEN
         RMACH = BASE
      ELSE IF( LSAME( CMACH, 'P' ) ) THEN
         RMACH = PREC
      ELSE IF( LSAME( CMACH, 'N' ) ) THEN
         RMACH = T
      ELSE IF( LSAME( CMACH, 'R' ) ) THEN
         RMACH = RND
      ELSE IF( LSAME( CMACH, 'M' ) ) THEN
         RMACH = EMIN
      ELSE IF( LSAME( CMACH, 'U' ) ) THEN
         RMACH = RMIN
      ELSE IF( LSAME( CMACH, 'L' ) ) THEN
         RMACH = EMAX
      ELSE IF( LSAME( CMACH, 'O' ) ) THEN
         RMACH = RMAX
      END IF
*
      DLAMCH = RMACH
      RETURN
*
*     END OF DLAMCH
*
      END
*
************************************************************************
*
      SUBROUTINE DLAMC1( BETA, T, RND, IEEE1 )
*
*  -- LAPACK AUXILIARY ROUTINE (VERSION 2.0) --
*     UNIV. OF TENNESSEE, UNIV. OF CALIFORNIA BERKELEY, NAG LTD.,
*     COURANT INSTITUTE, ARGONNE NATIONAL LAB, AND RICE UNIVERSITY
*     OCTOBER 31, 1992
*
*     .. SCALAR ARGUMENTS ..
      LOGICAL            IEEE1, RND
      INTEGER            BETA, T
*     ..
*
*  PURPOSE
*  =======
*
*  DLAMC1 DETERMINES THE MACHINE PARAMETERS GIVEN BY BETA, T, RND, AND
*  IEEE1.
*
*  ARGUMENTS
*  =========
*
*  BETA    (OUTPUT) INTEGER
*          THE BASE OF THE MACHINE.
*
*  T       (OUTPUT) INTEGER
*          THE NUMBER OF ( BETA ) DIGITS IN THE MANTISSA.
*
*  RND     (OUTPUT) LOGICAL
*          SPECIFIES WHETHER PROPER ROUNDING  ( RND = .TRUE. )  OR
*          CHOPPING  ( RND = .FALSE. )  OCCURS IN ADDITION. THIS MAY NOT
*          BE A RELIABLE GUIDE TO THE WAY IN WHICH THE MACHINE PERFORMS
*          ITS ARITHMETIC.
*
*  IEEE1   (OUTPUT) LOGICAL
*          SPECIFIES WHETHER ROUNDING APPEARS TO BE DONE IN THE IEEE
*          'ROUND TO NEAREST' STYLE.
*
*  FURTHER DETAILS
*  ===============
*
*  THE ROUTINE IS BASED ON THE ROUTINE  ENVRON  BY MALCOLM AND
*  INCORPORATES SUGGESTIONS BY GENTLEMAN AND MAROVICH. SEE
*
*     MALCOLM M. A. (1972) ALGORITHMS TO REVEAL PROPERTIES OF
*        FLOATING-POINT ARITHMETIC. COMMS. OF THE ACM, 15, 949-951.
*
*     GENTLEMAN W. M. AND MAROVICH S. B. (1974) MORE ON ALGORITHMS
*        THAT REVEAL PROPERTIES OF FLOATING POINT ARITHMETIC UNITS.
*        COMMS. OF THE ACM, 17, 276-277.
*
* =====================================================================
*
*     .. LOCAL SCALARS ..
      LOGICAL            FIRST, LIEEE1, LRND
      INTEGER            LBETA, LT
      DOUBLE PRECISION   A, B, C, F, ONE, QTR, SAVEC, T1, T2
*     ..
*     .. EXTERNAL FUNCTIONS ..
      DOUBLE PRECISION   DLAMC3
      EXTERNAL           DLAMC3
*     ..
*     .. SAVE STATEMENT ..
      SAVE               FIRST, LIEEE1, LBETA, LRND, LT
*     ..
*     .. DATA STATEMENTS ..
      DATA               FIRST / .TRUE. /
*     ..
*     .. EXECUTABLE STATEMENTS ..
*
      IF( FIRST ) THEN
         FIRST = .FALSE.
         ONE = 1
*
*        LBETA,  LIEEE1,  LT AND  LRND  ARE THE  LOCAL VALUES  OF  BETA,
*        IEEE1, T AND RND.
*
*        THROUGHOUT THIS ROUTINE  WE USE THE FUNCTION  DLAMC3  TO ENSURE
*        THAT RELEVANT VALUES ARE  STORED AND NOT HELD IN REGISTERS,  OR
*        ARE NOT AFFECTED BY OPTIMIZERS.
*
*        COMPUTE  A = 2.0**M  WITH THE  SMALLEST POSITIVE INTEGER M SUCH
*        THAT
*
*           FL( A + 1.0 ) = A.
*
         A = 1
         C = 1
*
*+       WHILE( C.EQ.ONE )LOOP
   10    CONTINUE
         IF( C.EQ.ONE ) THEN
            A = 2*A
            C = DLAMC3( A, ONE )
            C = DLAMC3( C, -A )
            GO TO 10
         END IF
*+       END WHILE
*
*        NOW COMPUTE  B = 2.0**M  WITH THE SMALLEST POSITIVE INTEGER M
*        SUCH THAT
*
*           FL( A + B ) .GT. A.
*
         B = 1
         C = DLAMC3( A, B )
*
*+       WHILE( C.EQ.A )LOOP
   20    CONTINUE
         IF( C.EQ.A ) THEN
            B = 2*B
            C = DLAMC3( A, B )
            GO TO 20
         END IF
*+       END WHILE
*
*        NOW COMPUTE THE BASE.  A AND C  ARE NEIGHBOURING FLOATING POINT
*        NUMBERS  IN THE  INTERVAL  ( BETA**T, BETA**( T + 1 ) )  AND SO
*        THEIR DIFFERENCE IS BETA. ADDING 0.25 TO C IS TO ENSURE THAT IT
*        IS TRUNCATED TO BETA AND NOT ( BETA - 1 ).
*
         QTR = ONE / 4
         SAVEC = C
         C = DLAMC3( C, -A )
         LBETA = C + QTR
*
*        NOW DETERMINE WHETHER ROUNDING OR CHOPPING OCCURS,  BY ADDING A
*        BIT  LESS  THAN  BETA/2  AND A  BIT  MORE  THAN  BETA/2  TO  A.
*
         B = LBETA
         F = DLAMC3( B / 2, -B / 100 )
         C = DLAMC3( F, A )
         IF( C.EQ.A ) THEN
            LRND = .TRUE.
         ELSE
            LRND = .FALSE.
         END IF
         F = DLAMC3( B / 2, B / 100 )
         C = DLAMC3( F, A )
         IF( ( LRND ) .AND. ( C.EQ.A ) )
     $      LRND = .FALSE.
*
*        TRY AND DECIDE WHETHER ROUNDING IS DONE IN THE  IEEE  'ROUND TO
*        NEAREST' STYLE. B/2 IS HALF A UNIT IN THE LAST PLACE OF THE TWO
*        NUMBERS A AND SAVEC. FURTHERMORE, A IS EVEN, I.E. HAS LAST  BIT
*        ZERO, AND SAVEC IS ODD. THUS ADDING B/2 TO A SHOULD NOT  CHANGE
*        A, BUT ADDING B/2 TO SAVEC SHOULD CHANGE SAVEC.
*
         T1 = DLAMC3( B / 2, A )
         T2 = DLAMC3( B / 2, SAVEC )
         LIEEE1 = ( T1.EQ.A ) .AND. ( T2.GT.SAVEC ) .AND. LRND
*
*        NOW FIND  THE  MANTISSA, T.  IT SHOULD  BE THE  INTEGER PART OF
*        LOG TO THE BASE BETA OF A,  HOWEVER IT IS SAFER TO DETERMINE  T
*        BY POWERING.  SO WE FIND T AS THE SMALLEST POSITIVE INTEGER FOR
*        WHICH
*
*           FL( BETA**T + 1.0 ) = 1.0.
*
         LT = 0
         A = 1
         C = 1
*
*+       WHILE( C.EQ.ONE )LOOP
   30    CONTINUE
         IF( C.EQ.ONE ) THEN
            LT = LT + 1
            A = A*LBETA
            C = DLAMC3( A, ONE )
            C = DLAMC3( C, -A )
            GO TO 30
         END IF
*+       END WHILE
*
      END IF
*
      BETA = LBETA
      T = LT
      RND = LRND
      IEEE1 = LIEEE1
      RETURN
*
*     END OF DLAMC1
*
      END
*
************************************************************************
*
      SUBROUTINE DLAMC2( BETA, T, RND, EPS, EMIN, RMIN, EMAX, RMAX )
*
*  -- LAPACK AUXILIARY ROUTINE (VERSION 2.0) --
*     UNIV. OF TENNESSEE, UNIV. OF CALIFORNIA BERKELEY, NAG LTD.,
*     COURANT INSTITUTE, ARGONNE NATIONAL LAB, AND RICE UNIVERSITY
*     OCTOBER 31, 1992
*
*     .. SCALAR ARGUMENTS ..
      LOGICAL            RND
      INTEGER            BETA, EMAX, EMIN, T
      DOUBLE PRECISION   EPS, RMAX, RMIN
*     ..
*
*  PURPOSE
*  =======
*
*  DLAMC2 DETERMINES THE MACHINE PARAMETERS SPECIFIED IN ITS ARGUMENT
*  LIST.
*
*  ARGUMENTS
*  =========
*
*  BETA    (OUTPUT) INTEGER
*          THE BASE OF THE MACHINE.
*
*  T       (OUTPUT) INTEGER
*          THE NUMBER OF ( BETA ) DIGITS IN THE MANTISSA.
*
*  RND     (OUTPUT) LOGICAL
*          SPECIFIES WHETHER PROPER ROUNDING  ( RND = .TRUE. )  OR
*          CHOPPING  ( RND = .FALSE. )  OCCURS IN ADDITION. THIS MAY NOT
*          BE A RELIABLE GUIDE TO THE WAY IN WHICH THE MACHINE PERFORMS
*          ITS ARITHMETIC.
*
*  EPS     (OUTPUT) DOUBLE PRECISION
*          THE SMALLEST POSITIVE NUMBER SUCH THAT
*
*             FL( 1.0 - EPS ) .LT. 1.0,
*
*          WHERE FL DENOTES THE COMPUTED VALUE.
*
*  EMIN    (OUTPUT) INTEGER
*          THE MINIMUM EXPONENT BEFORE (GRADUAL) UNDERFLOW OCCURS.
*
*  RMIN    (OUTPUT) DOUBLE PRECISION
*          THE SMALLEST NORMALIZED NUMBER FOR THE MACHINE, GIVEN BY
*          BASE**( EMIN - 1 ), WHERE  BASE  IS THE FLOATING POINT VALUE
*          OF BETA.
*
*  EMAX    (OUTPUT) INTEGER
*          THE MAXIMUM EXPONENT BEFORE OVERFLOW OCCURS.
*
*  RMAX    (OUTPUT) DOUBLE PRECISION
*          THE LARGEST POSITIVE NUMBER FOR THE MACHINE, GIVEN BY
*          BASE**EMAX * ( 1 - EPS ), WHERE  BASE  IS THE FLOATING POINT
*          VALUE OF BETA.
*
*  FURTHER DETAILS
*  ===============
*
*  THE COMPUTATION OF  EPS  IS BASED ON A ROUTINE PARANOIA BY
*  W. KAHAN OF THE UNIVERSITY OF CALIFORNIA AT BERKELEY.
*
* =====================================================================
*
*     .. LOCAL SCALARS ..
      LOGICAL            FIRST, IEEE, IWARN, LIEEE1, LRND
      INTEGER            GNMIN, GPMIN, I, LBETA, LEMAX, LEMIN, LT,
     $                   NGNMIN, NGPMIN
      DOUBLE PRECISION   A, B, C, HALF, LEPS, LRMAX, LRMIN, ONE, RBASE,
     $                   SIXTH, SMALL, THIRD, TWO, ZERO
*     ..
*     .. EXTERNAL FUNCTIONS ..
      DOUBLE PRECISION   DLAMC3
      EXTERNAL           DLAMC3
*     ..
*     .. EXTERNAL SUBROUTINES ..
      EXTERNAL           DLAMC1, DLAMC4, DLAMC5
*     ..
*     .. INTRINSIC FUNCTIONS ..
      INTRINSIC          ABS, MAX, MIN
*     ..
*     .. SAVE STATEMENT ..
      SAVE               FIRST, IWARN, LBETA, LEMAX, LEMIN, LEPS, LRMAX,
     $                   LRMIN, LT
*     ..
*     .. DATA STATEMENTS ..
      DATA               FIRST / .TRUE. / , IWARN / .FALSE. /
*     ..
*     .. EXECUTABLE STATEMENTS ..
*
      IF( FIRST ) THEN
         FIRST = .FALSE.
         ZERO = 0
         ONE = 1
         TWO = 2
*
*        LBETA, LT, LRND, LEPS, LEMIN AND LRMIN  ARE THE LOCAL VALUES OF
*        BETA, T, RND, EPS, EMIN AND RMIN.
*
*        THROUGHOUT THIS ROUTINE  WE USE THE FUNCTION  DLAMC3  TO ENSURE
*        THAT RELEVANT VALUES ARE STORED  AND NOT HELD IN REGISTERS,  OR
*        ARE NOT AFFECTED BY OPTIMIZERS.
*
*        DLAMC1 RETURNS THE PARAMETERS  LBETA, LT, LRND AND LIEEE1.
*
         CALL DLAMC1( LBETA, LT, LRND, LIEEE1 )
*
*        START TO FIND EPS.
*
         B = LBETA
         A = B**( -LT )
         LEPS = A
*
*        TRY SOME TRICKS TO SEE WHETHER OR NOT THIS IS THE CORRECT  EPS.
*
         B = TWO / 3
         HALF = ONE / 2
         SIXTH = DLAMC3( B, -HALF )
         THIRD = DLAMC3( SIXTH, SIXTH )
         B = DLAMC3( THIRD, -HALF )
         B = DLAMC3( B, SIXTH )
         B = ABS( B )
         IF( B.LT.LEPS )
     $      B = LEPS
*
         LEPS = 1
*
*+       WHILE( ( LEPS.GT.B ).AND.( B.GT.ZERO ) )LOOP
   10    CONTINUE
         IF( ( LEPS.GT.B ) .AND. ( B.GT.ZERO ) ) THEN
            LEPS = B
            C = DLAMC3( HALF*LEPS, ( TWO**5 )*( LEPS**2 ) )
            C = DLAMC3( HALF, -C )
            B = DLAMC3( HALF, C )
            C = DLAMC3( HALF, -B )
            B = DLAMC3( HALF, C )
            GO TO 10
         END IF
*+       END WHILE
*
         IF( A.LT.LEPS )
     $      LEPS = A
*
*        COMPUTATION OF EPS COMPLETE.
*
*        NOW FIND  EMIN.  LET A = + OR - 1, AND + OR - (1 + BASE**(-3)).
*        KEEP DIVIDING  A BY BETA UNTIL (GRADUAL) UNDERFLOW OCCURS. THIS
*        IS DETECTED WHEN WE CANNOT RECOVER THE PREVIOUS A.
*
         RBASE = ONE / LBETA
         SMALL = ONE
         DO 20 I = 1, 3
            SMALL = DLAMC3( SMALL*RBASE, ZERO )
   20    CONTINUE
         A = DLAMC3( ONE, SMALL )
         CALL DLAMC4( NGPMIN, ONE, LBETA )
         CALL DLAMC4( NGNMIN, -ONE, LBETA )
         CALL DLAMC4( GPMIN, A, LBETA )
         CALL DLAMC4( GNMIN, -A, LBETA )
         IEEE = .FALSE.
*
         IF( ( NGPMIN.EQ.NGNMIN ) .AND. ( GPMIN.EQ.GNMIN ) ) THEN
            IF( NGPMIN.EQ.GPMIN ) THEN
               LEMIN = NGPMIN
*            ( NON TWOS-COMPLEMENT MACHINES, NO GRADUAL UNDERFLOW;
*              E.G.,  VAX )
            ELSE IF( ( GPMIN-NGPMIN ).EQ.3 ) THEN
               LEMIN = NGPMIN - 1 + LT
               IEEE = .TRUE.
*            ( NON TWOS-COMPLEMENT MACHINES, WITH GRADUAL UNDERFLOW;
*              E.G., IEEE STANDARD FOLLOWERS )
            ELSE
               LEMIN = MIN( NGPMIN, GPMIN )
*            ( A GUESS; NO KNOWN MACHINE )
               IWARN = .TRUE.
            END IF
*
         ELSE IF( ( NGPMIN.EQ.GPMIN ) .AND. ( NGNMIN.EQ.GNMIN ) ) THEN
            IF( ABS( NGPMIN-NGNMIN ).EQ.1 ) THEN
               LEMIN = MAX( NGPMIN, NGNMIN )
*            ( TWOS-COMPLEMENT MACHINES, NO GRADUAL UNDERFLOW;
*              E.G., CYBER 205 )
            ELSE
               LEMIN = MIN( NGPMIN, NGNMIN )
*            ( A GUESS; NO KNOWN MACHINE )
               IWARN = .TRUE.
            END IF
*
         ELSE IF( ( ABS( NGPMIN-NGNMIN ).EQ.1 ) .AND.
     $            ( GPMIN.EQ.GNMIN ) ) THEN
            IF( ( GPMIN-MIN( NGPMIN, NGNMIN ) ).EQ.3 ) THEN
               LEMIN = MAX( NGPMIN, NGNMIN ) - 1 + LT
*            ( TWOS-COMPLEMENT MACHINES WITH GRADUAL UNDERFLOW;
*              NO KNOWN MACHINE )
            ELSE
               LEMIN = MIN( NGPMIN, NGNMIN )
*            ( A GUESS; NO KNOWN MACHINE )
               IWARN = .TRUE.
            END IF
*
         ELSE
            LEMIN = MIN( NGPMIN, NGNMIN, GPMIN, GNMIN )
*         ( A GUESS; NO KNOWN MACHINE )
            IWARN = .TRUE.
         END IF
***
* COMMENT OUT THIS IF BLOCK IF EMIN IS OK
         IF( IWARN ) THEN
            FIRST = .TRUE.
            WRITE( 6, FMT = 9999 )LEMIN
         END IF
***
*
*        ASSUME IEEE ARITHMETIC IF WE FOUND DENORMALISED  NUMBERS ABOVE,
*        OR IF ARITHMETIC SEEMS TO ROUND IN THE  IEEE STYLE,  DETERMINED
*        IN ROUTINE DLAMC1. A TRUE IEEE MACHINE SHOULD HAVE BOTH  THINGS
*        TRUE; HOWEVER, FAULTY MACHINES MAY HAVE ONE OR THE OTHER.
*
         IEEE = IEEE .OR. LIEEE1
*
*        COMPUTE  RMIN BY SUCCESSIVE DIVISION BY  BETA. WE COULD COMPUTE
*        RMIN AS BASE**( EMIN - 1 ),  BUT SOME MACHINES UNDERFLOW DURING
*        THIS COMPUTATION.
*
         LRMIN = 1
         DO 30 I = 1, 1 - LEMIN
            LRMIN = DLAMC3( LRMIN*RBASE, ZERO )
   30    CONTINUE
*
*        FINALLY, CALL DLAMC5 TO COMPUTE EMAX AND RMAX.
*
         CALL DLAMC5( LBETA, LT, LEMIN, IEEE, LEMAX, LRMAX )
      END IF
*
      BETA = LBETA
      T = LT
      RND = LRND
      EPS = LEPS
      EMIN = LEMIN
      RMIN = LRMIN
      EMAX = LEMAX
      RMAX = LRMAX
*
      RETURN
*
 9999 FORMAT( / / ' WARNING. THE VALUE EMIN MAY BE INCORRECT:-',
     $      '  EMIN = ', I8, /
     $      ' IF, AFTER INSPECTION, THE VALUE EMIN LOOKS',
     $      ' ACCEPTABLE PLEASE COMMENT OUT ',
     $      / ' THE IF BLOCK AS MARKED WITHIN THE CODE OF ROUTINE',
     $      ' DLAMC2,', / ' OTHERWISE SUPPLY EMIN EXPLICITLY.', / )
*
*     END OF DLAMC2
*
      END
*
************************************************************************
*
      DOUBLE PRECISION FUNCTION DLAMC3( A, B )
*
*  -- LAPACK AUXILIARY ROUTINE (VERSION 2.0) --
*     UNIV. OF TENNESSEE, UNIV. OF CALIFORNIA BERKELEY, NAG LTD.,
*     COURANT INSTITUTE, ARGONNE NATIONAL LAB, AND RICE UNIVERSITY
*     OCTOBER 31, 1992
*
*     .. SCALAR ARGUMENTS ..
      DOUBLE PRECISION   A, B
*     ..
*
*  PURPOSE
*  =======
*
*  DLAMC3  IS INTENDED TO FORCE  A  AND  B  TO BE STORED PRIOR TO DOING
*  THE ADDITION OF  A  AND  B ,  FOR USE IN SITUATIONS WHERE OPTIMIZERS
*  MIGHT HOLD ONE OF THESE IN A REGISTER.
*
*  ARGUMENTS
*  =========
*
*  A, B    (INPUT) DOUBLE PRECISION
*          THE VALUES A AND B.
*
* =====================================================================
*
*     .. EXECUTABLE STATEMENTS ..
*
      DLAMC3 = A + B
*
      RETURN
*
*     END OF DLAMC3
*
      END
*
************************************************************************
*
      SUBROUTINE DLAMC4( EMIN, START, BASE )
*
*  -- LAPACK AUXILIARY ROUTINE (VERSION 2.0) --
*     UNIV. OF TENNESSEE, UNIV. OF CALIFORNIA BERKELEY, NAG LTD.,
*     COURANT INSTITUTE, ARGONNE NATIONAL LAB, AND RICE UNIVERSITY
*     OCTOBER 31, 1992
*
*     .. SCALAR ARGUMENTS ..
      INTEGER            BASE, EMIN
      DOUBLE PRECISION   START
*     ..
*
*  PURPOSE
*  =======
*
*  DLAMC4 IS A SERVICE ROUTINE FOR DLAMC2.
*
*  ARGUMENTS
*  =========
*
*  EMIN    (OUTPUT) EMIN
*          THE MINIMUM EXPONENT BEFORE (GRADUAL) UNDERFLOW, COMPUTED BY
*          SETTING A = START AND DIVIDING BY BASE UNTIL THE PREVIOUS A
*          CAN NOT BE RECOVERED.
*
*  START   (INPUT) DOUBLE PRECISION
*          THE STARTING POINT FOR DETERMINING EMIN.
*
*  BASE    (INPUT) INTEGER
*          THE BASE OF THE MACHINE.
*
* =====================================================================
*
*     .. LOCAL SCALARS ..
      INTEGER            I
      DOUBLE PRECISION   A, B1, B2, C1, C2, D1, D2, ONE, RBASE, ZERO
*     ..
*     .. EXTERNAL FUNCTIONS ..
      DOUBLE PRECISION   DLAMC3
      EXTERNAL           DLAMC3
*     ..
*     .. EXECUTABLE STATEMENTS ..
*
      A = START
      ONE = 1
      RBASE = ONE / BASE
      ZERO = 0
      EMIN = 1
      B1 = DLAMC3( A*RBASE, ZERO )
      C1 = A
      C2 = A
      D1 = A
      D2 = A
*+    WHILE( ( C1.EQ.A ).AND.( C2.EQ.A ).AND.
*    $       ( D1.EQ.A ).AND.( D2.EQ.A )      )LOOP
   10 CONTINUE
      IF( ( C1.EQ.A ) .AND. ( C2.EQ.A ) .AND. ( D1.EQ.A ) .AND.
     $    ( D2.EQ.A ) ) THEN
         EMIN = EMIN - 1
         A = B1
         B1 = DLAMC3( A / BASE, ZERO )
         C1 = DLAMC3( B1*BASE, ZERO )
         D1 = ZERO
         DO 20 I = 1, BASE
            D1 = D1 + B1
   20    CONTINUE
         B2 = DLAMC3( A*RBASE, ZERO )
         C2 = DLAMC3( B2 / RBASE, ZERO )
         D2 = ZERO
         DO 30 I = 1, BASE
            D2 = D2 + B2
   30    CONTINUE
         GO TO 10
      END IF
*+    END WHILE
*
      RETURN
*
*     END OF DLAMC4
*
      END
*
************************************************************************
*
      SUBROUTINE DLAMC5( BETA, P, EMIN, IEEE, EMAX, RMAX )
*
*  -- LAPACK AUXILIARY ROUTINE (VERSION 2.0) --
*     UNIV. OF TENNESSEE, UNIV. OF CALIFORNIA BERKELEY, NAG LTD.,
*     COURANT INSTITUTE, ARGONNE NATIONAL LAB, AND RICE UNIVERSITY
*     OCTOBER 31, 1992
*
*     .. SCALAR ARGUMENTS ..
      LOGICAL            IEEE
      INTEGER            BETA, EMAX, EMIN, P
      DOUBLE PRECISION   RMAX
*     ..
*
*  PURPOSE
*  =======
*
*  DLAMC5 ATTEMPTS TO COMPUTE RMAX, THE LARGEST MACHINE FLOATING-POINT
*  NUMBER, WITHOUT OVERFLOW.  IT ASSUMES THAT EMAX + ABS(EMIN) SUM
*  APPROXIMATELY TO A POWER OF 2.  IT WILL FAIL ON MACHINES WHERE THIS
*  ASSUMPTION DOES NOT HOLD, FOR EXAMPLE, THE CYBER 205 (EMIN = -28625,
*  EMAX = 28718).  IT WILL ALSO FAIL IF THE VALUE SUPPLIED FOR EMIN IS
*  TOO LARGE (I.E. TOO CLOSE TO ZERO), PROBABLY WITH OVERFLOW.
*
*  ARGUMENTS
*  =========
*
*  BETA    (INPUT) INTEGER
*          THE BASE OF FLOATING-POINT ARITHMETIC.
*
*  P       (INPUT) INTEGER
*          THE NUMBER OF BASE BETA DIGITS IN THE MANTISSA OF A
*          FLOATING-POINT VALUE.
*
*  EMIN    (INPUT) INTEGER
*          THE MINIMUM EXPONENT BEFORE (GRADUAL) UNDERFLOW.
*
*  IEEE    (INPUT) LOGICAL
*          A LOGICAL FLAG SPECIFYING WHETHER OR NOT THE ARITHMETIC
*          SYSTEM IS THOUGHT TO COMPLY WITH THE IEEE STANDARD.
*
*  EMAX    (OUTPUT) INTEGER
*          THE LARGEST EXPONENT BEFORE OVERFLOW
*
*  RMAX    (OUTPUT) DOUBLE PRECISION
*          THE LARGEST MACHINE FLOATING-POINT NUMBER.
*
* =====================================================================
*
*     .. PARAMETERS ..
      DOUBLE PRECISION   ZERO, ONE
      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0 )
*     ..
*     .. LOCAL SCALARS ..
      INTEGER            EXBITS, EXPSUM, I, LEXP, NBITS, TRY, UEXP
      DOUBLE PRECISION   OLDY, RECBAS, Y, Z
*     ..
*     .. EXTERNAL FUNCTIONS ..
      DOUBLE PRECISION   DLAMC3
      EXTERNAL           DLAMC3
*     ..
*     .. INTRINSIC FUNCTIONS ..
      INTRINSIC          MOD
*     ..
*     .. EXECUTABLE STATEMENTS ..
*
*     FIRST COMPUTE LEXP AND UEXP, TWO POWERS OF 2 THAT BOUND
*     ABS(EMIN). WE THEN ASSUME THAT EMAX + ABS(EMIN) WILL SUM
*     APPROXIMATELY TO THE BOUND THAT IS CLOSEST TO ABS(EMIN).
*     (EMAX IS THE EXPONENT OF THE REQUIRED NUMBER RMAX).
*
      LEXP = 1
      EXBITS = 1
   10 CONTINUE
      TRY = LEXP*2
      IF( TRY.LE.( -EMIN ) ) THEN
         LEXP = TRY
         EXBITS = EXBITS + 1
         GO TO 10
      END IF
      IF( LEXP.EQ.-EMIN ) THEN
         UEXP = LEXP
      ELSE
         UEXP = TRY
         EXBITS = EXBITS + 1
      END IF
*
*     NOW -LEXP IS LESS THAN OR EQUAL TO EMIN, AND -UEXP IS GREATER
*     THAN OR EQUAL TO EMIN. EXBITS IS THE NUMBER OF BITS NEEDED TO
*     STORE THE EXPONENT.
*
      IF( ( UEXP+EMIN ).GT.( -LEXP-EMIN ) ) THEN
         EXPSUM = 2*LEXP
      ELSE
         EXPSUM = 2*UEXP
      END IF
*
*     EXPSUM IS THE EXPONENT RANGE, APPROXIMATELY EQUAL TO
*     EMAX - EMIN + 1 .
*
      EMAX = EXPSUM + EMIN - 1
      NBITS = 1 + EXBITS + P
*
*     NBITS IS THE TOTAL NUMBER OF BITS NEEDED TO STORE A
*     FLOATING-POINT NUMBER.
*
      IF( ( MOD( NBITS, 2 ).EQ.1 ) .AND. ( BETA.EQ.2 ) ) THEN
*
*        EITHER THERE ARE AN ODD NUMBER OF BITS USED TO STORE A
*        FLOATING-POINT NUMBER, WHICH IS UNLIKELY, OR SOME BITS ARE
*        NOT USED IN THE REPRESENTATION OF NUMBERS, WHICH IS POSSIBLE,
*        (E.G. CRAY MACHINES) OR THE MANTISSA HAS AN IMPLICIT BIT,
*        (E.G. IEEE MACHINES, DEC VAX MACHINES), WHICH IS PERHAPS THE
*        MOST LIKELY. WE HAVE TO ASSUME THE LAST ALTERNATIVE.
*        IF THIS IS TRUE, THEN WE NEED TO REDUCE EMAX BY ONE BECAUSE
*        THERE MUST BE SOME WAY OF REPRESENTING ZERO IN AN IMPLICIT-BIT
*        SYSTEM. ON MACHINES LIKE CRAY, WE ARE REDUCING EMAX BY ONE
*        UNNECESSARILY.
*
         EMAX = EMAX - 1
      END IF
*
      IF( IEEE ) THEN
*
*        ASSUME WE ARE ON AN IEEE MACHINE WHICH RESERVES ONE EXPONENT
*        FOR INFINITY AND NAN.
*
         EMAX = EMAX - 1
      END IF
*
*     NOW CREATE RMAX, THE LARGEST MACHINE NUMBER, WHICH SHOULD
*     BE EQUAL TO (1.0 - BETA**(-P)) * BETA**EMAX .
*
*     FIRST COMPUTE 1.0 - BETA**(-P), BEING CAREFUL THAT THE
*     RESULT IS LESS THAN 1.0 .
*
      RECBAS = ONE / BETA
      Z = BETA - ONE
      Y = ZERO
      DO 20 I = 1, P
         Z = Z*RECBAS
         IF( Y.LT.ONE )
     $      OLDY = Y
         Y = DLAMC3( Y, Z )
   20 CONTINUE
      IF( Y.GE.ONE )
     $   Y = OLDY
*
*     NOW MULTIPLY BY BETA**EMAX TO GET RMAX.
*
      DO 30 I = 1, EMAX
         Y = DLAMC3( Y*BETA, ZERO )
   30 CONTINUE
*
      RMAX = Y
      RETURN
*
*     END OF DLAMC5
*
      END
