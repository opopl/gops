!  GMIN: A PROGRAM FOR FINDING GLOBAL MINIMA
!  COPYRIGHT (C) 1999-2006 DAVID J. WALES
!  THIS FILE IS PART OF GMIN.
!
!  GMIN IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
!  IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
!  THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
!  (AT YOUR OPTION) ANY LATER VERSION.
!
!  GMIN IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
!  BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
!  MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
!  GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
!
!  YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
!  ALONG WITH THIS PROGRAM; IF NOT, WRITE TO THE FREE SOFTWARE
!  FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330, BOSTON, MA  02111-1307  USA
!
! OBJECTIVE - TO SYMMETRISE A SET OF INPUT COORDINATES.
!
SUBROUTINE SYMMETRY2(JP,SCREENC,QDONE,BRUN,ITERATIONS,TIME,CHANGEDE,NSYMCALL)
USE COMMONS
USE PORFUNCS
IMPLICIT NONE
DOUBLE PRECISION :: LCOORDS(3*NATOMS), CMDIST(NATOMS), ORBDIST(NATOMS), T0
DOUBLE PRECISION :: EBEST, QBEST(3*NATOMS), VATBEST(NATOMS)
DOUBLE PRECISION :: CMX(2), CMY(2), CMZ(2), CM(3), CMSAVE(3), COREVT(NATOMS), OTHERVT(NATOMS)
DOUBLE PRECISION :: DUMMY, XMASS, YMASS, ZMASS
DOUBLE PRECISION :: ORIGIN(3)
DOUBLE PRECISION :: TIME, LTOLD
INTEGER :: J1, J2, NDUMMY, I, NORBIT, J, ISTART, LARGESIZE, MYUNIT2, MYUNIT3, HPTGRPSAVE
INTEGER :: JP, NATOMSCORE, NORBITSCORE
INTEGER :: NFLOAT
INTEGER :: NINDEX(NATOMS), ORBSIZE(NATOMS)
DOUBLE PRECISION :: SCOORDS(3*NATOMS)
! DOUBLE PRECISION :: ORBSORT(3*NATOMS), LCOORDSSORTED(3*NATOMS), RCOORDSSORTED(3*NATOMS)
DOUBLE PRECISION :: CORECOORDS(3*NATOMS), OTHERCOORDS(3*NATOMS)
DOUBLE PRECISION :: DENOM
LOGICAL :: CHANGEDE, LDEBUG
DOUBLE PRECISION :: POTEL, SCREENC(3*NATOMS), GENMAT(100,3,3), GENMATSAVE(100,3,3), X(3*NATOMS)
DOUBLE PRECISION :: DUMMYE, DUMMYGRAD(3*NATOMS)
INTEGER :: NCORESAVE
INTEGER :: NQTOT, QDONE, BRUN, ITERATIONS, NQTOTSAVE, IGEN, IGENSAVE, ORBSYM
INTEGER :: IPRNT
INTEGER :: NSYMCALL
CHARACTER(LEN=4) FPGRP, POINTGROUP
CHARACTER(LEN=6) JPSTRING
DOUBLE PRECISION, PARAMETER :: EPS=1.0D-10
COMMON /MYPOT/ POTEL
COMMON /TOT/ NQTOT
SAVE NORBIT

! DO J1=1,NPAR
  ! WRITE(MYUNIT,*) 'SYMMETRY2> J1,SHELLMOVES,PTGROUP',J1,SHELLMOVES(J1),PTGROUP(J1)
! ENDDO
NCORESAVE=NCORE(JP)
WRITE(JPSTRING,'(I6)') JP
MYUNIT2=NPAR+MYUNIT
MYUNIT3=2*NPAR+MYUNIT+1
IPRNT=0
LDEBUG=DEBUG
NSYMCALL=NSYMCALL+1   ! NSYMCALL SHOULD BE THE NUMBER OF CONSECUTIVE CALLS TO SYMMETRY WITH THIS MINIMUM
IF (NSYMCALL.GT.2) THEN
   IF (LDEBUG) WRITE(MYUNIT, '(A)') 'SYMMETRY2> MAXIMUM CONSECUTIVE CALLS TO SYMMETRY REACHED FOR THIS MINIMUM'
   WRITE(MYUNIT, '(A)') 'SYMMETRY2> MAXIMUM CONSECUTIVE CALLS TO SYMMETRY REACHED FOR THIS MINIMUM'
   RETURN 
ENDIF
NSYMREM=0
CHANGEDE=.FALSE.
IF (LDEBUG) IPRNT=11
CALL MYCPU_TIME(T0)
EBEST=EPREV(JP)
QBEST(1:3*NATOMS)=COORDS(1:3*NATOMS,JP)
VATBEST(1:NATOMS)=VAT(1:NATOMS,JP)
NQTOTSAVE=NQTOT
LCOORDS(1:3*NATOMS)=COORDS(1:3*NATOMS,JP)

!   DO J2=1,3*NATOMS
!      X(J2)=COORDS(J2,JP)
!   ENDDO
!   CALL POTENTIAL(X,DUMMYGRAD,DUMMYE,.FALSE.,.FALSE.)
!   DO J2=1,NATOMS
!      IF (VT(J2).NE.0.0D0) THEN
!         IF (ABS((VT(J2)-VAT(J2,JP))/VT(J2)).GT.0.01D0) THEN
!            WRITE(MYUNIT,'(A,I8,2F15.5)') 'SYMMETRY2> A J2,VAT,VT(J2)=',J2,VAT(J2,JP),VT(J2)
!            STOP
!         ENDIF
!      ENDIF
!   ENDDO


LTOLD=SYMTOL2
ORIGIN(1:3)=1.0D0
CMLOOP: DO J1=1,200
   XMASS=0.0D0; YMASS=0.0D0; ZMASS=0.0D0
   DENOM=0.0D0
   DO I=1,NATOMS
      IF (J1.GT.1) THEN
         DUMMY=EXP(-DISTFAC*CMDIST(I))
      ELSE
         DUMMY=1.0D0
      ENDIF
      XMASS=XMASS+LCOORDS(3*(I-1)+1)*DUMMY
      YMASS=YMASS+LCOORDS(3*(I-1)+2)*DUMMY
      ZMASS=ZMASS+LCOORDS(3*(I-1)+3)*DUMMY
      DENOM=DENOM+DUMMY
   ENDDO
   DUMMY=SQRT( (ORIGIN(1)-XMASS/DENOM)**2+(ORIGIN(2)-YMASS/DENOM)**2+(ORIGIN(3)-ZMASS/DENOM)**2)
   ORIGIN(1)=XMASS/DENOM;  ORIGIN(2)=YMASS/DENOM; ORIGIN(3)=ZMASS/DENOM
   DO J=1,NATOMS
      CMDIST(J)=SQRT((LCOORDS(3*(J-1)+1)-ORIGIN(1))**2+ &
                     (LCOORDS(3*(J-1)+2)-ORIGIN(2))**2+ &
                     (LCOORDS(3*(J-1)+3)-ORIGIN(3))**2)
   ENDDO
   IF (LDEBUG) WRITE(MYUNIT, '(A,I5,3G20.10)') 'SYMMETRY2> CYCLE, ORIGIN:',J1,ORIGIN(1:3)
   IF ((J1.GT.1).AND.(DUMMY.LT.1.0D-4)) EXIT CMLOOP 
ENDDO CMLOOP

DO J=1,NATOMS
   NINDEX(J)=J
ENDDO

IF (LDEBUG) WRITE(MYUNIT, '(A,3F15.5)') 'SYMMETRY2> INITIAL CENTRE OF MASS: ',ORIGIN(1:3)
SCOORDS(1:3*NATOMS)=LCOORDS(1:3*NATOMS)
CALL PIKSR2(NATOMS,CMDIST,NINDEX) ! SORTS CMDIST AND NINDEX
! CALL GETORBITS(NORBIT,ORBDIST,CMDIST,NATOMS,ORBSIZE,SYMTOL1,LARGESIZE,NINDEX,LCOORDS,LDEBUG)
! FIND THE LARGEST GAP BETWEEN CM DISTANCES AND USE THE CENTRE-OF-MASS OF ALL THE ATOMS UP TO THAT POINT
CMX(1)=0.0D0; CMY(1)=0.0D0; CMZ(1)=0.0D0
CMX(2)=LCOORDS(3*(NINDEX(1)-1)+1); CMY(2)=LCOORDS(3*(NINDEX(1)-1)+2); CMZ(2)=LCOORDS(3*(NINDEX(1)-1)+3)
! STORE SUM OF CENTRES OF MASS FROM PREVIOUS LARGEST GAP TO CURRENT IN CMX(2).
GMAX=-1.0D0
DO J=2,NATOMS
   IF (ABS(CMDIST(J)-CMDIST(J-1)).GT.GMAX) THEN
      GMAX=ABS(CMDIST(J)-CMDIST(J-1))
      NDUMMY=J-1
      CMX(1)=CMX(1)+CMX(2); CMY(1)=CMY(1)+CMY(2); CMZ(1)=CMZ(1)+CMZ(2)
      CMX(2)=LCOORDS(3*(NINDEX(J)-1)+1); CMY(2)=LCOORDS(3*(NINDEX(J)-1)+2); CMZ(2)=LCOORDS(3*(NINDEX(J)-1)+3)
   ELSE
      CMX(2)=CMX(2)+LCOORDS(3*(NINDEX(J)-1)+1); CMY(2)=CMY(2)+LCOORDS(3*(NINDEX(J)-1)+2); CMZ(2)=CMZ(2)+LCOORDS(3*(NINDEX(J)-1)+3)
   ENDIF
ENDDO
CMX(1)=CMX(1)/NDUMMY; CMY(1)=CMY(1)/NDUMMY; CMZ(1)=CMZ(1)/NDUMMY

IF (LDEBUG) WRITE(MYUNIT, '(A,3F15.5)') 'SYMMETRY2> ORIGIN WILL BE MOVED TO CENTRE OF MASS FOR ATOMS UP TO BIGGEST GAP: ', &
  &                           CMX(1),CMY(1),CMZ(1)
IF (LDEBUG) WRITE(MYUNIT, '(A,I6,A,F15.5,A)') 'SYMMETRY2> NUMBER OF ATOMS=',NDUMMY
ORBSIZE(1)=NDUMMY
IF (LDEBUG) WRITE(MYUNIT, '(12I5)')  (NINDEX(J1),J1=1,ORBSIZE(1))
ORIGIN(1)=CMX(1)
ORIGIN(2)=CMY(1)
ORIGIN(3)=CMZ(1)
DO J=1,NATOMS
   NINDEX(J)=J
   LCOORDS(3*(J-1)+1)=LCOORDS(3*(J-1)+1)-ORIGIN(1)
   LCOORDS(3*(J-1)+2)=LCOORDS(3*(J-1)+2)-ORIGIN(2)
   LCOORDS(3*(J-1)+3)=LCOORDS(3*(J-1)+3)-ORIGIN(3)
   CMDIST(J)=SQRT(LCOORDS(3*(J-1)+1)**2+LCOORDS(3*(J-1)+2)**2+LCOORDS(3*(J-1)+3)**2)
ENDDO
CALL PIKSR2(NATOMS,CMDIST,NINDEX) ! SORTS CMDIST AND NINDEX AGAIN
CALL GETORBITS(NORBIT,ORBDIST,CMDIST,NATOMS,ORBSIZE,SYMTOL1,LARGESIZE,NINDEX,LCOORDS,LDEBUG)
IF (LDEBUG) THEN
   ISTART=1
   OPEN(UNIT=MYUNIT2,FILE='ORBITS.'//TRIM(ADJUSTL(JPSTRING)) // '.XYZ',STATUS='UNKNOWN')
   DO J1=1,NORBIT
      WRITE(MYUNIT2,'(I5)') SUM(ORBSIZE(1:J1))
      WRITE(MYUNIT2,'(A)') ' '
      DO J2=ISTART,ISTART+ORBSIZE(J1)-1
         WRITE(MYUNIT2,'(A2,2X,3G20.10)') 'LA',LCOORDS(3*(NINDEX(J2)-1)+1:3*(NINDEX(J2)-1)+3)
      ENDDO
      DO J2=1,ISTART-1
         WRITE(MYUNIT2,'(A2,2X,3G20.10)') 'LB',LCOORDS(3*(NINDEX(J2)-1)+1:3*(NINDEX(J2)-1)+3)
      ENDDO
      ISTART=ISTART+ORBSIZE(J1)
   ENDDO
   CLOSE(MYUNIT2)
ENDIF

IF (LARGESIZE.EQ.1) THEN
   IF (LDEBUG) THEN
      CALL MYCPU_TIME(TIME)
      WRITE(MYUNIT, '(A,F15.2)') 'SYMMETRY2> NO NONTRIVIAL ORBITS - RETURN FROM SYMMETRY2, TIME TAKEN=',TIME-T0
   ENDIF
   RETURN
ENDIF

! EXAMINE HOW THE POINT GROUP CHANGES AS WE INCLUDE MORE ORBITS.
 
ISTART=1
NATOMSCORE=0
NORBITSCORE=0
IGENSAVE=0
HPTGRPSAVE=0
SYMCORE: DO J1=1,NORBIT
   DO J2=ISTART,ISTART+ORBSIZE(J1)-1
      CORECOORDS(3*(J2-1)+1:3*(J2-1)+3)=LCOORDS(3*(NINDEX(J2)-1)+1:3*(NINDEX(J2)-1)+3)
   ENDDO
   ISTART=ISTART+ORBSIZE(J1)
   NATOMSCORE=NATOMSCORE+ORBSIZE(J1)
   SCOORDS(1:3*NATOMSCORE)=CORECOORDS(1:3*NATOMSCORE) 
   IF (NATOMSCORE.GT.3) THEN
      DUMMY=MATDIFF
      CALL PTGRP(SCOORDS,NATOMSCORE,LDEBUG,SYMTOL1,SYMTOL2,SYMTOL3,GENMAT,IGEN,FPGRP,CM,DUMMY) ! SCOORDS IS CHANGED!
      IF (LDEBUG) WRITE(MYUNIT, '(A,I5,A,I5,A,I4,A,A4,A,I6)') 'SYMMETRY2> NUMBER OF ORBITS=',J1,' NUMBER OF ATOMS=',NATOMSCORE, &
                          ' NUMBER OF GENERATORS=',IGEN,' POINT GROUP= ',FPGRP,' ORDER=',HPTGRP
      IF (HPTGRP.GE.HPTGRPSAVE) THEN
         HPTGRPSAVE=HPTGRP
         ORBSYM=J1
         CMSAVE(1:3)=CM(1:3)
         NCORE(JP)=NATOMSCORE
         NORBITSCORE=J1
         IGENSAVE=IGEN
         POINTGROUP=FPGRP
         GENMATSAVE(1:IGEN,1:3,1:3)=GENMAT(1:IGEN,1:3,1:3)
         IF ((HPTGRP.EQ.1).AND.(NCORE(JP).GE.20)) THEN
            NCORE(JP)=0
            EXIT SYMCORE ! LOOKS LIKE THERE IS NO SYMMETRY
         ENDIF
      ELSEIF (HPTGRP.GE.1) THEN ! SYMMETRY HAS DECREASED
         IF (NPAR.GT.1) THEN
            WRITE(MYUNIT,'(A,I1,3A,I6,A,I6,A)') '[',JP,']SYMMETRY2> HIGHEST SYMMETRY ',POINTGROUP,' FOR ',NORBITSCORE, &
  &                        ' ORBITS AND ',NCORE(JP),' ATOMS'
         ELSE
            WRITE(MYUNIT,'(3A,I6,A,I6,A)') 'SYMMETRY2> HIGHEST SYMMETRY ',POINTGROUP,' FOR ',NORBITSCORE, &
  &                        ' ORBITS AND ',NCORE(JP),' ATOMS'
         ENDIF
         EXIT SYMCORE
      ENDIF
   ELSE
      IF (LDEBUG) WRITE(MYUNIT, '(A,I5,A,I5)') 'SYMMETRY2> NUMBER OF ORBITS=',NORBITSCORE,' NUMBER OF ATOMS=',NATOMSCORE
   ENDIF
ENDDO SYMCORE

IF (HPTGRPSAVE.EQ.1) THEN
   IF (LDEBUG) WRITE(MYUNIT, '(A)') 'SYMMETRY2> NO SYMMETRY DETECTED'
   NCORE(JP)=NCORESAVE
   RETURN
ELSE
   IF (NCORE(JP).EQ.NATOMS) THEN
      RETURN
   ENDIF
!  WRITE(MYUNIT, '(A,A,A,I4)') 'SYMMETRY2> SYMMETRY ANALYSIS FOR POINT GROUP ',TRIM(ADJUSTL(POINTGROUP)), &
!   &                   ' NUMBER OF GENERATORS=',IGENSAVE
ENDIF

! MOVE THE CORECOORDS CENTRE OF MASS TO THE ORIGIN.

DO J1=1,NATOMS
   LCOORDS(3*(J1-1)+1)=LCOORDS(3*(J1-1)+1)-CMSAVE(1)
   LCOORDS(3*(J1-1)+2)=LCOORDS(3*(J1-1)+2)-CMSAVE(2)
   LCOORDS(3*(J1-1)+3)=LCOORDS(3*(J1-1)+3)-CMSAVE(3)
ENDDO
DO J1=1,NCORE(JP)
   CORECOORDS(3*(J1-1)+1)=CORECOORDS(3*(J1-1)+1)-CMSAVE(1)
   CORECOORDS(3*(J1-1)+2)=CORECOORDS(3*(J1-1)+2)-CMSAVE(2)
   CORECOORDS(3*(J1-1)+3)=CORECOORDS(3*(J1-1)+3)-CMSAVE(3)
ENDDO

! MOVE COORDINATES INTO CORE AND OTHER VECTORS. DEFINE NCORE(JP), THE NUMBER OF CORE ATOMS.

ISTART=1
DO J1=1,NORBITSCORE
   DO J2=ISTART,ISTART+ORBSIZE(J1)-1
      CORECOORDS(3*(J2-1)+1:3*(J2-1)+3)=LCOORDS(3*(NINDEX(J2)-1)+1:3*(NINDEX(J2)-1)+3)
      COREVT(J2)=VAT(NINDEX(J2),JP)
   ENDDO
   ISTART=ISTART+ORBSIZE(J1)
ENDDO
NCORE(JP)=ISTART-1
DO J1=NORBITSCORE+1,NORBIT
   DO J2=ISTART,ISTART+ORBSIZE(J1)-1
      OTHERCOORDS(3*(J2-NCORE(JP)-1)+1:3*(J2-NCORE(JP)-1)+3)=LCOORDS(3*(NINDEX(J2)-1)+1:3*(NINDEX(J2)-1)+3)
      OTHERVT(J2-NCORE(JP))=VAT(NINDEX(J2),JP)
   ENDDO
   ISTART=ISTART+ORBSIZE(J1)
ENDDO

NFLOAT=NATOMS-NCORE(JP)

IF (LDEBUG) THEN
   OPEN(MYUNIT2,FILE='COREPLUSOTHER.' // TRIM(ADJUSTL(JPSTRING)) // '.XYZ',STATUS='UNKNOWN')
   WRITE(MYUNIT2,*) NATOMS
   WRITE(MYUNIT2,'(A)') ' '
   IF (NCORE(JP).GT.0) WRITE(MYUNIT2,'(A2,3X,3F20.10)') ('LA',CORECOORDS(3*(J2-1)+1:3*(J2-1)+3),J2=1,NCORE(JP))
   DO J1=1,NFLOAT
      WRITE(MYUNIT2,'(A2,3X,3F20.10)') 'LB',OTHERCOORDS(3*(J1-1)+1:3*(J1-1)+3)
      NDUMMY=NDUMMY+1
   ENDDO
   CLOSE(MYUNIT2)
ENDIF
IF (NCORE(JP).EQ.NATOMS) RETURN
! IF (LDEBUG) WRITE(MYUNIT,'(A,3I8)') 'SYMMETRY2> NCORE(JP),NCORESAVE,NFLOAT=',NCORE(JP),NCORESAVE,NFLOAT
IF (NCORE(JP).LE.NCORESAVE) THEN
   NCORE(JP)=NCORESAVE
   RETURN
ENDIF

DO J1=1,NPAR
   IF (J1.EQ.JP) CYCLE
!  WRITE(MYUNIT,*) 'SYMMETRY2> J1,SHELLMOVES,PTGROUP,POINTGROUP=',J1,SHELLMOVES(J1),PTGROUP(J1),POINTGROUP
   IF (.NOT.SHELLMOVES(J1)) CYCLE
   IF (POINTGROUP.EQ.PTGROUP(J1)) THEN
      IF (NPAR.GT.1) THEN
         WRITE(MYUNIT,'(A,I1,3A,I6)') '[',JP,']SYMMETRY2> POINT GROUP ',POINTGROUP,' COINCIDES WITH RUN ',J1
      ELSE
         WRITE(MYUNIT,'(3A,I6)') 'SYMMETRY2> POINT GROUP ',POINTGROUP,' COINCIDES WITH RUN ',J1
      ENDIF
      NCORE(JP)=0
      NSURFMOVES(JP)=0
      SHELLMOVES(JP)=.FALSE. ! IN CASE THIS WAS TRUE AND THE SYMMETRY HAS JUST INCREASED TO THAT OF ANOTHER RUN
      RETURN
   ENDIF
ENDDO
NSURFMOVES(JP)=0
SHELLMOVES(JP)=.TRUE.
PTGROUP(JP)=POINTGROUP

COORDS(3*NFLOAT+1:3*NATOMS,JP)=CORECOORDS(1:3*NCORE(JP))
VAT(NFLOAT+1:NATOMS,JP)=COREVT(1:NCORE(JP))
DO J1=1,NFLOAT
   COORDS(3*(J1-1)+1:3*(J1-1)+3,JP)=OTHERCOORDS(3*(J1-1)+1:3*(J1-1)+3)
ENDDO
VAT(1:NFLOAT,JP)=OTHERVT(1:NFLOAT)

IF (NPAR.GT.1) THEN
   WRITE(MYUNIT,'(A,I1,A,I8,A,I8,3A,I8,A)') '[',JP,']SYMMETRY2> STARTING A BLOCK OF ',SHELLMOVEMAX,' MOVES WITH ', &
  &      NCORE(JP),' ATOMS UNPERTURBED, CORE SYMMETRY ',POINTGROUP,' AFTER ',NQ(JP),' QUENCHES'
ELSE
   WRITE(MYUNIT,'(A,I8,A,I8,3A,I8,A)') 'SYMMETRY2> STARTING A BLOCK OF ',SHELLMOVEMAX,' MOVES WITH ', &
  &      NCORE(JP),' ATOMS UNPERTURBED, CORE SYMMETRY ',POINTGROUP,' AFTER ',NQ(JP),' QUENCHES'
ENDIF
IF (DEBUG) THEN ! CHECK FOR OVERLAPS
   DO J1=1,NATOMS ! CHECK OVERLAPS WITH CURRENT ORBIT
      DO J2=J1+1,NATOMS 
         DUMMY=SQRT((COORDS(3*(J1-1)+1,JP)-COORDS(3*(J2-1)+1,JP))**2 &
                   +(COORDS(3*(J1-1)+2,JP)-COORDS(3*(J2-1)+2,JP))**2 &
                   +(COORDS(3*(J1-1)+3,JP)-COORDS(3*(J2-1)+3,JP))**2)
         IF (DUMMY.LT.SYMTOL5) THEN
            WRITE(MYUNIT,'(A,I8,A,I8,A,G20.10)') 'SYMMETRY2> ERROR - ATOMS ',J1,' AND ',J2,' ARE SEPARATED BY ONLY ',DUMMY
      WRITE(41,'(I4)') NATOMS
      WRITE(41,*) ' ' 
      WRITE(41,'(A2,3F20.10)') ('LA ',COORDS(3*(I-1)+1,JP),COORDS(3*(I-1)+2,JP),COORDS(3*(I-1)+3,JP),I=1,NCORE(JP))
      WRITE(41,'(A2,3F20.10)') ('LB',COORDS(3*(I-1)+1,JP),COORDS(3*(I-1)+2,JP),COORDS(3*(I-1)+3,JP),I=NCORE(JP)+1,NATOMS)
            STOP
         ENDIF
      ENDDO
   ENDDO
ENDIF

!   DO J2=1,3*NATOMS
!      X(J2)=COORDS(J2,JP)
!   ENDDO
!   CALL POTENTIAL(X,DUMMYGRAD,DUMMYE,.FALSE.,.FALSE.)
!   DO J2=1,NATOMS
!      IF (VT(J2).NE.0.0D0) THEN
!         IF (ABS((VT(J2)-VAT(J2,JP))/VT(J2)).GT.0.01D0) THEN
!            WRITE(MYUNIT,'(A,I8,2F15.5)') 'SYMMETRY2> A J2,VAT,VT(J2)=',J2,VAT(J2,JP),VT(J2)
!            STOP
!         ENDIF
!      ENDIF
!   ENDDO

!           WRITE(77,'(I4)') NATOMS
!           WRITE(77,*) 'COORDS AT THE END OF SYMMETRY2'
!           WRITE(77,'(A2,3F20.10)') ('LB',X(3*(I-1)+1),X(3*(I-1)+2),X(3*(I-1)+3),I=1,NATOMS-NCORE(JP))
!           WRITE(77,'(A2,3F20.10)') ('LA ',X(3*(I-1)+1),X(3*(I-1)+2),X(3*(I-1)+3),I=NATOMS-NCORE(JP)+1,NATOMS)

RETURN

END SUBROUTINE SYMMETRY2
