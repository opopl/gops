C   GMIN: A PROGRAM FOR FINDING GLOBAL MINIMA
C   COPYRIGHT (C) 1999-2006 DAVID J. WALES
C   THIS FILE IS PART OF GMIN.
C
C   GMIN IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C   IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C   THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C   (AT YOUR OPTION) ANY LATER VERSION.
C
C   GMIN IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
C   BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
C   GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C   YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C   ALONG WITH THIS PROGRAM; IF NOT, WRITE TO THE FREE SOFTWARE
C   FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330, BOSTON, MA  02111-1307  USA
C
      SUBROUTINE ODESD(ITMAX,VARS,MFLAG,NSTP,ENERGY,NP)
      USE COMMONS
      USE ODESDSAVEAR
      IMPLICIT NONE
      INTEGER I, NOK, NBAD, NSTP, ITMAX, NOPT, NP
      LOGICAL MFLAG
      DOUBLE PRECISION VARS(3*NATOMS), YSCAL(3*NATOMS), ENERGY, MXSTP, STRY,
     1                 DYDX(3*NATOMS), STRYDID, EPS, STRYNEXT, DUMMY
      DOUBLE PRECISION TINY, STRYMIN, SLENGTH
      PARAMETER (TINY=1.D-30)
      COMMON /BSNEW/ SLENGTH,NOK,NBAD,EPS

      STRYMIN=0.0D0
      NOPT=3*NATOMS
      MXSTP=0.00001D0
      STRY=MXSTP
      NSTP=1
10    CALL POTENTIAL(VARS,DYDX,ENERGY,.TRUE.,.FALSE.)

      FIXIMAGE=.TRUE.

      IF (RMS.LT.GMAX) THEN
         MFLAG=.TRUE.
         IF (MFLAG) THEN
            FIXIMAGE=.FALSE.
            RETURN
         ENDIF
      ENDIF

      IF (NSTP.EQ.ITMAX) THEN
         MFLAG=.FALSE.
         FIXIMAGE=.FALSE.
         RETURN
      ENDIF

      DUMMY=RMS*SQRT(1.0D0*NOPT)
      DO I=1,NOPT
         YSCAL(I)=ABS(VARS(I))+ABS(STRY*DYDX(I))+TINY
         DYDX(I)=-DYDX(I)/MAX(DUMMY,1.0D0)
C        DYDX(I)=-DYDX(I)
      ENDDO

      IF (BSMIN) CALL BSSTEP(VARS,DYDX,SLENGTH,STRY,EPS,YSCAL,STRYDID,STRYNEXT,ENERGY,NOPT)
      IF (RKMIN) CALL RKQS(VARS,DYDX,SLENGTH,STRY,EPS,YSCAL,STRYDID,STRYNEXT,ENERGY,NOPT)

      WRITE(*,'(A,G20.10,A,G20.10)') 'STEP LENGTH=',STRYDID,' NEXT ESTIMATED STEP SIZE=',STRYNEXT

      IF (STRYDID.EQ.STRY) THEN
         NOK=NOK+1
      ELSE
         NBAD=NBAD+1
      ENDIF
      PRINT '(A,4I8)','STRYDID,STRY,NOK,NBAD=',STRYDID,STRY,NOK,NBAD
      IF (ABS(STRYNEXT).LT.STRYMIN) THEN
         PRINT*, ' WARNING, STEPSIZE < 0 IN ODESD'
         OPEN(UNIT=96,FILE='DISCONN',STATUS='UNKNOWN')
         PRINT*,' INTRACTABLE DISCONTINUITY IN MAIN - QUIT '
         WRITE(96,'(A)') 'INTRACTABLE DISCONTINUITY'
         CLOSE(96)
         WRITE(*,'(A,2F20.10,A,I6,A,F15.10)') ' ENERGY AND RMS FORCE=',ENERGY,RMS
         STOP
      ENDIF
      IF (DEBUG) WRITE(*,'(A,2F20.10,A,I6,A)') ' ENERGY AND RMS FORCE=',ENERGY,RMS,' AFTER ',NSTP,' SD STEPS'

C     STRY=MIN(STRYNEXT,MXSTP)
      STRY=STRYNEXT
      MFLAG=.FALSE.
      FIXIMAGE=.FALSE.
      NSTP=NSTP+1
      GOTO 10

      RETURN
      END

      SUBROUTINE BSSTEP(Y,DYDX,X,HTRY,EPS,YSCAL,HDID,HNEXT,ENERGY,NV)
      USE COMMONS
      USE ODESDSAVEAR
      IMPLICIT NONE
      INTEGER NV,KMAXX,IMAX
      DOUBLE PRECISION EPS,HDID,HNEXT,HTRY,X,DYDX(3*NATOMS),Y(3*NATOMS),YSCAL(3*NATOMS)
     *,SAFE1,SAFE2,
     *REDMAX,REDMIN,TINY,SCALMX
      PARAMETER (KMAXX=8,IMAX=KMAXX+1,SAFE1=.25D0,SAFE2=.7D0,
     *REDMAX=1.D-5,REDMIN=.7D0,TINY=1.D-30,SCALMX=.9D0)
CU    USES DERIVS,MMID,PZEXTR
      INTEGER I,IQ,K,KK,KM,KMAX,KOPT,NSEQ(IMAX)
      DOUBLE PRECISION EPS1,EPSOLD,ERRMAX,FACT,H,RED,SCALE,WORK,WRKMIN
     *,XEST,XNEW,ENERGY,EOLD,VNEW(3*NATOMS),
     *A(IMAX),ALF(KMAXX,KMAXX),ERR(KMAXX),YERR(3*NATOMS),YSAV(3*NATOMS),
     *YSEQ(3*NATOMS)
      LOGICAL FIRST,REDUCT
      SAVE A,ALF,EPSOLD,FIRST,KMAX,KOPT,NSEQ,XNEW
      DATA FIRST/.TRUE./,EPSOLD/-1.D0/
      DATA NSEQ /2,4,6,8,10,12,14,16,18/
      ALLOCATE(QCOL(3*NATOMS,IMAX),D(3*NATOMS,IMAX))

C     PRINT*,'IN BSSTEP, X,EPS,EPSOLD=',X,EPS,EPSOLD
      EOLD=ENERGY
      IF(EPS.NE.EPSOLD)THEN
        HNEXT=-1.D29
        XNEW=-1.D29
        EPS1=SAFE1*EPS
        A(1)=NSEQ(1)+1
        DO 11 K=1,KMAXX
          A(K+1)=A(K)+NSEQ(K+1)
11      CONTINUE
        DO 13 IQ=2,KMAXX
          DO 12 K=1,IQ-1
            ALF(K,IQ)=EPS1**((A(K+1)-A(IQ+1))/((A(IQ+1)-A(1)+1.D0)*(2*K+
     *
     *1)))
12        CONTINUE
13      CONTINUE
        EPSOLD=EPS
        DO 14 KOPT=2,KMAXX-1
          IF(A(KOPT+1).GT.A(KOPT)*ALF(KOPT-1,KOPT))GOTO 1
14      CONTINUE
1       KMAX=KOPT
      ENDIF
      H=HTRY
      DO 15 I=1,NV
        YSAV(I)=Y(I)
15    CONTINUE
      IF(H.NE.HNEXT.OR.X.NE.XNEW)THEN
        FIRST=.TRUE.
        KOPT=KMAX
      ENDIF
      REDUCT=.FALSE.
2     DO 17 K=1,KMAX
        XNEW=X+H
        IF ((XNEW.EQ.X).OR.(EPS.LT.1.0D-20)) THEN
           PRINT*,'STEPSIZE UNDERFLOW IN BSSTEP'
           OPEN(UNIT=96,FILE='DISCONN',STATUS='UNKNOWN')
           PRINT*,' INTRACTABLE DISCONTINUITY IN BSSSTEP - QUIT '
           WRITE(96,'(A)') 'INTRACTABLE DISCONTINUITY'
           CLOSE(96)
!          STOP
        ENDIF
        CALL MMID(YSAV,DYDX,X,H,NSEQ(K),YSEQ,NV)
        XEST=(H/NSEQ(K))**2
        CALL RZEXTR(K,XEST,YSEQ,Y,YERR,NV,NATOMS)
C       CALL PZEXTR(K,XEST,YSEQ,Y,YERR,NV)
        IF(K.NE.1)THEN
          ERRMAX=TINY
          DO 16 I=1,NV
            ERRMAX=MAX(ERRMAX,ABS(YERR(I)/YSCAL(I)))
16        CONTINUE
          ERRMAX=ERRMAX/EPS
          KM=K-1
          ERR(KM)=(ERRMAX/SAFE1)**(1.D0/(2*KM+1))
        ENDIF
        IF(K.NE.1.AND.(K.GE.KOPT-1.OR.FIRST))THEN
          IF (ERRMAX.LT.1.0D0) THEN
             CALL POTENTIAL(Y,VNEW,ENERGY,.FALSE.,.FALSE.)
             IF (ENERGY.GT.EOLD+1.0D-12) THEN
                ERRMAX=2.0D0
                EPS=EPS/2.0D0
                WRITE(*,'(A,4G20.10)') 'Y,ENERGY,EOLD,EPS=',Y(1),ENERGY,EOLD,EPS
             ELSE
C               EPS=EPS*1.1D0
             ENDIF
          ENDIF
          IF(ERRMAX.LT.1.D0)GOTO 4
          IF(K.EQ.KMAX.OR.K.EQ.KOPT+1)THEN
            RED=SAFE2/ERR(KM)
            GOTO 3
          ELSE IF(K.EQ.KOPT)THEN
            IF(ALF(KOPT-1,KOPT).LT.ERR(KM))THEN
              RED=1.D0/ERR(KM)
              GOTO 3
            ENDIF
          ELSE IF(KOPT.EQ.KMAX)THEN
            IF(ALF(KM,KMAX-1).LT.ERR(KM))THEN
              RED=ALF(KM,KMAX-1)*SAFE2/ERR(KM)
              GOTO 3
            ENDIF
          ELSE IF(ALF(KM,KOPT).LT.ERR(KM))THEN
            RED=ALF(KM,KOPT-1)/ERR(KM)
            GOTO 3
          ENDIF
        ENDIF
17    CONTINUE
3     RED=MIN(RED,REDMIN)
      RED=MAX(RED,REDMAX)
      H=H*RED
      REDUCT=.TRUE.
      GOTO 2
4     X=XNEW
      HDID=H
      FIRST=.FALSE.
      WRKMIN=1.D35
      DO 18 KK=1,KM
        FACT=MAX(ERR(KK),SCALMX)
        WORK=FACT*A(KK+1)
        IF(WORK.LT.WRKMIN)THEN
          SCALE=FACT
          WRKMIN=WORK
          KOPT=KK+1
        ENDIF
18    CONTINUE
      HNEXT=H/SCALE
      IF(KOPT.GE.K.AND.KOPT.NE.KMAX.AND..NOT.REDUCT)THEN
        FACT=MAX(SCALE/ALF(KOPT-1,KOPT),SCALMX)
        IF(A(KOPT+1)*FACT.LE.WRKMIN)THEN
          HNEXT=H/FACT
          KOPT=KOPT+1
        ENDIF
      ENDIF
      RETURN
      END

      SUBROUTINE MMID(Y,DYDX,XS,HTOT,NSTEP,YOUT,NOPT)
      USE COMMONS
      IMPLICIT NONE
      INTEGER NSTEP, NOPT
      DOUBLE PRECISION HTOT,XS,DYDX(3*NATOMS),Y(3*NATOMS),YOUT(3*NATOMS),ENERGY
      INTEGER I,N
      DOUBLE PRECISION H,H2,SWAP,X,YM(3*NATOMS),YN(3*NATOMS)

C     PRINT*,'IN MMID'
      H=HTOT/NSTEP
      DO 11 I=1,NOPT
        YM(I)=Y(I)
        YN(I)=Y(I)+H*DYDX(I)
11    CONTINUE
      X=XS+H
      CALL POTENTIAL(YN,YOUT,ENERGY,.TRUE.,.FALSE.)
      RMS=RMS*SQRT(1.0D0*NOPT)
      DO I=1,NOPT
         YOUT(I)=-YOUT(I)/MAX(RMS,1.0D0)
C        YOUT(I)=-YOUT(I)
      ENDDO
      H2=2.D0*H
      DO 13 N=2,NSTEP
        DO 12 I=1,NOPT
          SWAP=YM(I)+H2*YOUT(I)
          YM(I)=YN(I)
          YN(I)=SWAP
12      CONTINUE
        X=X+H
        CALL POTENTIAL(YN,YOUT,ENERGY,.TRUE.,.FALSE.)
        RMS=RMS*SQRT(1.0D0*NOPT)
        DO I=1,NOPT
           YOUT(I)=-YOUT(I)/MAX(RMS,1.0D0)
C          YOUT(I)=-YOUT(I)
        ENDDO
13    CONTINUE
      DO 14 I=1,NOPT
        YOUT(I)=0.5D0*(YM(I)+YN(I)+H*YOUT(I))
14    CONTINUE
      RETURN
      END

      SUBROUTINE PZEXTR(IEST,XEST,YEST,YZ,DY,NV,NATOMS)
      USE ODESDSAVEAR
      IMPLICIT NONE
      INTEGER IEST,NV,IMAX, NATOMS
      DOUBLE PRECISION XEST,DY(NV),YEST(NV),YZ(NV)
      PARAMETER (IMAX=13)
      INTEGER J,K1
      DOUBLE PRECISION DELTA,F1,F2,Q,X(IMAX)
      SAVE X

C     PRINT*,'IN PZEXTR'
      X(IEST)=XEST
      DO 11 J=1,NV
        DY(J)=YEST(J)
        YZ(J)=YEST(J)
11    CONTINUE
      IF(IEST.EQ.1) THEN
        DO 12 J=1,NV
          QCOL(J,1)=YEST(J)
12      CONTINUE
      ELSE
        DO 13 J=1,NV
          D(J,1)=YEST(J)
13      CONTINUE
        DO 15 K1=1,IEST-1
          DELTA=1.D0/(X(IEST-K1)-XEST)
          F1=XEST*DELTA
          F2=X(IEST-K1)*DELTA
          DO 14 J=1,NV
            Q=QCOL(J,K1)
            QCOL(J,K1)=DY(J)
            DELTA=D(J,1)-Q
            DY(J)=F1*DELTA
            D(J,1)=F2*DELTA
            YZ(J)=YZ(J)+DY(J)
14        CONTINUE
15      CONTINUE
        DO 16 J=1,NV
          QCOL(J,IEST)=DY(J)
16      CONTINUE
      ENDIF
      RETURN
      END
      SUBROUTINE RZEXTR(IEST,XEST,YEST,YZ,DY,NV,NATOMS)
      USE ODESDSAVEAR
      IMPLICIT NONE
      INTEGER IEST,NV,IMAX, NATOMS
      DOUBLE PRECISION XEST,DY(NV),YEST(NV),YZ(NV)
      PARAMETER (IMAX=13)
      INTEGER J,K
      DOUBLE PRECISION B,B1,C,DDY,V,YY,FX(IMAX),X(IMAX)
      SAVE X

C     PRINT*,'IN RZEXTR'
      X(IEST)=XEST
      IF(IEST.EQ.1) THEN
        DO 11 J=1,NV
          YZ(J)=YEST(J)
          D(J,1)=YEST(J)
          DY(J)=YEST(J)
11      CONTINUE
      ELSE
        DO 12 K=1,IEST-1
          FX(K+1)=X(IEST-K)/XEST
12      CONTINUE
        DO 14 J=1,NV
          YY=YEST(J)
          V=D(J,1)
          C=YY
          D(J,1)=YY
          DO 13 K=2,IEST
            B1=FX(K)*V
            B=B1-C
            IF(B.NE.0.D0) THEN
              B=(C-V)/B
              DDY=C*B
              C=B1*B
            ELSE
              DDY=V
            ENDIF
            IF (K.NE.IEST) V=D(J,K)
            D(J,K)=DDY
            YY=YY+DDY
13        CONTINUE
          DY(J)=DDY
          YZ(J)=YY
14      CONTINUE
      ENDIF
      RETURN
      END

      SUBROUTINE RKQS(Y,DYDX,X,HTRY,EPS,YSCAL,HDID,HNEXT,ENERGY,N)
      USE COMMONS
      IMPLICIT NONE
      INTEGER N
      DOUBLE PRECISION EPS,HDID,HNEXT,HTRY,X,DYDX(3*NATOMS),Y(3*NATOMS),YSCAL(3*NATOMS)
CU    USES RKCK
      INTEGER I
      DOUBLE PRECISION ERRMAX,H,XNEW,YERR(3*NATOMS),YTEMP(3*NATOMS),SAFETY,PGROW
     *,PSHRNK,
     *ERRCON
      PARAMETER (SAFETY=0.9D0,PGROW=-.2D0,PSHRNK=-.25D0,ERRCON=1.89D-4)
      DOUBLE PRECISION EOLD, ENERGY, VNEW(3*NATOMS)
      
      EOLD=ENERGY
      H=HTRY
1     CALL RKCK(Y,DYDX,N,X,H,YTEMP,YERR)
      ERRMAX=0.D0
      DO 11 I=1,N
        ERRMAX=MAX(ERRMAX,ABS(YERR(I)/YSCAL(I)))
11    CONTINUE
      ERRMAX=ERRMAX/EPS

      PRINT*,'ERRMAX,H IN RKQS=',ERRMAX,H
      IF (ERRMAX.LT.1.0D0) THEN
         CALL POTENTIAL(YTEMP,VNEW,ENERGY,.FALSE.,.FALSE.)
         PRINT*,'ENERGY,EOLD=',ENERGY,EOLD

         IF (ENERGY.GT.EOLD+1.0D-12) THEN
            ERRMAX=2.0D0
C           EPS=EPS/2.0D0
            WRITE(*,'(A,4G20.10)') 'YTEMP(1),ENERGY,EOLD,EPS=',YTEMP(1),ENERGY,EOLD,EPS
         ELSE
C           EPS=EPS*1.1D0
         ENDIF
      ENDIF

      IF(ERRMAX.GT.1.D0)THEN
        H=SAFETY*H*(ERRMAX**PSHRNK)
        IF(H.LT.0.1D0*H)THEN
          H=.1D0*H
        ENDIF
        XNEW=X+H
        IF ((XNEW.EQ.X).OR.(EPS.LT.1.0D-20)) THEN
           PRINT*,' STEPSIZE UNDERFLOW IN RKQS'
           OPEN(UNIT=96,FILE='DISCONN',STATUS='UNKNOWN')
           PRINT '(A,3G20.10)',' INTRACTABLE DISCONTINUITY IN RKQS X,XNEW,EPS=',X,XNEW,EPS
           PRINT '(A,3G20.10)',' X,XNEW=',X,XNEW
           PRINT '(A,3G20.10)',' EPS=',EPS
           WRITE(96,'(A)') 'INTRACTABLE DISCONTINUITY'
           CLOSE(96)
!          STOP
        ENDIF
        GOTO 1
      ELSE
        IF(ERRMAX.GT.ERRCON)THEN
          HNEXT=SAFETY*H*(ERRMAX**PGROW)
        ELSE
          HNEXT=5.D0*H
        ENDIF
        HDID=H
        X=X+H
        DO 12 I=1,N
          Y(I)=YTEMP(I)
12      CONTINUE
        RETURN
      ENDIF
      END

      SUBROUTINE RKCK(Y,DYDX,N,X,H,YOUT,YERR)
      USE COMMONS
      IMPLICIT NONE
      INTEGER N
      DOUBLE PRECISION H,X,DYDX(N),Y(N),YERR(N),YOUT(N)
      INTEGER I
      DOUBLE PRECISION AK2(3*NATOMS),AK3(3*NATOMS),AK4(3*NATOMS),AK5(3*NATOMS),AK6(3*NATOMS)
     *,
     *YTEMP(3*NATOMS),A2,A3,A4,A5,A6,B21,B31,B32,B41,B42,B43,B51,B52,B53,
     *B54,B61,B62,B63,B64,B65,C1,C3,C4,C6,DC1,DC3,DC4,DC5,DC6
      PARAMETER (A2=.2D0,A3=.3D0,A4=.6D0,A5=1.D0,A6=.875D0,B21=.2D0,B31
     *=3.D0/40.D0,
     *B32=9.D0/40.D0,B41=.3D0,B42=-.9D0,B43=1.2D0,B51=-11.D0/54.D0,B52
     *=2.5D0,
     *B53=-70.D0/27.D0,B54=35.D0/27.D0,B61=1631.D0/55296.D0,B62=175.D0
     */512.D0,
     *B63=575.D0/13824.D0,B64=44275.D0/110592.D0,B65=253.D0/4096.D0,C1
     *=37.D0/378.D0,
     *C3=250.D0/621.D0,C4=125.D0/594.D0,C6=512.D0/1771.D0,DC1=C1-2825.D0
     */27648.D0,
     *DC3=C3-18575.D0/48384.D0,DC4=C4-13525.D0/55296.D0,DC5=-277.D0
     */14336.D0,
     *DC6=C6-.25D0)
      DOUBLE PRECISION E1, E2, E3,E4,E5

      DO 11 I=1,N
        YTEMP(I)=Y(I)+B21*H*DYDX(I)
11    CONTINUE
C     CALL DERIVS(X+A2*H,YTEMP,AK2)

      CALL POTENTIAL(YTEMP,AK2,E1,.TRUE.,.FALSE.)

      RMS=RMS*SQRT(1.0D0*N)

      DO I=1,N
         AK2(I)=-AK2(I)/MAX(RMS,1.0D0)
      ENDDO

      DO 12 I=1,N
        YTEMP(I)=Y(I)+H*(B31*DYDX(I)+B32*AK2(I))
12    CONTINUE
C     CALL DERIVS(X+A3*H,YTEMP,AK3)

      CALL POTENTIAL(YTEMP,AK3,E2,.TRUE.,.FALSE.)

      RMS=RMS*SQRT(1.0D0*N)

      DO I=1,N
         AK3(I)=-AK3(I)/MAX(RMS,1.0D0)
      ENDDO

      DO 13 I=1,N
        YTEMP(I)=Y(I)+H*(B41*DYDX(I)+B42*AK2(I)+B43*AK3(I))
13    CONTINUE
C     CALL DERIVS(X+A4*H,YTEMP,AK4)

      CALL POTENTIAL(YTEMP,AK4,E3,.TRUE.,.FALSE.)

      RMS=RMS*SQRT(1.0D0*N)

      DO I=1,N
         AK4(I)=-AK4(I)/MAX(RMS,1.0D0)
      ENDDO

      DO 14 I=1,N
        YTEMP(I)=Y(I)+H*(B51*DYDX(I)+B52*AK2(I)+B53*AK3(I)+B54*AK4(I))
14    CONTINUE
C     CALL DERIVS(X+A5*H,YTEMP,AK5)

      CALL POTENTIAL(YTEMP,AK5,E4,.TRUE.,.FALSE.)

      RMS=RMS*SQRT(1.0D0*N)

       DO I=1,N
          AK5(I)=-AK5(I)/MAX(RMS,1.0D0)
       ENDDO

      DO 15 I=1,N
        YTEMP(I)=Y(I)+H*(B61*DYDX(I)+B62*AK2(I)+B63*AK3(I)+B64*AK4(I)+B65*AK5(I))
15    CONTINUE
C     CALL DERIVS(X+A6*H,YTEMP,AK6)

      CALL POTENTIAL(YTEMP,AK6,E5,.TRUE.,.FALSE.)

      RMS=RMS*SQRT(1.0D0*N)

      DO I=1,N
         AK6(I)=-AK6(I)/MAX(RMS,1.0D0)
      ENDDO

      DO 16 I=1,N
        YOUT(I)=Y(I)+H*(C1*DYDX(I)+C3*AK3(I)+C4*AK4(I)+C6*AK6(I))
16    CONTINUE
      DO 17 I=1,N
        YERR(I)=H*(DC1*DYDX(I)+DC3*AK3(I)+DC4*AK4(I)+DC5*AK5(I)+DC6*AK6(I))
17    CONTINUE
      PRINT '(A,5F20.10)','ENERGIES=',E1,E2,E3,E4,E5
      RETURN
      END

