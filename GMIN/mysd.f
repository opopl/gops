C   GMIN: A PROGRAM FOR FINDING GLOBAL MINIMA
C   COPYRIGHT (C) 1999-2006 DAVID J. WALES
C   THIS FILE IS PART OF GMIN.
C
C   GMIN IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C   IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C   THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C   (AT YOUR OPTION) ANY LATER VERSION.
C
C   GMIN IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
C   BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
C   GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C   YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C   ALONG WITH THIS PROGRAM; IF NOT, WRITE TO THE FREE SOFTWARE
C   FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330, BOSTON, MA  02111-1307  USA
C
      SUBROUTINE MYSD(ITMAX,VARS,MFLAG,NSTP,ENERGY)
      USE COMMONS,ONLY : NATOMS, MYUNIT, GMAX, FIXIMAGE, RMS, SDTOL, DEBUG
      IMPLICIT NONE
      INTEGER NSTP, ITMAX, J1, NOPT
      LOGICAL MFLAG
      DOUBLE PRECISION VARS(3*NATOMS), GRAD(3*NATOMS), ENERGY, STEP(3*NATOMS), NEWVARS(3*NATOMS),
     &                 EPRED, ENEW, NEWGRAD(3*NATOMS), SFAC, GNORM, SLENGTH, DDOT, PERROR

      SFAC=1.1D0
      NOPT=3*NATOMS
      NSTP=1
      CALL POTENTIAL(VARS,GRAD,ENERGY,.TRUE.,.FALSE.)

10    GNORM=DSQRT(DDOT(NOPT,GRAD,1,GRAD,1))
      IF (GNORM.LE.0.0D0) THEN
         WRITE(MYUNIT,'(A)') 'MYSD> ERROR - GNORM IS ZERO'
         STOP
      ENDIF
      IF (NSTP.EQ.1) THEN
         SLENGTH=MIN(GNORM,1.0D0/GNORM)
      ENDIF

      FIXIMAGE=.TRUE.
!
!  CHECK FOR CONVERGENCE ON RMS FORCE.
!
      IF (RMS.LT.GMAX) THEN
         MFLAG=.TRUE.
         IF (MFLAG) THEN
            FIXIMAGE=.FALSE.
            RETURN
         ENDIF
      ENDIF
!
!  CHECK IF WE HAVE EXCEEDED MAXIMUM ALLOWED ITERATIONS.
!
      IF (NSTP.EQ.ITMAX) THEN
         MFLAG=.FALSE.
         FIXIMAGE=.FALSE.
         RETURN
      ENDIF

11    DO J1=1,NOPT
         STEP(J1)=-SLENGTH*GRAD(J1)/GNORM
         NEWVARS(J1)=VARS(J1)+STEP(J1)
      ENDDO
      EPRED=DDOT(NOPT,GRAD,1,STEP,1)
 
      CALL POTENTIAL(NEWVARS,NEWGRAD,ENEW,.TRUE.,.FALSE.)
      IF (ENEW-ENERGY.EQ.0.0D0) THEN
         WRITE(MYUNIT,'(A,G20.10)') 'MYSD> WARNING - ENEW=ENERGY=',ENERGY
         PERROR=0.0D0
      ELSE 
         PERROR=(EPRED-(ENEW-ENERGY))*100.0D0/(ENEW-ENERGY)
      ENDIF
      IF (PERROR.GT.SDTOL) THEN
         SLENGTH=SLENGTH/SFAC
         IF (DEBUG) WRITE(MYUNIT,'(A,G20.10,A,G20.10)') 'MYSD> % ERROR=',PERROR,
     &     ' EXCEEDS TOLERANCE, DECREASING STEP LENGTH TO',SLENGTH
         GOTO 11
      ELSEIF (PERROR.GT.SDTOL*0.66D0) THEN
         SLENGTH=SLENGTH/SFAC
         IF (DEBUG) WRITE(MYUNIT,'(A,G20.10,A,G20.10)') 'MYSD> % ERROR=',PERROR,
     &     ' DECREASING STEP LENGTH TO',SLENGTH
      ELSE
         SLENGTH=SLENGTH*SFAC
         IF (DEBUG) WRITE(MYUNIT,'(A,G20.10,A,G20.10)') 'MYSD> % ERROR=',PERROR,
     &     ' INCREASING STEP LENGTH TO',SLENGTH
      ENDIF
      ENERGY=ENEW
      GRAD(1:NOPT)=NEWGRAD(1:NOPT)
      VARS(1:NOPT)=NEWVARS(1:NOPT)

      IF (DEBUG) WRITE(MYUNIT,'(A,2F20.10,A,I6,A,G15.5)') 'MYSD> E AND RMS=',ENERGY,RMS,' AFTER ',
     &        NSTP,' SD CYCLES, STEP=',SLENGTH

      IF (SLENGTH.LT.1.0D-200) THEN
         WRITE(MYUNIT,'(A)') 'MYSD> STEP SIZE UNDERFLOW - QUIT'
         STOP
      ENDIF
      MFLAG=.FALSE.
      FIXIMAGE=.FALSE.
      NSTP=NSTP+1
      GOTO 10

      RETURN
      END
