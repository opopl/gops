!  GMIN: A PROGRAM FOR FINDING GLOBAL MINIMA
!  COPYRIGHT (C) 1999-2006 DAVID J. WALES
!  THIS FILE IS PART OF GMIN.
!
!  GMIN IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
!  IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
!  THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
!  (AT YOUR OPTION) ANY LATER VERSION.
!
!  GMIN IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
!  BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
!  MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
!  GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
!
!  YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
!  ALONG WITH THIS PROGRAM; IF NOT, WRITE TO THE FREE SOFTWARE
!  FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330, BOSTON, MA  02111-1307  USA
!
!
!  BIPARTITE MATCHING ROUTINE TO FIND THE CLOSEST PERMUTATIONAL ISOMER
!  OF ONE STRUCTURE FROM ANOTHER.
!  THE MATCHING IS P(I) <--> Q(PERM(I))
!  CHECK FOR "OBVIOUS" SOLUTION WHERE THE MINIMUM DISTANCE FOR EACH
!  ATOM DEFINES A MATCHING AS WELL - THIS WILL FIND THE ANSWER
!  IMMEDIATELY FOR ALIGNED PERMUTATIONAL ISOMERS.  NOT DONE YET!
!

SUBROUTINE BIPARTITE(N,P,Q,PERM,DIST,WORSTDIST,WORSTRADIUS)
IMPLICIT NONE
INTEGER N, PERM(N), NCONN(2*N+2), NEIGHBOUR(2*N+2,2*N+2), NVERTEX, J1, J2, NPERM, PARENT(2*N+2), J4, OTHERMIN, J3, JMINL, &
        NDIJ, J5, CURRENTMIN, PARENTMIN, LOSE, NDUMMY, NCOUNT, I, MINDIST, MINJ
DOUBLE PRECISION P(3*N), Q(3*N), DIST, WORSTDIST, WORSTRADIUS, WEIGHT(2*N+2,2*N+2), PATHLENGTH(2*N+2), TMPLENGTH, MINLENGTH, &
                 DUMMY
LOGICAL PERMANENT(2*N+2), SIMPLESOL, CHANGE
!
!  SET UP INITIAL ADJACENCY LISTS FOR THE UNDERLYING NETWORK,
!  WHICH HAS DIMENSION 2*N+2.
!  VERTEX 1 IS THE SOURCE, VERTEX 2*N+2 IS THE SINK, AND THE
!  N ATOMS OF STRUCTURES P AND Q OCCUPY VERTICES 2 TO N+1 AND
!  N+2 TO 2*N+1, RESPECTIVELY.
!
NVERTEX=2*N+2

NCONN(1)=N ! SOURCE
DO J1=1,N
   NEIGHBOUR(1,J1)=J1+1
   WEIGHT(1,J1)=0.0D0
ENDDO

SIMPLESOL=.TRUE.
DO J1=1,N  ! STRUCTURE P
   NCONN(J1+1)=N
   MINDIST=HUGE(MINDIST)
   DO J2=1,N
      NEIGHBOUR(J1+1,J2)=N+J2+1
      WEIGHT(J1+1,J2)=(P(3*(J1-1)+1)-Q(3*(J2-1)+1))**2+(P(3*(J1-1)+2)-Q(3*(J2-1)+2))**2+(P(3*(J1-1)+3)-Q(3*(J2-1)+3))**2
      IF (WEIGHT(J1+1,J2).LT.MINDIST) THEN
         MINDIST=WEIGHT(J1+1,J2)
         MINJ=J2
      ENDIF
   ENDDO
   PERM(J1)=MINJ
   IF (SIMPLESOL) THEN
      DO J2=1,J1-1
         IF (PERM(J1).EQ.PERM(J2)) THEN
            SIMPLESOL=.FALSE.
            EXIT
         ENDIF
      ENDDO
   ENDIF
ENDDO

IF (SIMPLESOL) THEN
   ! PRINT '(A)','SIMPLE SOLUTION FOUND IN BIPARTITE'
   GOTO 100
ENDIF

DO J1=1,N  ! STRUCTURE Q
   NCONN(J1+N+1)=1
   NEIGHBOUR(J1+N+1,1)=NVERTEX
   WEIGHT(J1+N+1,1)=0.0D0
ENDDO

NCONN(2*N+2)=0 ! SINK VERTEX
!
!  NOW RUN DIJKSTRA'S ALGORITHM TO FIND THE SHORTEST PATH LENGTHS FROM THE SOURCE TO THE
!  OTHER VERTICES.
!
NDIJ=0
OUTER: DO
   NDIJ=NDIJ+1
   PATHLENGTH(2:NVERTEX)=HUGE(1.0D0)
   PERMANENT(1:NVERTEX)=.FALSE.
   PARENT(1)=0 
   PATHLENGTH(1)=0.0D0
   NCOUNT=0
   DIJKSTRALOOP: DO
      MINLENGTH=HUGE(MINLENGTH)
      DO J1=1,NVERTEX
         IF (PERMANENT(J1)) CYCLE
         IF (PATHLENGTH(J1).LT.MINLENGTH) THEN
            MINLENGTH=PATHLENGTH(J1)
            NDUMMY=J1
         ENDIF
      ENDDO
      PERMANENT(NDUMMY)=.TRUE.
!     CHANGE=.FALSE.
      DO J2=1,NCONN(NDUMMY) ! NEIGHBOURS OF VERTEX WITH MINIMUM PATHLENGTH
         IF (PATHLENGTH(NEIGHBOUR(NDUMMY,J2)).GT.PATHLENGTH(NDUMMY)+WEIGHT(NDUMMY,J2)) THEN
            PATHLENGTH(NEIGHBOUR(NDUMMY,J2))=PATHLENGTH(NDUMMY)+WEIGHT(NDUMMY,J2)
            PARENT(NEIGHBOUR(NDUMMY,J2))=NDUMMY
!           CHANGE=.TRUE.
         ENDIF
      ENDDO
      NCOUNT=NCOUNT+1
!     PRINT '(A,I6,A,L5)','DIJKSTRA ITERATION ',NCOUNT,' CHANGE=',CHANGE
      IF (NCOUNT.GE.NVERTEX) EXIT
   ENDDO DIJKSTRALOOP
!
! ADJUST EDGE WEIGHTS
!
   DO J1=1,NVERTEX
      DO J2=1,NCONN(J1)
         WEIGHT(J1,J2)=WEIGHT(J1,J2)+PATHLENGTH(J1)-PATHLENGTH(NEIGHBOUR(J1,J2))
      ENDDO
   ENDDO
!
! REVERSE SHORTEST PATH. NCONN SHOULD STAY THE SAME FOR VERTICES 2 TO 2*N+1,
! AND CHANGE TO NATOMS-NDIJ AND NDIJ FOR THE SOURCE AND SINK ON CYCLE NDIJ.
!
   CURRENTMIN=NVERTEX
   PARENTMIN=PARENT(CURRENTMIN)
   NCONN(CURRENTMIN)=NCONN(CURRENTMIN)+1
   NEIGHBOUR(CURRENTMIN,NCONN(CURRENTMIN))=PARENTMIN
   DO J1=1,NCONN(PARENTMIN)
      IF (NEIGHBOUR(PARENTMIN,J1).EQ.CURRENTMIN) THEN
         WEIGHT(CURRENTMIN,NCONN(CURRENTMIN))=WEIGHT(PARENTMIN,J1)
         LOSE=J1
         EXIT
      ENDIF
   ENDDO
   DO
     CURRENTMIN=PARENTMIN
     PARENTMIN=PARENT(CURRENTMIN)
     DO J1=1,NCONN(PARENTMIN)
        IF (NEIGHBOUR(PARENTMIN,J1).EQ.CURRENTMIN) THEN
           WEIGHT(CURRENTMIN,LOSE)=WEIGHT(PARENTMIN,J1)
           NEIGHBOUR(CURRENTMIN,LOSE)=PARENTMIN
           LOSE=J1
           EXIT
        ENDIF
     ENDDO
     IF (PARENTMIN.EQ.1) EXIT
   ENDDO
   DO J2=LOSE,NCONN(1)-1
      WEIGHT(1,J2)=WEIGHT(1,J2+1)
      NEIGHBOUR(1,J2)=NEIGHBOUR(1,J2+1)
   ENDDO
   NCONN(1)=NCONN(1)-1
   IF (NCONN(1).EQ.0) EXIT OUTER
ENDDO OUTER

DO J1=1,N
   PERM(NEIGHBOUR(N+1+J1,1)-1)=J1
ENDDO

100 CONTINUE
WORSTDIST=-1.0D0
DIST=0.0D0
DO I=1,N
   DUMMY=(P(3*(I-1)+1)-Q(3*(PERM(I)-1)+1))**2+(P(3*(I-1)+2)-Q(3*(PERM(I)-1)+2))**2+(P(3*(I-1)+3)-Q(3*(PERM(I)-1)+3))**2
   DIST=DIST+DUMMY
   IF (DUMMY.GT.WORSTDIST) THEN
      WORSTDIST=DUMMY
      WORSTRADIUS=P(3*(I-1)+1)**2+P(3*(I-1)+2)**2+P(3*(I-1)+3)**2
   ENDIF
ENDDO
WORSTDIST=SQRT(WORSTDIST)
WORSTRADIUS=MAX(SQRT(WORSTRADIUS),1.0D0)

END SUBROUTINE BIPARTITE
