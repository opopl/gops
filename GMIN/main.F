!OP226>=================================== 
!OP226> GPL LICENSE INFO {{{
C   GMIN: A PROGRAM FOR FINDING GLOBAL MINIMA
C   COPYRIGHT (C) 1999- DAVID J. WALES
C   THIS FILE IS PART OF GMIN.
C
C   GMIN IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C   IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C   THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C   (AT YOUR OPTION) ANY LATER VERSION.
C
C   GMIN IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
C   BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
C   GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C   YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C   ALONG WITH THIS PROGRAM; IF NOT, WRITE TO THE FREE SOFTWARE
C   FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330, BOSTON, MA  02111-1307  USA
C
!OP226>}}} 
      
!> \NAME GMIN
!> \BRIEF MAIN PROGRAM FILE FOR GMIN
!> \PARAM SCREENC
!OP226>=================================== 
      PROGRAM GMIN
!OP226>=================================== 
!OP226> DECLARATIONS {{{ 
      !OP226> MODULES {{{ 
      USE MODMXATMS
      USE NOA
      USE COMMONS
      USE QMODULE
      USE PERMU
      USE F1COM
      USE MODAMBER
      USE MODAMBER9, ONLY : AMBFINALIO_NODE,MDCRD_UNIT,MDINFO_UNIT,AMBPDB_UNIT
      USE MODCHARMM
      USE PORFUNCS
      !OP226>  }}}
      !OP226> OTHER {{{
      IMPLICIT NONE
      !EXTERNAL READ_CMD_ARGS
#IFDEF MPI
      INCLUDE 'MPIF.H'
#ENDIF
      INTEGER J1,J2, JP, MPIERR, NDUMMY3,NPTOTAL,VERSIONTEMP
      DOUBLE PRECISION, ALLOCATABLE :: SCREENC(:)
      DOUBLE PRECISION POTEL
      DOUBLE PRECISION, ALLOCATABLE :: TMPCOORDS(:)
      INTEGER, ALLOCATABLE :: NDUMMY(:), NDUMMY2(:,:)
      LOGICAL LOPEN

      CHARACTER(LEN=130) ISTR
      CHARACTER(LEN=40) :: ATOM1,ATOM2,ATOMPAIR

      COMMON /MYPOT/ POTEL
!OP226>  }}}
!OP226> END DECLARATIONS }}}
!OP226>=================================== 

      CALL CPU_TIME(TSTART)
      CALL READ_CMD_ARGS
#IFDEF MPI
!OP226> MPI SECTION {{{ 
      CALL MPI_INIT(MPIERR)
      CALL MPI_COMM_SIZE(MPI_COMM_WORLD,NPAR,MPIERR)
      CALL MPI_COMM_RANK(MPI_COMM_WORLD,MYNODE,MPIERR)
      MYUNIT=22980+MYNODE
      MDCRD_UNIT=20000+MYNODE
      MDINFO_UNIT=21000+MYNODE
      AMBPDB_UNIT=18000+MYNODE
      AMBFINALIO_NODE=200+MYNODE
      WRITE (ISTR, '(I10)') MYNODE+1
      IF (TRIM(ADJUSTL(INFILE)).EQ.'') INFILE='GMIN_OUT'
      IF (NPAR.GT.1) THEN 
         MYFILENAME=TRIM(ADJUSTL(INFILE))//"."//TRIM(ADJUSTL(ISTR))
      ELSE
         MYFILENAME=TRIM(ADJUSTL(INFILE))
      ENDIF
      OPEN(MYUNIT,FILE=MYFILENAME, STATUS="UNKNOWN", FORM="FORMATTED")
      WRITE(MYUNIT, '(A,I10,A,I10)') "STARTING PARALLEL EXECUTION: PROCESSOR", MYNODE+1, " OF ",NPAR
!OP226>}}} 
#ELSE
!OP226> NON-MPI SECTION {{{ 
      NPAR=1
      MYNODE=0
      MYUNIT=22979+1
      MDCRD_UNIT=20000
      MDINFO_UNIT=21000
      AMBPDB_UNIT=18000
      AMBFINALIO_NODE=1
      IF (TRIM(ADJUSTL(INFILE)).EQ.'') THEN
         MYFILENAME="GMIN_OUT"
      ELSE
         MYFILENAME=TRIM(ADJUSTL(INFILE))
      ENDIF
      OPEN(MYUNIT,FILE=MYFILENAME, STATUS="UNKNOWN", FORM="FORMATTED")
      WRITE(MYUNIT, '(A,I10,A,I10,A)') "STARTING SERIAL EXECUTION" 
!OP226>}}} 
#ENDIF
!OP226> ALLOCATE MEMORY; OPEN FILES; INITIALIZE DIFFERENT THINGS  {{{ 
! ADD THE GMIN VERSION TO THE OUTPUT - HELPS BUG HUNTING :)
      !WRITE(MYUNIT, '(A,I5)') 'GMIN VERSION R',VERSIONTEMP
!     CALL DISPLAY_VERSION(MYUNIT)
      CALL COUNTATOMS(MYUNIT)
      IF (CHRMMT) WRITE(MYUNIT,'(A,I8)') 'MAIN> MAXAIM PARAMETER FOR CHARMM MXATMS=',MXATMS
      CALL MODCOMMONINIT
 
      ALLOCATE(FIN(3*NATOMS))
      ALLOCATE(XICOM(3*NATOMS),PCOM(3*NATOMS))
      ALLOCATE(SCREENC(3*NATOMS))
      ALLOCATE(IATNUM(NATOMS), VT(NATOMS), ZSYM(NATOMS))
      VT(1:NATOMS)=0.0D0 ! TO PREVENT READING FROM UNINITIALISED MEMORY
      IF (Q4T) CALL SHINIT

      INQUIRE(UNIT=1,OPENED=LOPEN)
      IF (LOPEN) THEN
         WRITE(*,'(A,I2,A)') 'MAIN> A ERROR *** UNIT ', 1, ' IS NOT FREE '
         STOP
      ENDIF

      CALL KEYWORD

      INQUIRE(UNIT=1,OPENED=LOPEN)
      IF (LOPEN) THEN
         WRITE(*,'(A,I2,A)') 'MAIN> B ERROR *** UNIT ', 1, ' IS NOT FREE '
         STOP
      ENDIF

      IF (CHRIGIDTRANST.OR.CHRIGIDROTT) CALL CHSETSEG

!OP226> RMST {{{ 
      IF (RMST) THEN
         ALLOCATE(RMSBEST(RMSSAVE,2),RMSCOOR(RMSSAVE,3*NATOMS))
         RMSBEST(1:RMSSAVE,1)=RMSLIMIT+RMSTOL
         RMSBEST(1:RMSSAVE,2)=0.D0
         RMSCOOR(1:RMSSAVE,1:3*NATOMS)=0.D0
         ALLOCATE(COORCOMP(1:3*NATOMS))
!
!        CSW34> NEED TO ADD THE READ IN FOR OTHER FILE FORMATS
!        (CRD,PDB). STILL NOT SURE HOW GMIN READS IN THE INPUT.CRD FILE
!        FOR CHARMM. IT APPEARS TO BE READING INTO UNIT 7 IN IO1.F
!        THOUGH - BUT ONLY FROM XYZ FORMAT! IS THERE A HIDDEN
!        CONVERSION?
!         
         OPEN(UNIT=1,FILE='COMPARE',STATUS='OLD')
         READ(1,*) (COORCOMP(J1),J1=1,3*NATOMS)
         CLOSE(1)
      ENDIF
!OP226>}}} 

      ALLOCATE(FF(NSAVE),QMIN(NSAVE))
      ALLOCATE(QMINP(NSAVE,3*NATOMS))

!        CSW34> ALLOCATE THE INTERACTION ENERGY TRACKING ARRAYS IF A9INTE IN DATA
!OP226> IF (A9INTET.AND.AMBERT) THEN  {{{
      IF (A9INTET.AND.AMBERT) THEN 
         ALLOCATE(INTEFF(NSAVEINTE),INTEQMIN(NSAVEINTE))
         ALLOCATE(INTEQMINP(NSAVEINTE,3*NATOMS))
         INTEQMIN(:)=1.0D10 
         INTEQMINP(1:NSAVEINTE,1:3*NATOMS)=0.0D0 ! TO PREVENT READING FROM UNINITIALISED MEMORY
         INTEFF(1:NSAVEINTE)=0 ! TO PREVENT READING FROM UNINITIALISED MEMORY
      ENDIF  
!OP226>}}} 

!OP226> GAUSST {{{ 
      IF (GAUSST) THEN
         ALLOCATE(GAUSSKK(3*NATOMS,GMODES),GAUSSEE(GMODES),GKSMALL(3*NATOMS))
         CALL KEGEN ! INITIAL SETUP 
         DO J1=1,GMODES
             PRINT *,J1,GAUSSEE(J1)
         ENDDO
      ENDIF
!OP226>}}} 

      QMINP(1:NSAVE,1:3*NATOMS)=0.0D0 ! TO PREVENT READING FROM UNINITIALISED MEMORY
      COORDSO(1:3*NATOMS,1:NPAR)=0.0D0 ! TO PREVENT READING FROM UNINITIALISED MEMORY
      FF(1:NSAVE)=0 ! TO PREVENT READING FROM UNINITIALISED MEMORY
      VATO(1:NATOMS,1:NPAR)=0.0D0 ! TO PREVENT READING FROM UNINITIALISED MEMORY
      ALLOCATE(ESAVE(NTAB,NPAR),XINSAVE(NTAB,NPAR))
      ALLOCATE(VEC(NVEC))

!     IF (SYMMETRIZE.AND.(.NOT.CENT)) THEN
!        PRINT '(A)','PROBABLE INPUT ERROR - SYMMETRIZE TRUE BUT CENT FALSE'
!        STOP
!     ENDIF

!OP226> DUMPT {{{ 
      IF (DUMPT) THEN
         IF (CHRMMT) THEN
            OPEN(UNIT=719,FILE='DUMP.CRD',STATUS='UNKNOWN')
            OPEN(UNIT=720,FILE='DUMP.PDB',STATUS='UNKNOWN')
         ENDIF
         DUMPXYZUNIT=40
         DUMPVUNIT=39
         DO J1=1,NPAR
            WRITE (ISTR,'(A5,I1,A4)') 'DUMP.',J1,'.XYZ'
            J2=DUMPXYZUNIT+J1
            OPEN(UNIT=J2,FILE=TRIM(ADJUSTL(ISTR)),STATUS='UNKNOWN')
            WRITE (ISTR,'(A5,I1,A2)') 'DUMP.',J1,'.V'
            J2=DUMPVUNIT-J1
            OPEN(UNIT=J2,FILE=TRIM(ADJUSTL(ISTR)),STATUS='UNKNOWN')
         ENDDO
      ENDIF
!OP226>}}} 

      IF (PAIRDISTT) THEN
         MYPUNIT=3000+MYNODE
         IF (NPAR.GT.1) THEN
            OPEN(MYPUNIT,FILE="PAIRDISTS."//TRIM(ADJUSTL(ISTR)),STATUS='UNKNOWN',FORM='FORMATTED',POSITION='APPEND')
         ELSE
            OPEN(MYPUNIT,FILE="PAIRDISTS",STATUS='UNKNOWN',FORM='FORMATTED',POSITION='APPEND')
         ENDIF
         WRITE(MYPUNIT,'(A10)',ADVANCE="NO") "QUENCH  "
         DO J1=1,NPAIRS
            WRITE(ATOM1,*) PAIRDIST(J1,1)
            WRITE(ATOM2,*) PAIRDIST(J1,2)
            WRITE(ATOMPAIR,*) TRIM(ADJUSTL(ATOM1))//"-"//TRIM(ADJUSTL(ATOM2))
            WRITE(MYPUNIT,'(A10)',ADVANCE="NO") TRIM(ADJUSTL(ATOMPAIR))//"  " 
         ENDDO
         WRITE(MYUNIT,'(A)') ""
      ENDIF

!OP226> TRACKDATAT {{{ 
!
!     CSW34> TRACKDATA KEYWORD PRINTS THE ENERGY AND MARKOV ENERGY 
!     TO FILES FOR VIEWING DURING A RUN. IF RMS IS ALSO SPECIFIED IT
!     PRINTS THE RMSD FROM THE COMPARISON STRUCTURE INTO A FILE.
!
      IF (TRACKDATAT) THEN
         MYEUNIT=4000+MYNODE
         MYMUNIT=6000+MYNODE
         MYRUNIT=8000+MYNODE
         MYBUNIT=10000+MYNODE
         IF (NPAR.GT.1) THEN
            OPEN(MYEUNIT,FILE="ENERGY."//TRIM(ADJUSTL(ISTR)),STATUS='UNKNOWN',FORM='FORMATTED',POSITION='APPEND')
            OPEN(MYMUNIT,FILE="MARKOV."//TRIM(ADJUSTL(ISTR)),STATUS='UNKNOWN',FORM='FORMATTED',POSITION='APPEND')
            OPEN(MYBUNIT,FILE="BEST."//TRIM(ADJUSTL(ISTR)),STATUS='UNKNOWN',FORM='FORMATTED',POSITION='APPEND')
         ELSE
            OPEN(MYEUNIT,FILE='ENERGY',STATUS='UNKNOWN',FORM='FORMATTED',POSITION='APPEND')
            OPEN(MYMUNIT,FILE='MARKOV',STATUS='UNKNOWN',FORM='FORMATTED',POSITION='APPEND')
            IF (RMST) OPEN(MYRUNIT,FILE='RMSD',STATUS='UNKNOWN',FORM='FORMATTED',POSITION='APPEND')
            OPEN(MYBUNIT,FILE='BEST',STATUS='UNKNOWN',FORM='FORMATTED',POSITION='APPEND')
            IF (A9INTET) THEN
               OPEN(UNIT=3998,FILE='INTE.DAT',STATUS='UNKNOWN',FORM='FORMATTED')
               OPEN(UNIT=3999,FILE='BESTINTE.DAT',STATUS='UNKNOWN',FORM='FORMATTED')
            ENDIF            
         ENDIF
      ENDIF
!OP226>}}} 
      CALL FLUSH(6)
      CALL IO1
!OP226> CSMT {{{ 
!
! IF THIS IS A CSM OPTIMISATION WE NOW HAVE TO MULTIPLY THE NUMBER OF ATOMS BY THE NUMBER OF
! GROUP OPERATIONS AND REPLICATE SOME COORDINATES AND ALLOWED PERMUTATIONS.
!
      IF (CSMT) THEN
         CALL CSMINIT
         IF (SYMMETRIZECSM) THEN
            IF (CSMMAXIT.EQ.0) CSMMAXIT=MAXIT
         ELSE
            CSMMAXIT=MAXIT
         ENDIF
      ENDIF
!OP226>}}} 

      CALL FLUSH(6)

!OP226> PROJIT {{{ 
      IF (PROJIT) THEN
         ALLOCATE(TMPCOORDS(3*NATOMS))
         TMPCOORDS(1:3*NATOMS)=COORDS(1:3*NATOMS,1)
         CALL PROJIINIT(TMPCOORDS,NATOMS)
         DEALLOCATE(TMPCOORDS)
      ENDIF
!OP226>}}} 

!OP226> VGW SEEDT {{{ 
      IF(VGW) THEN
        CALL INITIALIZE_VGWSP(NATOMS,LJSIGMA,LJEPSILON,TAUMAX,CPFACTORSG,CPS,VGWTOL)
        CALL INITIALIZE_VGW(NATOMS,LJSIGMA,LJEPSILON,TAUMAXFULL,CPFACTORFG,CPF)
      ENDIF

      IF (SEEDT) THEN
         CALL GSEED
      ELSE
         IF ((.NOT.FIELDT).AND.CENT) THEN
            DO J1=1,NPAR
               IF (.NOT.SEEDT) CALL CENTRE2(COORDS(1:3*NATOMS,J1))
            ENDDO
         ELSEIF ((.NOT.FIELDT).AND.FIXCOM) THEN
            DO J1=1,NPAR
               IF (.NOT.SEEDT) CALL CENTRECOM(COORDS(1:3*NATOMS,J1))
            ENDDO
         ENDIF
      ENDIF
!OP226>}}} 

      IF (SUPERSTEP) NSUPERSTEP=0
      
      DO JP=1,NPAR
         NQ(JP)=1
      ENDDO
      DO J1=1,NSAVE
         QMIN(J1)=1.0D10
      ENDDO
!OP226> END INITIALIZATIONS AND ALLOCATIONS }}} 

!OP226> MAIN PROGRAM RUN
      IF ((NRUNS.GT.0).OR.PTMC.OR.BSPT) CALL MCRUNS(SCREENC)

C     CALL SYSTEM('RM SSDUMP SSAVE >& /DEV/NULL')

!OP226> DEALLOCATE MEMORY; CLOSE FILES {{{ 
      IF (ALLOCATED(FIN)) DEALLOCATE(FIN)
      IF (ALLOCATED(XICOM)) DEALLOCATE(XICOM)
      IF (ALLOCATED(PCOM)) DEALLOCATE(PCOM)
      IF (ALLOCATED(GAUSSKK)) DEALLOCATE(GAUSSKK,GAUSSEE)
C     DEALLOCATE DYNAMIC MEMORY FOR AMBER
      IF (AMBERT) CALL AMBER_DEALLOCATE_STACKS
      CALL MODCOMMONDEINIT
      CALL FLUSH(MYUNIT)

      IF(VGW) THEN
        CALL CLEANUP_VGWSP
        CALL CLEANUP_VGW
      ENDIF

      CLOSE(MYUNIT)
! CSW34> CLOSE PAIRDISTS.* FILES
      IF (PAIRDISTT) CLOSE(MYPUNIT)
!OP226> CLOSING FILES FOR: TRACKDATAT RMST A9INTET {{{ 
      IF (TRACKDATAT) THEN
         CLOSE(MYEUNIT)
         CLOSE(MYMUNIT)
         IF (RMST) CLOSE(MYRUNIT)
         CLOSE(MYBUNIT)
         IF (A9INTET) THEN
            CLOSE(3998)
            CLOSE(3999)
         ENDIF
      ENDIF
!OP226>}}} 
#IFDEF MPI
      CALL MPI_FINALIZE(MPIERR)
#ENDIF

!OP226>}}} 
      STOP

      END
