MODULE SPFUNCTS
! EFK 11/01/07
! THIS FILE CONTAINS SUBROUTINES FOR COMPUTING VARIOUS SPECIAL FUNCTIONS
!
  IMPLICIT NONE

  COMPLEX (KIND=KIND(1.0D0)), PARAMETER :: CMPLXI = (0.0D0,1.0D0)

CONTAINS
  SUBROUTINE INITIATE_RANDOM(SEED)
    ! INITIATE RANDOM NUMBER GENERATOR WITH THE GIVEN SEED

    IMPLICIT NONE

    INTEGER, INTENT(IN) :: SEED
    INTEGER, ALLOCATABLE :: FULLSEED(:)
    INTEGER :: SEEDSIZE
    DOUBLE PRECISION :: RANDSTART(1000)

    CALL RANDOM_SEED(SIZE=SEEDSIZE)
    ALLOCATE(FULLSEED(SEEDSIZE))
    FULLSEED(:) = SEED

    CALL RANDOM_SEED(PUT=FULLSEED(:))
    CALL RANDOM_NUMBER(RANDSTART(1:1000))

    DEALLOCATE(FULLSEED)
    RETURN
  END SUBROUTINE INITIATE_RANDOM

  SUBROUTINE BAND2SCS(BANDM,VAL,INDX,JNDX,KD,N,NNZ)
    ! CONVERT A BAND MATRIX OF DIMENSION 2*KD+1 WHERE KD IS THE NUMBER
    ! OF SUPERDIAGONALS
    ! TO A MATRIX IN SPARSE COORDINATE STORAGE FORMAT 
    ! (SUCH AS REQUIRED BY NAG SPARSE CHOLESKY DECOMPOSITION ROUTINE F11JAF)
    ! THE ENTRIES IN THE SCS MATRIX ARE ORDERED BY INCREASING ROW AND THEN
    ! BY INCREASING COLUMN WITHIN EACH ROW
    ! ONLY THE UPPER TRIANGLE PART OF BANDM IS USED
    ! SCS IS TRANSPOSED (SO THAT ROW NUMBERS ARE ALWAYS GREATER THAN COLUMNS)
    ! N BY N IS THE DIMENSION OF THE FULL MATRIX
    ! RETURNS NNZ - THE NUMBER OF NONZERO ELEMENTS
    ! NNZ <= (KD+1)*N
    ! THE VAL, INDX, JNDX ARRAYS HAVE DIMENSION >= 2*NNZ

    IMPLICIT NONE
    INTEGER, INTENT(IN) :: N, KD
    DOUBLE PRECISION, INTENT(IN) :: BANDM(2*KD+1,N)
    DOUBLE PRECISION, INTENT(OUT) :: VAL(2*(KD+1)*N)
    INTEGER, INTENT(OUT) :: INDX(2*(KD+1)*N), JNDX(2*(KD+1)*N), NNZ

    INTEGER :: I, R, C
    DOUBLE PRECISION :: V
    DOUBLE PRECISION, PARAMETER :: TINY=1.0D-10

    I = 0
    DO C = 1,KD !COLUMN
       DO R = 1,C !ROW
          V = BANDM(KD+1+R-C,C)
          IF (ABS(V).GT.TINY) THEN
             I = I + 1
             VAL(I) = V
             INDX(I) = C
             JNDX(I) = R
          ENDIF
       ENDDO
    ENDDO

    DO C = KD+1,N !COLUMN
       DO R = C-KD,C !ROW
          V = BANDM(KD+1+R-C,C)
          IF (ABS(V).GT.TINY) THEN
             I = I + 1
             VAL(I) = V
             INDX(I) = C
             JNDX(I) = R
          ENDIF
       ENDDO
    ENDDO

    NNZ = I
    
!    PRINT*, 'FRACTION NONSPARSE: ', DBLE(NNZ)/((KD+1)*N-KD*(KD+1)/2)
  END SUBROUTINE BAND2SCS

  SUBROUTINE DUMPCOORDS(X, FNAME, APPEND)
    USE COMMONS, ONLY : NATOMS
    IMPLICIT NONE
    CHARACTER (*) :: FNAME
    LOGICAL :: APPEND
    DOUBLE PRECISION :: X(3*NATOMS)
    INTEGER :: A

    ! GIVEN COORDINATE ARRAY X FOR A SINGLE MOLECULE, DUMP INTO FILE FNAME
    IF (APPEND) THEN
       OPEN (UNIT = 55, FILE = FNAME, STATUS = 'UNKNOWN', POSITION = 'APPEND')
    ELSE
       OPEN (UNIT = 55, FILE = FNAME, STATUS = 'UNKNOWN')
    ENDIF
    WRITE(55,'(I6)') NATOMS
    WRITE(55,'(A)') ' '
    WRITE(55,'(A3,3G25.15)') ('AX ',X(3*(A-1)+1:3*(A-1)+3),A=1,NATOMS)
    CLOSE(55)
  END SUBROUTINE DUMPCOORDS

  SUBROUTINE DUMPFRAMES(X, NFRAME,FNAME)
    ! DUMP OUT THE FRAMES FROM A 1D COORDINATE ARRAY
    ! NFRAME IS THE NUMBER OF FRAMES
    USE COMMONS, ONLY : NATOMS
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: NFRAME
    CHARACTER (*), INTENT(IN) :: FNAME
    DOUBLE PRECISION, INTENT(IN) :: X(3*NATOMS*NFRAME)
    INTEGER :: A, F

    ! GIVEN COORDINATE ARRAY X FOR A SINGLE MOLECULE, DUMP INTO FILE FNAME
    OPEN (UNIT = 55, FILE = FNAME, STATUS = 'UNKNOWN')
    DO F = 1,NFRAME
       WRITE(55,'(I6)') NATOMS
       WRITE(55,'(A,I4)') ' FRAME ', F
       WRITE(55,'(A3,3G25.15)') ('AX ',X(3*NATOMS*(F-1)+3*(A-1)+1:3*NATOMS*(F-1)+3*(A-1)+3),A=1,NATOMS)
    ENDDO
    CLOSE(55)

  END SUBROUTINE DUMPFRAMES

    SUBROUTINE CROSS_PRODUCT(A, B, C)
      ! TAKE THE CROSS PRODUCT OF 3D VECTORS A AND B; RETURN RESULT IN C

      IMPLICIT NONE

      DOUBLE PRECISION, INTENT(IN) :: A(3), B(3)
      DOUBLE PRECISION, INTENT(OUT) :: C(3)

      C(1) = A(2)*B(3) - A(3)*B(2)
      C(2) = A(3)*B(1)-A(1)*B(3)
      C(3) = A(1)*B(2) - A(2)*B(1)

      RETURN
    END SUBROUTINE CROSS_PRODUCT

    SUBROUTINE NORMALIZE(X)
      ! NORMALIZE A 3 DIMENSIONAL VECTOR

      IMPLICIT NONE

      DOUBLE PRECISION, INTENT(INOUT) :: X(3)
      DOUBLE PRECISION :: DX

      DX = SQRT(DOT_PRODUCT(X,X))
      X(:) = X(:)/DX

      RETURN
    END SUBROUTINE NORMALIZE

    SUBROUTINE IRANDOMSELECT(CHOICES, PICKED, NC, NS, SEED)
      ! FROM AN ARRAY CHOICES OF SIZE NC, SELECT NP ELEMENTS RANDOMLY
      ! AND PUT RESULTS IN PICKED
      ! CHOICES AND PICKED SHOULD BE INTEGER ARRAYS
      ! USES SIMPLE ALGORITHM S FROM VITTER, 1984, COMMUN. ACM
      ! AT EACH STEP, IF M ELEMENTS REMAIN TO BE SELECTED FROM N POSSIBILITIES
      ! THE PROBABILITY OF SELECTING THE NEXT ELEMENT IS M/N

      IMPLICIT NONE

      INTEGER, INTENT(IN) :: NC, NS, CHOICES(NC), SEED
      INTEGER, INTENT(OUT) :: PICKED(NS)

      INTEGER :: SEEDSIZE, N, S
      INTEGER, ALLOCATABLE :: FULLSEED(:)
      DOUBLE PRECISION :: RANSTART(1000), R

      IF (NS > NC) THEN
         PRINT*, 'ERROR: NS > NC IN IRANDOMSELECT'
         STOP
      END IF

      CALL RANDOM_SEED(SIZE=SEEDSIZE)
      ALLOCATE(FULLSEED(SEEDSIZE))
      FULLSEED(:) = SEED
      CALL RANDOM_SEED(PUT=FULLSEED(:SEEDSIZE))
      CALL RANDOM_NUMBER(RANSTART(1:1000)) ! GET THE GENERATOR STARTED

      N = NC; S = NS
      DO 
         CALL RANDOM_NUMBER(R)
         IF (R*N <= S) THEN
            PICKED(NS-S+1) = CHOICES(NC-N+1)
            S = S - 1
         END IF
         N = N - 1
         IF (S <= 0) THEN
            EXIT
         ENDIF
      ENDDO
      DEALLOCATE(FULLSEED)
      RETURN      
    END SUBROUTINE IRANDOMSELECT

    SUBROUTINE SHIFTZERO(COORDS,NATMS,ATM)
      ! SHIFT ENTIRE MOLECULE SO THAT ATOM ATM IS AT THE ORIGIN
      ! NATMS IS THE TOTAL NUMBER OF ATOMS

      IMPLICIT NONE
      INTEGER, INTENT(IN) :: NATMS, ATM
      DOUBLE PRECISION, INTENT(INOUT) :: COORDS(3*NATMS)
      DOUBLE PRECISION :: SHIFTS(3)
      INTEGER :: A, C

      SHIFTS(1:3) = COORDS(3*(ATM-1)+1:3*(ATM-1)+3)
      DO A = 1,NATMS
         DO C = 1,3
            COORDS(3*(A-1)+C) = COORDS(3*(A-1)+C) - SHIFTS(C)
         ENDDO
      ENDDO
    END SUBROUTINE SHIFTZERO

    SUBROUTINE ROTATEZERO(COORDS, NATMS, ATM, RAXIS, ZAXIS)
      ! ROTATE THE MOLECULE AROUND THE RAXIS OF 
      ! ATOM NUMBER ATM SO AS TO ZERO THE ZAXIS DIMENSION OF ATM
      ! RAXIS AND ZAXIS MUST BE 1,2, OR 3 AND NOT EQUAL
      ! NATMS IS THE TOTAL NUMBER OF ATOMS
      ! COORDP IS A POINTER TO AN ARRAY OF DIMENSION 3*NATMS

      IMPLICIT NONE
      INTEGER, INTENT(IN) :: NATMS, ATM, RAXIS, ZAXIS
      DOUBLE PRECISION, INTENT(INOUT) :: COORDS(3*NATMS)
      INTEGER :: XAXIS, A
      DOUBLE PRECISION :: CT, ST, THETA, XX, YY
      COMPLEX (KIND=KIND(1.0D0)) :: DUMMYC, DUMMY1, DUMMY2

      IF (RAXIS.EQ.ZAXIS.OR.(RAXIS.LT.1.OR.RAXIS.GT.3) &
           & .OR.(ZAXIS.LT.1.OR.ZAXIS.GT.3)) THEN
         PRINT*, 'RAXIS AND ZAXIS MUST BE BTWN 1 AND 3 AND &
              & CANNOT BE THE SAME IN ROTATETOZ!', RAXIS, ZAXIS
         STOP
      ENDIF

      DO XAXIS = 1,3
         IF (XAXIS.NE.RAXIS.AND.XAXIS.NE.ZAXIS) EXIT
      ENDDO
      DUMMY1 = COORDS(3*(ATM-1)+XAXIS)
      DUMMY2 = COORDS(3*(ATM-1)+ZAXIS)
      DUMMYC = LOG(DUMMY1 + DUMMY2*CMPLXI)

      THETA = -AIMAG(DUMMYC)
      CT = COS(THETA); ST = SIN(THETA)

      DO A = 1,NATMS
         XX = COORDS(3*(A-1)+XAXIS); YY = COORDS(3*(A-1)+ZAXIS)
         COORDS(3*(A-1)+XAXIS) = CT*XX-ST*YY
         COORDS(3*(A-1)+ZAXIS) = ST*XX+CT*YY
      ENDDO
    END SUBROUTINE ROTATEZERO

    SUBROUTINE ROTATE(COORDS, THETA, AXIS)
      ! ROTATE A GIVEN POINT IN 3D SPACE AROUND A GIVEN AXIS (1,2,OR 3)
      ! BY AN ANGLE THETA (IN RADIANS)
      ! RETURN RESULT AS OUTCOORDS

      IMPLICIT NONE
      DOUBLE PRECISION, INTENT(INOUT) :: COORDS(3)
      DOUBLE PRECISION, INTENT(IN) :: THETA
      INTEGER, INTENT(IN) :: AXIS
      DOUBLE PRECISION :: CT, ST, X, Y, Z

      CT = DCOS(THETA)
      ST = DSIN(THETA)

      X = COORDS(1); Y = COORDS(2); Z = COORDS(3)
      IF (AXIS.EQ.1) THEN
         COORDS(2) = CT*Y-ST*Z
         COORDS(3) = ST*Y+CT*Z
      ELSE IF (AXIS.EQ.2) THEN
         COORDS(1) = CT*X-ST*Z
         COORDS(3) = ST*X+CT*Z
      ELSE IF (AXIS.EQ.3) THEN
         COORDS(1) = CT*X-ST*Y
         COORDS(2) = ST*X+CT*Y
      ELSE
         PRINT*, 'ERROR: IN ROTATE, AXIS MUST BE 1,2,OR3', AXIS
         STOP
      ENDIF
      RETURN
    END SUBROUTINE ROTATE

    SUBROUTINE ROTATEANGLAXIS(X,THETA,V)
      ! ROTATE 3D VECTOR X BY AN ANGLE THETA AROUND VECTOR V
      ! USE RODRIGUES' ROTATION FORMULA

      IMPLICIT NONE
      DOUBLE PRECISION, INTENT(INOUT) :: V(3)
      DOUBLE PRECISION, INTENT(IN) :: THETA
      DOUBLE PRECISION, INTENT(INOUT) :: X(3)
      DOUBLE PRECISION :: DUMMY1(3), DUMMY2

      CALL NORMALIZE(V)

      CALL CROSS_PRODUCT(V,X,DUMMY1)
      DUMMY2 = DOT_PRODUCT(V,X)*(1-COS(THETA))

      X(:) = X(:)*COS(THETA) + DUMMY1(:)*SIN(THETA) + DUMMY2*V(:)
      
      RETURN
    END SUBROUTINE ROTATEANGLAXIS

    SUBROUTINE LEGZO(N,X,W)
      ! COPIED FROM: HTTP://JIN.ECE.UIUC.EDU/, MLEGZO.FOR
      ! WRITTEN BY JIAN-MING JIN
      !
      !       =========================================================
      !       PURPOSE : COMPUTE THE ZEROS OF LEGENDRE POLYNOMIAL PN(X)
      !                 IN THE INTERVAL [-1,1], AND THE CORRESPONDING
      !                 WEIGHTING COEFFICIENTS FOR GAUSS-LEGENDRE
      !                 INTEGRATION
      !       INPUT :   N    --- ORDER OF THE LEGENDRE POLYNOMIAL
      !       OUTPUT:   X(N) --- ZEROS OF THE LEGENDRE POLYNOMIAL
      !                 W(N) --- CORRESPONDING WEIGHTING COEFFICIENTS
      !       =========================================================
      !
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER :: N, N0,NR,I,J,K
      DOUBLE PRECISION ::  X(N),W(N)
      N0=(N+1)/2
      DO 45 NR=1,N0
         Z=DCOS(3.1415926D0*(NR-0.25D0)/N)
10       Z0=Z
         P=1.0D0
         DO 15 I=1,NR-1
15          P=P*(Z-X(I))
            F0=1.0D0
            IF (NR.EQ.N0.AND.N.NE.2*INT(N/2)) Z=0.0D0
            F1=Z
            DO 20 K=2,N
               PF=(2.0D0-1.0D0/K)*Z*F1-(1.0D0-1.0D0/K)*F0
               PD=K*(F1-Z*PF)/(1.0D0-Z*Z)
               F0=F1
20             F1=PF
               IF (Z.EQ.0.0) GO TO 40
               FD=PF/P
               Q=0.0D0
               DO 35 I=1,NR
                  WP=1.0D0
                  DO 30 J=1,NR
                     IF (J.NE.I) WP=WP*(Z-X(J))
30                   CONTINUE
35                   Q=Q+WP
                     GD=(PD-Q*FD)/P
                     Z=Z-FD/GD
                     IF (DABS(Z-Z0).GT.DABS(Z)*1.0D-15) GO TO 10
40                   X(NR)=Z
                     X(N+1-NR)=-Z
                     W(NR)=2.0D0/((1.0D0-Z*Z)*PD*PD)
45                   W(N+1-NR)=W(NR)
                     RETURN
                   END SUBROUTINE LEGZO

 END MODULE SPFUNCTS

