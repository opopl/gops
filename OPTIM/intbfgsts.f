C   OPTIM: A PROGRAM FOR OPTIMIZING GEOMETRIES AND CALCULATING REACTION PATHWAYS
C   COPYRIGHT (C) 1999-2006 DAVID J. WALES
C   THIS FILE IS PART OF OPTIM.
C
C   OPTIM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C   IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C   THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C   (AT YOUR OPTION) ANY LATER VERSION.
C
C   OPTIM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
C   BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
C   GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C   YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C   ALONG WITH THIS PROGRAM; IF NOT, WRITE TO THE FREE SOFTWARE
C   FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330, BOSTON, MA  02111-1307  USA
C
C***********************************************************************
C
C  THIS SUBROUTINE IS DESIGNED TO PERFORM A HYBRID EIGENVECTOR-FOLLOWING/GRADIENT
C  MINIMIZATION OPTIMIZATION FOR LARGE SYSTEMS WHERE WE DO NOT WANT TO 
C  DIAGONALIZE THE WHOLE HESSIAN.
C  THIS SUBROUTINE (AS OPPOSED TO BFGSTS) WORKS IN INTERNAL COORDINATES WITH THE 
C  UNRES POTENTIAL. JMC MARCH 2003
C
C***********************************************************************
C
      SUBROUTINE INTBFGSTS(ITMAX,COORDS,ENERGY,GRAD,MFLAG,RMS,EVALMIN,EVALMAX,VECS,ITER,POTCALL,PTEST)
      USE COMMONS
      USE KEY
      USE VECCK
      USE ZWK
      USE MODUNRES
      USE MODHESS
      USE PORFUNCS
      IMPLICIT NONE

C     INCLUDE 'LPARAMS.H'
      INTEGER J1, J2, J4, INEG, J, ITER, NS, I, K1, NBFGS, ITMAX, FRAME, ITDONE
      DOUBLE PRECISION SCRATCH(6*NATOMS),GRAD(3*NATOMS),ENERGY,COORDS(3*NATOMS),SUM,AVG,FOBNEW,DUMMY,
     1                 RMS,FOB,PSTEP,AX,BX,TOL,PSTEPNEW,DPRAND,FIXDIR(3*NATOMS),TEMPA(9*NATOMS),
     2                 EVALMAX, EVALMIN, STPMAG,COORDSN(3*NATOMS),VECSP(3*NATOMS),
     3                 XP1,XP2,E1,E2,DELE,SCALE,EPER,EOLD,RMS2,VECS(3*NATOMS),SOVER,EREAL,XRAT(3*NATOMS),
     4                 XFOB(3*NATOMS),STEP(3*NATOMS),XPSTEP(3*NATOMS),CSTEP(3*NATOMS),PFOB(3*NATOMS),PCSTEP(3*NATOMS),
     5                 AV(6),SSTPMAG,RAT1,RAT2,TEMP,LP1,LP2,LP,VECL(3*NATOMS)
C     EXTERNAL OP, IOVECT
      CHARACTER(LEN=80) :: FNAME
      LOGICAL MFLAG, AWAY, LINE, PVFLAG, RESET, STEST, POTCALL, PTEST, FIXDSAVE
      COMMON /PVF/ PVFLAG
      LOGICAL CONNECTT, DUMPPATH, READPATH, CALCRATES, STOPFIRST, CONVERGED
      INTEGER NCONNECT
      DOUBLE PRECISION TEMPERATURE, HRED
      COMMON /CONN/ STOPFIRST, CONNECTT, NCONNECT, DUMPPATH, READPATH, CALCRATES, TEMPERATURE, HRED
      DOUBLE PRECISION TMPINT(NINTS) 
C     COMMON /FORPATH/ INTSTEP ! JMC FOR USE IN PATH, NOW IN MODUNRES

C
C  ASSIGN ENOUGH MEMORY TO WORK FOR A BLOCKSIZE OF 32 TO BE POSSIBLE.
C  THIS IS FOR DSYEVR.
C
      INTEGER ILWORK, LWORK, NFOUND, ISUPPZ(2*3*NATOMS)
      INTEGER IWORK(33*3*NATOMS), INFO, ISTAT
      DOUBLE PRECISION WORK(33*3*NATOMS), ABSTOL, DIAG(3*NATOMS), DLAMCH
      LOGICAL KNOWE, KNOWG, KNOWH
      COMMON /KNOWN/ KNOWE, KNOWG, KNOWH
      SAVE

      LWORK=33*3*NATOMS
      ILWORK=33*3*NATOMS

      IF (.NOT.NOHESS) THEN
         WRITE(*,'(A)') '** WARNING - INTMIN ONLY WORKS WITH NOHESS AT PRESENT!!'
         WRITE(*,'(A)') '** STOPPING...'
         STOP
      ENDIF

      IF (FIXD) THEN
          WRITE(*,'(A)') '** WARNING - INTMIN AND FIXD SET: INCOMPATIBLE, THEREFORE STOPPING.'
          STOP
      ENDIF

      IF ((ZSYM(1)(1:1).EQ.'W').AND.(.NOT.BFGSSTEP)) THEN
         PRINT*,'BFGSTS PROCEDURES HAVE NOT BEEN PROGRAMMED FOR TIP POTENTIALS'
         STOP
      ENDIF
      FIXDSAVE=FIXD
      IF ((HINDEX.GT.1).AND.(.NOT.NOIT)) THEN
         WRITE(*,'(A)') 'TO SEARCH FOR HIGHER INDEX SADDLES YOU MUST USE NOIT OR SEARCH 2'
         STOP
      ENDIF

      DO J2=1,NRES
         C(1,J2)=COORDS(6*(J2-1)+1)
         C(2,J2)=COORDS(6*(J2-1)+2)
         C(3,J2)=COORDS(6*(J2-1)+3)
         C(1,J2+NRES)=COORDS(6*(J2-1)+4)
         C(2,J2+NRES)=COORDS(6*(J2-1)+5)
         C(3,J2+NRES)=COORDS(6*(J2-1)+6)
      END DO
      CALL UPDATEDC
!CALL INT_FROM_CART(.TRUE.,.FALSE.)
!CALL CHAINBUILD

      ITER=1
      FRAME=1
C
C  IF DUMPV IS .TRUE. THEN VECTOR.DUMP IS ALREADY OPEN AND ATTACHED TO UNIT 44.
C  SGI COMPILER WON;T ALLOW US TO ATTACH IT TO ANOTHER UNIT.
C  VECTOR.DUMP COULD CONTAIN MULTIPLE DUMPS FOR MORE THAN THE LAST STEP, SO WE
C  HAVE TO MAKE SURE WE GET THE RESULTS FOR THE LAST STEP.
C  
      IF (READV.AND.(ITER.EQ.1)) THEN
         IF (DUMPV) THEN
            REWIND(44)
211         READ(44,*,END=111) EVALMIN
            READ(44,*) (VECS(J1),J1=1,NINTS)
            GOTO 211
111         CONTINUE
         ELSE
            IF (FILTH.EQ.0) THEN
               FNAME='VECTOR.DUMP'
            ELSE
               WRITE(FNAME,'(A)') 'VECTOR.DUMP.'//TRIM(ADJUSTL(FILTHSTR))
            ENDIF

            OPEN(UNIT=45,FILE=FNAME,STATUS='OLD')
20          READ(45,*,END=10) EVALMIN
C JMC REMEMBER VECTOR.DUMP CONTAINS EIGENVECTOR IN INTERNAL COORDINATES...
            READ(45,*) (VECS(J1),J1=1,NINTS)
            GOTO 20
10          CLOSE(45)
         ENDIF
         WRITE(*,'(A,F20.10)') ' REACTION VECTOR READ SUCCESSFULLY. EIGENVALUE=   ',EVALMIN
         NS=100
      ENDIF

      STEST=.TRUE.
      IF (NOHESS) STEST=.FALSE.
      IF (READV.AND.(ITER.EQ.1)) STEST=.FALSE.
90    IF (PTEST) PRINT*
      NUP=HINDEX
      IF ((.NOT.BFGSSTEP).AND.PTEST) WRITE(*,11) ITER
11          FORMAT (' INTBFGSTS> BEGINNING OF OPTIMIZATION CYCLE ', I4,'.',/
     1              ' ------------------------------------------')
      FIXIMAGE=.FALSE.
      IF ((FIXAFTER.GT.0).AND.(ITER.GT.FIXAFTER)) FIXIMAGE=.TRUE.
      IF (POTCALL) THEN
         IF (PV.AND.(.NOT.BFGSSTEP)) THEN
            IF (.NOT.KNOWE) CALL POTENTIAL(COORDS,ENERGY,GRAD,.FALSE.,.FALSE.,RMS,.FALSE.,.FALSE.)
            PVFLAG=.FALSE.
            CALL PVOPT(COORDS,ENERGY,GRAD)
         ENDIF
         IF ((.NOT.KNOWG).OR.(STEST.AND.(.NOT.KNOWH))) CALL POTENTIAL(COORDS,ENERGY,GRAD,.TRUE.,STEST,RMS,PTEST,.FALSE.)
      ENDIF
      CALL DUMPP(COORDS,ENERGY)
      IF ((.NOT.VARIABLES).AND.NOIT.AND.STEST) CALL SHIFTH(COORDS,.TRUE.,NOPT,NATOMS,ATMASS)

C     DO J1=1,NOPT
C        VECSP(J1)=0.0D0  ! OTHERWISE VECSP IS NOT INITIALISED
C     ENDDO

C JMC PUT INTERNALS INTO COORDS ARRAY HERE IF WE'VE COME HERE FROM PATH, AS WE DON'T GO THROUGH 
C THE DO LOOP BELOW WHERE THIS WOULD BE DONE NORMALLY.
      IF (BFGSSTEP) CALL GEOM_TO_VAR(NINTS,COORDS(1:NINTS))

      IF (.NOT.((READV.AND.BFGSSTEP).OR.(.NOT.POTCALL))) THEN
         IF (FIXD.AND.(ITER.EQ.1)) THEN
            IF (CONNECTT) THEN
               DO J1=1,NOPT
                  FIXDIR(J1)=VECS(J1)
               ENDDO
            ELSE
               DO J1=1,NOPT
                  DUMMY=2*(DPRAND()-0.5D0)
                  FIXDIR(J1)=DUMMY
               ENDDO
            ENDIF
            CALL ORTHOGOPT(FIXDIR,COORDS,.TRUE.)
            IF (.TRUE.) CALL HSMOVE(COORDS,COORDSN,FIXDIR,PSTEP,PTEST)
            EVALMIN=1.0D0
         ELSE IF (FIXD) THEN
            CALL ORTHOGOPT(FIXDIR,COORDS,.TRUE.)
            IF (.TRUE.) CALL HSMOVE(COORDS,COORDSN,FIXDIR,PSTEP,PTEST)
            EVALMIN=1.0D0
         ENDIF
         IF (.NOT.NOHESS) THEN 
            IF (.NOT.NOIT) THEN
!              CALL ITEIG(ITER,COORDS,VECS,EVALMIN,EVALMAX,NS,SOVER,PTEST,VECL,CONVERGED)
               PRINT'(A)',' ITERATIVE SCHEME FOR EIGENVALUE NOT AVAILABLE WITH HESSIAN IN INTERNALS'
               STOP
            ELSE
               ABSTOL=DLAMCH('SAFE  MINIMUM')
               IF (ITER.GT.1) THEN
                  DO J1=1,NOPT
                     VECSP(J1)=VECS(J1)
                  ENDDO
               ENDIF
               CALL DSYEVR('V','I','U',NOPT,HESS,SIZE(HESS,1),0.0D0,1.0D0,1,HINDEX,ABSTOL,NFOUND,DIAG,ZWORK,3*NATOMS,ISUPPZ,WORK,
     1                        LWORK, IWORK, ILWORK, INFO )
               IF (INFO.NE.0) PRINT*,'WARNING - INFO=',INFO,' IN DSYEVR'
C              PRINT*,'OPTIMAL AND ACTUAL VALUES OF LWORK=',WORK(1),LWORK
C              PRINT*,'OPTIMAL AND ACTUAL VALUES OF ILWORK=',IWORK(1),ILWORK
               EVALMIN=DIAG(1)
               SOVER=0.0D0
               DO J1=1,NOPT
                  VECS(J1)=ZWORK(J1,1)
                  IF (ITER.GT.1) SOVER=SOVER+VECS(J1)*VECSP(J1)
               ENDDO
               IF (PTEST) WRITE(*,'(A,F15.7,A,F15.7)') ' SMALLEST EIGENVALUE=',EVALMIN,' OVERLAP WITH PREVIOUS VECTOR=',SOVER

               DO I=1,NOPT
                  SCRATCH(I) = COORDS(I)
               ENDDO
               DO I=1,HINDEX
                  XFOB(I)=0.0D0
                  DO J = 1,NOPT
                     XFOB(I)=XFOB(I)+GRAD(J)*ZWORK(J,I)
                  ENDDO
               ENDDO
C
C  FIND THE VECTOR OF STPMAX VALUES BY COMPARING PREDICTED AND
C  ACTUAL SECOND DERIVATIVES FOR EACH EIGENVECTOR.
C
               IF ((ITER.GT.1).AND.(ISTCRT.EQ.10)) THEN
                  DO J1=1,NOPT
                     TEMPA(J1)=STPMAX(J1)
                  ENDDO
                  K1=0
                  DO J1=1,HINDEX
                     XRAT(J1)=0.0D0
                     K1=K1+1
                     IF (DABS(XPSTEP(K1)).GT.1.0D-40) THEN
C
C  ALLOW FOR POSSIBLE PHASE CHANGE IN THE EIGENVECTOR. JUST TAKE THE SMALLER VALUE.
C
                        RAT1=DABS(( XFOB(J1)-PFOB(K1))/(DIAG(J1)*XPSTEP(K1))-1.0D0)
                        RAT2=DABS((-XFOB(J1)-PFOB(K1))/(DIAG(J1)*XPSTEP(K1))-1.0D0)
                        XRAT(J1)=MIN(RAT1,RAT2)
C                       WRITE(*,'(A,2I4,5E15.7)') 'J1,K1,FOB,PFOB,PSTEP,RAT1,DIAG=', J1,K1,XFOB(J1),PFOB(K1),PSTEP(K1),RAT1,DIAG(J1)
                        IF (XRAT(J1).GT.TRAD) THEN
                           STPMAX(J1)=MAX(TEMPA(K1)/1.11D0,MINMAX)
                        ELSE
                           IF (MASST) THEN
                              SUM=0
                              DO J2=1,NATOMS
                                 SUM=SUM+ATMASS(J2)
                              ENDDO
                              AVG=SQRT(SUM/NATOMS)
C                             PRINT *,'THE AVERAGE IS',AVG
                              STPMAX(J1)=MIN(MAX(TEMPA(K1)*1.09D0,MINMAX),AVG*MAXMAX)
                           ELSE
                              STPMAX(J1)=MIN(MAX(TEMPA(K1)*1.09D0,MINMAX),MAXMAX)
                           ENDIF
                        ENDIF
                     ELSE
                        STPMAX(J1)=MAX(TEMPA(K1),MINMAX)
                     ENDIF
                  ENDDO
               ENDIF
               TEMP=-1.0D0
            ENDIF
C
C  DO NOT USE.
C
C           CALL ITEIGN(ITER,COORDS,VECS,EVALMIN,EVALMAX,PTEST)
C
C  LANCZOS ROUTINE - DOES WORK BUT SEEMS TO BE SLOWER? FOR NFIG=3 IT IS ONLY
C  A BIT SLOWER THAN ITEIG WITH CEIG=0.01.
C
C           NVAL=-10
C           ANV=ABS(NVAL)
C           NFIG=3
C           NPERM=0
C           IF (ITER.GT.1) NPERM=1
C           MAXOP=NEVS
C           NBLOCK=1
C           IF ((ANV.GT.MANV).OR.(NBLOCK.GT.MAXBLOCK)) THEN
C              WRITE(*,'(A)') ' TOO MANY EIGENVECTORS OR TOO LARGE A LANCZOS BLOCKSIZE REQUESTED'
C              STOP
C           ENDIF
C
C           CALL DNLASO(HESS, Q, NATOMS, OP, IOVECT, 3*MXATMS, NVAL, NFIG, NPERM,
C    *                  NMVAL, VAL, NMVEC, LVEC, NBLOCK, MAXOP, MAXJ, LWORK,
C    *                  IND, IERR)
C           WRITE(*,'(I3,A,100F20.10)') NPERM,' EIGENVECTORS DETERMINED: ',(VAL(J1,1),J1=1,NPERM)
C           IF (IERR.NE.0) THEN
C              WRITE(*,'(A,I4)') 'LANCZOS CALL COMPLETED WITH ERROR CODE ',IERR
C           ELSE
C              WRITE(*,'(A,F20.10)') ' SMALLEST EIGENVALUE=',VAL(1,1)
C           ENDIF

C           EVALMIN=VAL(1,1)
C           DO J1=1,NOPT
C              VECS(J1)=LVEC(J1,1)
C           ENDDO
         ELSE
C JMC
C PUT INTERNALS INTO COORDS HERE.  COORDS ARRAY SHOULD BE UNCHANGED ON BEING PASSED THROUGH BEIG.
C SINCE WE'RE PASSING THE ENERGY CORRESPONDING TO THESE COORDS, I'M ASSUMING THAT THE UNRES C AND 
C GEOMETRY ARRAYS HAVE ALREADY BEEN UPDATED CORRECTLY (IN MYLBFGS AT THE END OF EACH 
C ITERATION AND BEFORE THIS ROUTINE IS CALLED - 18/10/03 IN FACT AT THE START OF THIS SUBROUTINE...)
!CALL GEOM_TO_VAR(NINTS,COORDS(1:NINTS))
            CALL INTBEIG(ITER,COORDS,ENERGY,VECS,EVALMIN,NS,SOVER,PTEST,CONVERGED)
C
C  THE FOLLOWING TWO ROUTINES ARE ALSO OBSOLETE.
C
C           CALL POWEIG(ITER,COORDS,ENERGY,VECS,EVALMIN)
C           CALL MCEIG(ITER,COORDS,ENERGY,VECS,EVALMIN)
         ENDIF
      ENDIF

      IF ((EVALMIN.LT.0.0D0).AND.FIXD) THEN
         IF (PTEST) WRITE(*,'(A)') ' NEGATIVE EIGENVALUE, CHANGING TO HYBRID EF'
         FIXD=.FALSE.
         CALL VECNORM(VECS,NOPT)
         DO J1=1,NOPT
            ZWORK(J1,1)=VECS(J1)
         ENDDO
      ELSE IF (FIXD) THEN
C     IF (FIXD) THEN
         DO J1=1,NOPT
            ZWORK(J1,1)=FIXDIR(J1)
            VECS(J1)=FIXDIR(J1)
         ENDDO
      ELSE ! JMC THIS IS THE ONLY OPTION THAT WORKS HERE...
         CALL VECNORM(VECS(1:NINTS),NINTS) ! JMC
         DUMMY=0.0D0
         DO J1=1,NINTS
            ZWORK(J1,1)=VECS(J1)
            DUMMY=DUMMY+VECS(J1)**2
         ENDDO
      ENDIF
C
C  DUMP THE SMALLEST NON-ZERO EIGENVALUE AND EIGENVECTOR 
C  IN FILE VECTOR.DUMP, IF REQUIRED.
C
      IF (DUMPV) THEN
         IF (.NOT.ALLSTEPS) REWIND(44)
         WRITE(44,'(E20.10)') EVALMIN
         WRITE(44,'(3F20.10)') (ZWORK(J1,1),J1=1,NINTS)
      ENDIF
C
C  TAKE AN EIGENVECTOR-FOLLOWING STEP UPHILL ALONG THE DIRECTION CORRESPONDING
C  TO THE SMALLEST NON-ZERO EIGENVALUE. THEN DO A LINE MINIMIZATION ALONG THE
C  GRADIENT VECTOR WITH COMPONENT ALONG THE UPHILL DIRECTION PROJECTED OUT. 
C  DO WE NEED A NEW GRADIENT VECTOR OR WILL THE OLD ONE FROM THE POINT BEFORE
C  STEPPING UPHILL DO?
C

      FOB=0.0D0
      DO J1=1,NINTS
         FOB=FOB+ZWORK(J1,1)*GRAD(J1)
      ENDDO
      XFOB(1)=FOB
      IF (FIXD) GOTO 666
      IF (HINDEX.LE.1) THEN
         IF (EVALMIN.LT.0.0D0) THEN
C           PRINT*,'THERE IS AT LEAST ONE NEGATIVE EIGENVALUE'
            INEG=1
         ELSE
C           PRINT*,'THERE ARE NO NEGATIVE EIGENVALUES'
            INEG=0
         ENDIF
      ELSE
         INEG=0
         DO J1=1,HINDEX
            IF (DIAG(J1).LT.0.0D0) INEG=INEG+1
         ENDDO
         WRITE(*,'(A,I5,A)') ' THERE ARE AT LEAST ',INEG,' NEGATIVE HESSIAN EIGENVALUES'
      ENDIF
C
C  TAKE A STEP AWAY FROM A STATIONARY POINT ALONG THE APPROPRIATE
C  HESSIAN EIGENVECTOR. THIS ENABLES US TO START FROM CONVERGED MINIMA.
C  DISTINGUISH THE CASE WHERE WE WANT TO TAKE A VERY SMALL STEP AWAY
C  FROM A TRANSITION STATE FROM OTHERS WHERE WE WANT A BIG DISPLACEMENT
C  TO GET UNSTUCK. 
C
      AWAY=.FALSE.
      IF ((RMS.LT.PUSHCUT).AND.(.NOT.FIXD)) THEN
         IF ((INEG.NE.HINDEX).AND.CONVERGED) THEN
            IF (HINDEX.LE.1) THEN
               IF ((ITER.EQ.1).AND.(INEG.EQ.0)) THEN
                  IF (PTEST) THEN
                     IF (IVEC.GE.0) PRINT*,'STEPPING AWAY FROM MINIMUM ALONG SOFTEST MODE + DIRECTION'
                     IF (IVEC.LT.0) PRINT*,'STEPPING AWAY FROM MINIMUM ALONG SOFTEST MODE - DIRECTION'
                  ENDIF
                  AWAY=.TRUE.
               ELSE IF (MOD(ITER-1,4).EQ.0) THEN
                  PRINT*,'STEPPING AWAY FROM SOLUTION OF WRONG INDEX'
                  IF (PUSHOFF.EQ.0.0D0) THEN
                     FOB=STPMAX(1)
                  ELSE 
                     FOB=PUSHOFF
                  ENDIF
               ENDIF
            ELSE
               DO J1=1,HINDEX
                  IF (DIAG(J1).GT.0.0D0) THEN
                     WRITE(*,'(A,I6)') 'STEPPING AWAY FROM SOLUTION OF WRONG INDEX ALONG EIGENVECTOR ',J1
                     IF (PUSHOFF.EQ.0.0D0) THEN
                        XFOB(J1)=STPMAX(J1)
                     ELSE
                        XFOB(J1)=PUSHOFF
                     ENDIF
                  ENDIF
               ENDDO
            ENDIF
         ENDIF
      ENDIF
      IF (BFGSSTEP) THEN
         IF (INEG.EQ.0) THEN
            PRINT*,'****WARNING - BFGSSTEP SET FOR A MINIMUM'
         ELSE
            IF (PTEST) THEN
               IF (IVEC.GE.0) PRINT*,'STEPPING AWAY FROM SADDLE ALONG SOFTEST MODE + DIRECTION'
               IF (IVEC.LT.0) PRINT*,'STEPPING AWAY FROM SADDLE ALONG SOFTEST MODE - DIRECTION'
            ENDIF
            AWAY=.TRUE.
         ENDIF
      ENDIF
C
C  EF DETERMINATION OF STEPS
C
      IF (HINDEX.LE.1) THEN
         XP1=DABS(EVALMIN)/2.0D0
         IF (MASST) THEN
            SUM=0
            DO J2=1,NATOMS
               SUM=SUM+ATMASS(J2)
            ENDDO
            AVG=SUM/NATOMS
            XP2=1.0D0 + 4.0D0*(FOB/EVALMIN)**2/AVG
         ELSE
            XP2=1.0D0 + 4.0D0*(FOB/EVALMIN)**2
         ENDIF
         XP1=-XP1*(1.0D0+DSQRT(XP2))
         PSTEP=-FOB/XP1
   
         IF (AWAY) THEN
            IF (PUSHOFF.NE.0.0D0) THEN
               PSTEP=PUSHOFF
            ELSE
               PSTEP=STPMAX(1)/1.0D1
            ENDIF
            IF (IVEC.LT.0) PSTEP=-PSTEP
         ENDIF
C        WRITE(*,'(A,F20.10)') ' UNSCALED STEP=',PSTEP
C
C  SCALE ACCORDING TO STEP SIZE IN EV BASIS:
C
         STPMAG=ABS(PSTEP)
         IF (.NOT.AWAY) THEN
            SCALE=MIN(STPMAX(1)/MAX(DABS(PSTEP),1D-10),1.0D0)
            PSTEP=SCALE*PSTEP
         ENDIF
      ELSE
         DO I=HINDEX,1,-1
            STEP(I)=0.0D0
            NZERO=0
            IF (DABS(DIAG(NZERO+1)/MAX(DABS(DIAG(I)),1.0D-10)).GT.TEMP) TEMP=DABS(DIAG(NZERO+1)/MAX(DABS(DIAG(I)),1.0D-10))
            LP1=DABS(DIAG(I))/2.0D0
            IF (MASST) THEN
               SUM=0
               DO J2=1,NATOMS
                  SUM=SUM+ATMASS(J2)
               ENDDO
               AVG=SUM/NATOMS
               LP2=1.0D0 + 4.0D0*((XFOB(I)/DIAG(I))**2)/AVG
            ELSE
               LP2=1.0D0 + 4.0D0*(XFOB(I)/DIAG(I))**2
            ENDIF
            LP=LP1*(1.0D0+DSQRT(LP2))
            WRITE(*,'(A,I4,A,4X,F19.10)') ' MODE ',I,' WILL BE SEARCHED UPHILL. EIGENVALUE=',DIAG(I)
            LP=-LP
            STEP(I)=-XFOB(I)/LP
         ENDDO
         DO J1=1,NOPT
            SCRATCH(NOPT+J1)=STEP(J1)
         ENDDO
C
C  CONVERT THE STEPS TO THE CARTESIAN RATHER THAN THE EV BASIS
C
         DO J=1,NOPT
            SCRATCH(J+NOPT)=0.0D0
            DO I=1,HINDEX
               SCRATCH(J+NOPT)=SCRATCH(J+NOPT)+STEP(I)*ZWORK(J,I)
            ENDDO
         ENDDO
C
C  SCALE ACCORDING TO STEP SIZE IN EV BASIS:
C
C JMC         CALL VSTAT(STEP(1),AV,NOPT,3*NATOMS)
C WILL ALMOST NEVER GET TO HERE IN MY RUNS, SO PROBABLY NOT WORTH WORRYING ABOUT, BUT THINK SHOULD HAVE THE DIMENSION OF 
C THE ARRAYS AS 1...
         CALL VSTAT(STEP(1),AV,1,1)
         STPMAG=MAX(AV(1),1D-10)
         DO J1=1,NOPT
            SCALE=MIN(STPMAX(J1)/MAX(DABS(STEP(J1)),1D-10),1.0D0)
            STEP(J1)=SCALE*STEP(J1)
         ENDDO
C JMC         CALL VSTAT(STEP(1),AV,NOPT,3*NATOMS)
C WILL ALMOST NEVER GET TO HERE IN MY RUNS, SO PROBABLY NOT WORTH WORRYING ABOUT, BUT THINK SHOULD HAVE THE DIMENSION OF 
C THE ARRAYS AS 1...
         CALL VSTAT(STEP(1),AV,1,1)
         SSTPMAG=MAX(AV(1),1D-10)
         SCALE=1.0D0
         E1=0.0D0
         DO J1=1,NOPT
            E1=E1+STEP(J1)*XFOB(J1)
         ENDDO
         E2=0.0D0
         DO J1=1,NOPT
            E2=E2+DIAG(J1)*STEP(J1)**2
         ENDDO
         E2=E2/2.0D0
         DELE=E1*SCALE+E2*SCALE**2
C JMC         CALL VADD(SCRATCH(1),SCRATCH(1),SCRATCH(NOPT+1),NOPT,1)
C WILL ALMOST NEVER GET TO HERE IN MY RUNS, SO PROBABLY NOT WORTH WORRYING ABOUT, BUT THINK SHOULD HAVE THE DIMENSION OF 
C THE ARRAYS AS 1...
         CALL VADD(SCRATCH(1),SCRATCH(1),SCRATCH(NINTS+1),1,1)

         IF (EFSTEPST.AND.(MOD(ITER-1,EFSTEPS).EQ.0)) THEN
            DO I=NZERO+1,HINDEX
                WRITE(*,360) I, STEP(I)
360             FORMAT(' UNSCALED STEP FOR MODE ',I3,'=',F20.10)
            ENDDO
         ENDIF
      ENDIF
C
C  USE MAXMAX UNTIL WE HAVE A NEGATIVE EIGENVALUE. BE SURE TO
C  STEP UPHILL!
C
      LINE=.FALSE.
      IF (CONVERGED) THEN
         IF (((EVALMIN.GT.0.0D0).OR.FIXD).AND.(HINDEX.LE.1)) THEN
            PSTEP=FOB*MAXMAX/ABS(FOB)
         ELSE IF (HINDEX.GT.1) THEN
            DO J1=1,HINDEX
               IF (DIAG(J1).GT.0.0D0) STEP(J1)=XFOB(J1)*MAXMAX/ABS(XFOB(J1))
            ENDDO
         ENDIF
      ENDIF

      IF (HINDEX.LE.1) THEN
         E1=PSTEP*FOB
         E2=EVALMIN*PSTEP**2/2.0D0
         DELE=E1+E2
      ENDIF
C
C  REGENERATE FULL Q VECTOR. 
C
666   IF (.NOT.FIXD) THEN
         IF (HINDEX.LE.1) THEN
            DO J=1,NINTS
               COORDS(J)=COORDS(J)+PSTEP*ZWORK(J,1)
               INTSTEP(J)=PSTEP*ZWORK(J,1) ! JMC FOR USE IN PATH
            ENDDO
         ELSE
C
C  UNPACK SCRATCH(1:NOPT) TO REGENERATE FULL Q VECTOR.
C  CSTEP CONTAINS THE STEP IN THE CARTESIAN BASIS.
C
            DO J=1,NOPT
               COORDS(J)=SCRATCH(J)
               CSTEP(J)=SCRATCH(NOPT+J)
            ENDDO
         ENDIF
      ELSE
         DO J=1,NOPT
            COORDS(J)=COORDSN(J)
         ENDDO
      ENDIF
      KNOWE=.FALSE.
      KNOWG=.FALSE.
      KNOWH=.FALSE.

      IF (.NOT.LINE) THEN
         EOLD=ENERGY
         IF (.NOT.BFGSSTEP) THEN
C
C  OPTIMISING THE BOX LENGTHS HERE WOULD CHANGE THE CRITICAL EIGENVALUE AND
C  EIGENVECTOR.
C
C           IF (PV) THEN
C              CALL POTENTIAL(COORDS,ENERGY,GRAD,.FALSE.,.FALSE.,RMS,.FALSE.,.FALSE.)
C              PVFLAG=.FALSE.
C              CALL PVOPT(COORDS,ENERGY,GRAD)
C           ENDIF
C
C JMC UPDATE CARTESIANS NOW
!CALL VAR_TO_GEOM(NINTS,COORDS(1:NINTS))
!           TMPINT=COORDS(1:NINTS)
!           CALL VAR_TO_GEOM(NINTS,TMPINT)
!CALL CHAINBUILD
C JMC ADDED THIS DO LOOP TO PUT CARTESIANS INTO COORDS FOR DUMPP
            DO J4=1,NRES
               COORDS(6*(J4-1)+1)=C(1,J4)
               COORDS(6*(J4-1)+2)=C(2,J4)
               COORDS(6*(J4-1)+3)=C(3,J4)
               COORDS(6*(J4-1)+4)=C(1,J4+NRES)
               COORDS(6*(J4-1)+5)=C(2,J4+NRES)
               COORDS(6*(J4-1)+6)=C(3,J4+NRES)
            END DO

            CALL POTENTIAL(COORDS,ENERGY,GRAD,.TRUE.,.FALSE.,RMS,.FALSE.,.FALSE.)
            CALL DUMPP(COORDS,ENERGY)
!           COORDS(1:NINTS)=TMPINT ! JMC PUT INTERNALS BACK INTO COORDS
         ENDIF
      ENDIF
      CALL FLUSH(6,ISTAT)

      FOBNEW=0.0D0
      DO J1=1,NINTS
         FOBNEW=FOBNEW+GRAD(J1)*ZWORK(J1,1)
      ENDDO
C
C  ONLY SCALE IF WE HAVE A -VE EIGENVALUE
C
      IF ((EOLD.NE.0.0D0).AND.(EVALMIN.LT.0.0D0).AND.(.NOT.FIXD)) THEN
         EPER=MIN(DABS(1.0D0-(FOBNEW-FOB)/(PSTEP*EVALMIN)),DABS(1.0D0-(-FOBNEW-FOB)/(PSTEP*EVALMIN)))
C        WRITE(*,'(A,4F20.10)') 'FOB,FOBNEW,PSTEP,EVALMIN=',FOB,FOBNEW,PSTEP,EVALMIN
C        WRITE(*,'(A,3F20.10)') 'EPER,EPER1,EPER2=',
C    1          EPER,DABS(1.0D0-(FOBNEW-FOB)/(PSTEP*EVALMIN)),DABS(1.0D0-(-FOBNEW-FOB)/(PSTEP*EVALMIN))
         IF (EPER.GT.TRAD) THEN
            STPMAX(1)=MAX(STPMAX(1)/1.1D0,MINMAX)
C           WRITE(*,'(A,E12.4,A,E12.4)') ' DECREASING ALLOWED EF STEP; TRUST RADIUS=',TRAD,' CALCULATED RATIO=',EPER
         ELSE
            STPMAX(1)=MIN(STPMAX(1)*1.1D0,MAXMAX)
C           WRITE(*,'(A,E12.4,A,E12.4)') ' INCREASING ALLOWED EF STEP; TRUST RADIUS=',TRAD,' CALCULATED RATIO=',EPER
         ENDIF
      ENDIF
C
C SUMMARIZE
C
C     IF (SUMMARYT.AND.(MOD(ITER-1,NSUMMARY).EQ.0)) THEN
         IF (PTEST) THEN
            IF (HINDEX.LE.1) THEN
               WRITE(*,30)
30             FORMAT(1X,79('-'))
               WRITE(*,40)
40             FORMAT(' VECTOR      GRADIENT        SECDER       STEP          MAX STEP    TRUST RATIO')
               WRITE(*,30)
               WRITE(*,50) 1,FOB,EVALMIN,PSTEP,STPMAX(1),EPER
50             FORMAT(1X,I4,1X,E15.6,1X,E15.6,1X,E13.6,1X,E12.6,1X,E15.6)
               WRITE(*,30)
            ELSE
               WRITE(*,30)
               WRITE(*,40)
               WRITE(*,30)
               DO I=HINDEX,1,-1
                  WRITE(*,50) I,XFOB(I),DIAG(I),STEP(I),STPMAX(I),XRAT(I)
               ENDDO
               WRITE(*,30)
            ENDIF
         ELSE IF (.NOT.BFGSSTEP) THEN
C           WRITE(*,'(A,I6,A,F20.10,A,F15.7,A,F12.4,A,F12.4)') 
C    1          ' CYCLE ',ITER,' E=',ENERGY,' RMS=',RMS,' EIGENVALUE=',EVALMIN,' OVERLAP=',SOVER
         ENDIF
C     ENDIF
C
      IF (BFGSSTEP) THEN
C JMC PUT CARTESIANS BACK INTO COORDS
!        TMPINT=COORDS(1:NINTS)
!        CALL VAR_TO_GEOM(NINTS,TMPINT)
!CALL VAR_TO_GEOM(NINTS,COORDS(1:NINTS))
!CALL CHAINBUILD
         DO J4=1,NRES
            COORDS(6*(J4-1)+1)=C(1,J4)
            COORDS(6*(J4-1)+2)=C(2,J4)
            COORDS(6*(J4-1)+3)=C(3,J4)
            COORDS(6*(J4-1)+4)=C(1,J4+NRES)
            COORDS(6*(J4-1)+5)=C(2,J4+NRES)
            COORDS(6*(J4-1)+6)=C(3,J4+NRES)
         END DO
         FIXIMAGE=.FALSE.
         FIXD=FIXDSAVE
         RETURN
      ENDIF
C
C  TANGENT SPACE MINIMIZATION NEXT.
C  UPHILL DIRECTION IS PROJECTED OUT OF THE STEP IN MYLBFGS
C  THE NEXT IF BLOCK ALLOWS FOR ZERO TANGENT SPACE STEPS IN THE INITIAL PHASE
C
      IF ((NBFGSMAX1.EQ.0).AND.((1.0D0-DABS(SOVER).GT.0.0001D0).OR.(INEG.EQ.0))) THEN
         FIXIMAGE=.FALSE.
         ITER=ITER+1
         FIXD=FIXDSAVE
         IF (ITER.GT.ITMAX) RETURN
         GOTO 90
      ENDIF

      IF (((1.0D0-DABS(SOVER).GT.0.0001D0).OR.(HINDEX.NE.INEG)).OR.(INEG.EQ.0).OR.(TWOENDS.AND.(ITER.EQ.1)).OR.(ITER.EQ.1)) THEN
          NBFGS=NBFGSMAX1
      ELSE
          NBFGS=NBFGSMAX2
      ENDIF

      RESET=.FALSE.
      IF (ITER.EQ.1) RESET=.TRUE.
      RMS2=RMS
C JMC PUT CARTESIANS BACK INTO COORDS
C JMC 13/7/04 NOW NO NEED, AS NOT PUTTING INTERNALS BACK INTO COORDS ABOVE.
!     TMPINT=COORDS(1:NINTS)
!     CALL VAR_TO_GEOM(NINTS,TMPINT)
C     CALL VAR_TO_GEOM(NINTS,COORDS(1:NINTS))
C     CALL CHAINBUILD
C     DO J4=1,NRES
C        COORDS(6*(J4-1)+1)=C(1,J4)
C        COORDS(6*(J4-1)+2)=C(2,J4)
C        COORDS(6*(J4-1)+3)=C(3,J4)
C        COORDS(6*(J4-1)+4)=C(1,J4+NRES)
C        COORDS(6*(J4-1)+5)=C(2,J4+NRES)
C        COORDS(6*(J4-1)+6)=C(3,J4+NRES)
C     END DO
      CALL MYLBFGS(NINTS,MUPDATE,COORDS,.FALSE.,GMAX,MFLAG,ENERGY,RMS2,EREAL,RMS,NBFGS,
     1             RESET,ITDONE,PTEST,GRAD,.FALSE.,.FALSE.)

      IF (REPELTST) CALL REPELSP(COORDS,RMS,INEG,MFLAG)

      IF (MFLAG) THEN
         IF (((RMS.GT.CONVR).OR.(INEG.EQ.0)).OR.(STPMAG.GT.CONVU)) MFLAG=.FALSE.
         IF (PTEST) WRITE(*,'(A,F15.7,A,F15.7,A,F15.7)') ' TOTAL GRADIENT=',RMS,' SUBSPACE GRADIENT=',RMS2,' EF STEP LENGTH=',STPMAG
         IF (MFLAG) THEN
C JMC TESTING!!
C     CALL MAKENUMINTHESS(MYHESS,NINTS,NATOMS)
C     ABSTOL=DLAMCH('SAFE  MINIMUM')
C     CALL DSYEVR('V','I','U',NINTS,HESS,3*NATOMS,0.0D0,1.0D0,1,HINDEX,ABSTOL,NFOUND,DIAG
C     CALL DSYEVR('V','I','U',NINTS,MYHESS,3*NATOMS,0.0D0,1.0D0,1,50,ABSTOL,NFOUND,DIAG
C    1,ZMAT,3*NATOMS,ISUPPZ,WORK,
C    2                        LWORK, IWORK, ILWORK, INFO )
C     IF (INFO.NE.0) PRINT*,'WARNING - INFO=',INFO,' IN DSYEVR'
C     DO J4=1,50
C     PRINT *,'EVALMIN ',DIAG(J4)
C     END DO
            FIXD=FIXDSAVE
            RETURN
         ENDIF
      ENDIF
      ITER=ITER+1
      IF (ITER.GT.ITMAX) THEN
         FIXD=FIXDSAVE
         RETURN
      ENDIF
C     IF ((AMBER).AND.(MOVIE)) CALL AMOVIEDUMP(FRAME)
      EOLD=ENERGY
      DO J1=1,NINTS
         PCSTEP(J1)=CSTEP(J1)
         XPSTEP(J1)=STEP(J1)
         PFOB(J1)=XFOB(J1)
      ENDDO
      GOTO 90

      RETURN
      END
