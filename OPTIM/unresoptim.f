C   OPTIM: A PROGRAM FOR OPTIMIZING GEOMETRIES AND CALCULATING REACTION PATHWAYS
C   COPYRIGHT (C) 1999-2006 DAVID J. WALES
C   THIS FILE IS PART OF OPTIM.
C
C   OPTIM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C   IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C   THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C   (AT YOUR OPTION) ANY LATER VERSION.
C
C   OPTIM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
C   BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
C   GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C   YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C   ALONG WITH THIS PROGRAM; IF NOT, WRITE TO THE FREE SOFTWARE
C   FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330, BOSTON, MA  02111-1307  USA
C
      SUBROUTINE UNRSETZSYMATMASS
      USE COMMONS
      USE MODUNRES
      IMPLICIT NONE

      INTEGER I1

      ALLOCATE(ATMASS(NATOMS))
      DO I1=1,NRES
         ZSYM(2*I1-1)='C'
         ZSYM(2*I1)='C'
         ATMASS(2*I1-1)=MASSES(1)
         ATMASS(2*I1)=MASSES(ITYPE(I1)+1)
      ENDDO
C JMC MAKE A MASSES FILE FOR PATHSAMPLE...
C     OPEN (UNIT=78,FILE='MASS',STATUS='UNKNOWN')
C     DO I1=1,NRES
C        WRITE(78,'(A3,F5.1)') ZSYM(2*I1-1),ATMASS(2*I1-1)
C        WRITE(78,'(A3,F5.1)') ZSYM(2*I1),ATMASS(2*I1)
C     END DO
C     CLOSE (UNIT=78)
 
      RETURN
      END


      SUBROUTINE UENERGY(X,GRAD,ETOT,GRADT,SECT)
      USE COMMONS
      USE MODUNRES
      IMPLICIT NONE

      DOUBLE PRECISION GRAD(3*NATOMS), X(3*NATOMS)
      REAL*8 EVDW,EVDW1,EVDW2,EES,EBE,ESC,ETORS,EHPB,EDIHCNSTR,ECORR,ETOT
      LOGICAL GRADT,SECT
      INTEGER ICALL
      COMMON /SRUTU/ ICALL

      NFL=0
      ICG=1
      ICALL=1

      CALL ZEROGRAD
      CALL ETOTAL(EVDW,EVDW1,EVDW2,EES,EBE,ESC,ETORS,EHPB,EDIHCNSTR,ECORR,ETOT)

      CALL INTGRAD(GRAD)
C JMC INTGRAD TAKES GRAD IN 'CARTS' (I.E. IN DC,DX: CA-CA AND SC-SC VECTORS) AND CONVERTS 
C IT TO A GRADIENT IN INTERNALS, WHICH IS PASSED BACK TO POTENTIAL ETC.

C JMC TESTING STUFF!!!
C     CALL ZEROGRAD
C     CALL CHECK_CARTGRAD
C     CALL CHECK_ECART
C     CALL CHECK_EINT

C     PRINT *,'UNRES ENERGY :'
C     PRINT *,ETOT

C     CALL CARTPRINT
C     CALL INT_FROM_CART(.TRUE.,.TRUE.)

      RETURN
      END SUBROUTINE UENERGY

      SUBROUTINE INTGRAD(GINT)
      USE COMMONS
      USE MODUNRES
      IMPLICIT NONE ! NOTE NOT PRESENT IN UNOPTIM.2.3

      DOUBLE PRECISION X(NINTS),G(NINTS)
      INTEGER UIPARM(1),ICALL,NF
      DOUBLE PRECISION URPARM(1)
      EXTERNAL FDUM
      DOUBLE PRECISION GINT(3*NATOMS)
      INTEGER J1
      COMMON /SRUTU/ ICALL

      CALL GEOM_TO_VAR(NVARU,X)
C     CALL VAR_TO_GEOM(NVARU,X)
C     CALL CHAINBUILD

      NF=1
      NFL=3
      CALL GRADIENT(NVARU,X,NF,G,UIPARM,URPARM,FDUM)

      GINT=0.0D0

      GINT(1:NVARU)=G(1:NVARU)

      RETURN
      END SUBROUTINE INTGRAD

      SUBROUTINE UPDATEDC
      USE COMMONS
      USE MODUNRES
      IMPLICIT NONE

      INTEGER J1

      DC=0.0D0
      DC_NORM=0.0D0

      DO J1=1,NRES-1
         DC(1,J1)=C(1,J1+1)-C(1,J1)
         DC(2,J1)=C(2,J1+1)-C(2,J1)
         DC(3,J1)=C(3,J1+1)-C(3,J1)
         DC_NORM(1,J1)=DC(1,J1)/VBL
         DC_NORM(2,J1)=DC(2,J1)/VBL
         DC_NORM(3,J1)=DC(3,J1)/VBL
C        PRINT *,MYDC(1,J1)/DC(1,J1),MYDC(2,J1)/DC(2,J1),MYDC(3,J1)/DC(3,J1)
C        PRINT *,MYDCNORM(1,J1)/DC_NORM(1,J1),MYDCNORM(2,J1)/DC_NORM(2,J1),MYDCNORM(3,J1)/DC_NORM(3,J1)
      END DO

      DO J1=NRES+1,2*NRES
         DC(1,J1)=C(1,J1)-C(1,J1-NRES)
         DC(2,J1)=C(2,J1)-C(2,J1-NRES)
         DC(3,J1)=C(3,J1)-C(3,J1-NRES)
         IF (ITYPE(J1-NRES).EQ.10) THEN   ! I.E. GLYCINE
            DC_NORM(1,J1)=DC(1,J1)
            DC_NORM(2,J1)=DC(2,J1)
            DC_NORM(3,J1)=DC(3,J1)
         ELSE
            DC_NORM(1,J1)=DC(1,J1)/DSC(ITYPE(J1-NRES))
            DC_NORM(2,J1)=DC(2,J1)/DSC(ITYPE(J1-NRES))
            DC_NORM(3,J1)=DC(3,J1)/DSC(ITYPE(J1-NRES))
         ENDIF
C        PRINT *,MYDC(1,J1)/DC(1,J1),MYDC(2,J1)/DC(2,J1),MYDC(3,J1)/DC(3,J1)
C        PRINT *,MYDCNORM(1,J1)/DC_NORM(1,J1),MYDCNORM(2,J1)/DC_NORM(2,J1),MYDCNORM(3,J1)/DC_NORM(3,J1)
      END DO
 
      RETURN
      END SUBROUTINE UPDATEDC
