      SUBROUTINE Q_BIAS_SEG_A(DISTNE,F_CORD,NMRES,E,
     *                  XDIFF,YDIFF,ZDIFF)

C     CALCULATES THE CONTRIBUTION TO FORCES (IE ZRCORD) DUE TO
C     A POTENTIAL THAT IS POLYNOMIAL IN Q (Q DEPENDS ON CA POSITIONS
C     ONLY, SO IT ONLY GIVES FORCES ON THESE ATOMS, BUT A DIMENSION
C     FOR TABLE NUMBER HAS BEEN INCLUDED IN MANY ARRAYS TO HOPEFULLY
C     ALLOW GENERALIZATION

C FORMAT 1  -  START WITH Q STRUCTURE AND CONSTAIN TO Q WITH POLY_NOMIAL
C FORMAT 2  -  START WITH Q STRUCTURE AND EXPAND QUARTIC POLYNOMIAL
C FORMAT 3  -  START WITH RANDOM STRUCTURE AND EXPAND QUARTIC POLYNOMIAL
 
      USE AMHGLOBALS,  ONLY: AMHMAXSIZ,MAXTAB,MAXCNT,MAXCRD,
     *   DEL_R_A,Q_IJ_A,DQ_DR_IJ_A,QBIASPOLY_A,TARG_DIST,N_QBIAS_A,
     *   I_Q_FORMAT_A,Q0_A,Q_WEIGHT_A,Q_CLIP_A,I_IXN_QBIAS_A,
     *   NUMCONST_A, SEGLIST_A,FOLDSTRT_MIN_A,SS_A,QVALUE_A,
     *   FOLDSTRT_MAX_A,N_DIVS_MAX,SS_DIST,SS_PATTERN_A
C     ARGUMENT DECLARATIONS

      IMPLICIT NONE

       DOUBLE PRECISION, INTENT(IN)::DISTNE(MAXCNT,MAXTAB),
     * XDIFF(MAXCNT,MAXTAB),YDIFF(MAXCNT,MAXTAB),
     * ZDIFF(MAXCNT,MAXTAB)

       DOUBLE PRECISION, INTENT(OUT)::F_CORD(AMHMAXSIZ,3,MAXCRD),E(:,:)
      INTEGER, INTENT(IN):: NMRES

C     INTERNAL VARIABLES

      INTEGER I_IXN,I_DIFF,I_DIST,I_CORD,I_RES,I_TAB,
     *        ISIT1,ISIT2,K,I,J,F
      DOUBLE PRECISION Q,R_DIST,FACTOR,Q_FORCE(AMHMAXSIZ,3,MAXTAB),
     *     V,DV_DQ  

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

        F_CORD=0.0D0
        E=0.0D0

C      INITIALIZE Q_FORCE

       DO I_RES=1,NMRES
         DO I_CORD=1,3
           DO I_TAB=1,4
             Q_FORCE(I_RES,I_CORD,I_TAB)=0.0
            ENDDO
         ENDDO
       ENDDO

C      CALCULATE Q AND 'UNSCALED' CONTRIBUTION TO ZRCORD

        Q=0.0D0
C        WRITE(6,*)'Q_BIAS_SEG_A  NUMCONST_A',NUMCONST_A
 
C       DO 50 I = 1,  NUMCONST_A,5
C   THIS CYCLE COMMAND PREVENT GOING OUTSIDE ARRAY BOUNDRIES

       DO 50 I = 1,  NUMCONST_A
            IF (I > NMRES )CYCLE 

             ISIT1=SEGLIST_A(I)

C IDENTIFY THE SECONDARY STRUCTURE UNIT
   
       IF (SS_A)THEN
        F = 0
       IF (SEGLIST_A(I) <= FOLDSTRT_MAX_A(1) .AND. 
     *                    SEGLIST_A(I) > FOLDSTRT_MIN_A(1)) F = 1
       IF (SEGLIST_A(I) <= FOLDSTRT_MAX_A(2) .AND.
     *                    SEGLIST_A(I) > FOLDSTRT_MIN_A(2)) F = 2
       IF (SEGLIST_A(I) <= FOLDSTRT_MAX_A(3) .AND.
     *                    SEGLIST_A(I) > FOLDSTRT_MIN_A(3)) F = 3
       IF (SEGLIST_A(I) <= FOLDSTRT_MAX_A(4) .AND.
     *                    SEGLIST_A(I) > FOLDSTRT_MIN_A(4)) F = 4
       IF (SEGLIST_A(I) <= FOLDSTRT_MAX_A(5) .AND.
     *                    SEGLIST_A(I) > FOLDSTRT_MIN_A(5)) F = 5
       IF (SEGLIST_A(I) <= FOLDSTRT_MAX_A(6) .AND.
     *                    SEGLIST_A(I) > FOLDSTRT_MIN_A(6)) F = 6
       IF (SEGLIST_A(I) <= FOLDSTRT_MAX_A(7) .AND.
     *                    SEGLIST_A(I) > FOLDSTRT_MIN_A(7)) F = 7
       IF (SEGLIST_A(I) <= FOLDSTRT_MAX_A(8) .AND.
     *                    SEGLIST_A(I) > FOLDSTRT_MIN_A(8)) F = 8
       IF (SEGLIST_A(I) <= FOLDSTRT_MAX_A(9) .AND.
     *                    SEGLIST_A(I) > FOLDSTRT_MIN_A(9)) F = 9
       IF (SEGLIST_A(I) <= FOLDSTRT_MAX_A(10) .AND.
     *                    SEGLIST_A(I) > FOLDSTRT_MIN_A(10)) F = 10
      IF (SEGLIST_A(I) <= FOLDSTRT_MAX_A(11) .AND.
     *                    SEGLIST_A(I) > FOLDSTRT_MIN_A(10)) F = 11
       IF (SEGLIST_A(I) <= FOLDSTRT_MAX_A(12) .AND.
     *                    SEGLIST_A(I) > FOLDSTRT_MIN_A(12)) F = 12
       IF (SEGLIST_A(I) <= FOLDSTRT_MAX_A(13) .AND.
     *                    SEGLIST_A(I) > FOLDSTRT_MIN_A(13)) F = 13
       IF (SEGLIST_A(I) <= FOLDSTRT_MAX_A(14) .AND.
     *                    SEGLIST_A(I) > FOLDSTRT_MIN_A(13)) F = 13
       IF (SEGLIST_A(I) <= FOLDSTRT_MAX_A(15) .AND.
     *                    SEGLIST_A(I) > FOLDSTRT_MIN_A(15)) F = 15
       IF (SEGLIST_A(I) <= FOLDSTRT_MAX_A(16) .AND.
     *                    SEGLIST_A(I) > FOLDSTRT_MIN_A(16)) F = 16
       IF (SEGLIST_A(I) <= FOLDSTRT_MAX_A(17) .AND.
     *                    SEGLIST_A(I) > FOLDSTRT_MIN_A(17)) F = 17
       IF (SEGLIST_A(I) <= FOLDSTRT_MAX_A(18) .AND.
     *                    SEGLIST_A(I) > FOLDSTRT_MIN_A(18)) F = 18
       IF (SEGLIST_A(I) <= FOLDSTRT_MAX_A(19) .AND.
     *                    SEGLIST_A(I) > FOLDSTRT_MIN_A(19)) F = 19
       IF (SEGLIST_A(I) <= FOLDSTRT_MAX_A(20) .AND.
     *                    SEGLIST_A(I) > FOLDSTRT_MIN_A(20)) F = 20
       IF (SEGLIST_A(I) <= FOLDSTRT_MAX_A(21) .AND.
     *                    SEGLIST_A(I) > FOLDSTRT_MIN_A(21)) F = 21
       IF (SEGLIST_A(I) <= FOLDSTRT_MAX_A(22) .AND.
     *                    SEGLIST_A(I) > FOLDSTRT_MIN_A(22)) F = 22
       IF (SEGLIST_A(I) <= FOLDSTRT_MAX_A(23) .AND.
     *                    SEGLIST_A(I) > FOLDSTRT_MIN_A(23)) F = 23
        ENDIF  ! SS_A

C      DO 100 J = I+2, NUMCONST_A,4

      DO 100 J = I+2, NUMCONST_A
C        WRITE(6,*)'Q_BIAS_SEG_A I, J  ', I, J 

       IF ((SS_A) .AND. (SEGLIST_A(J)  >=  FOLDSTRT_MAX_A(F) .OR. 
     *              SEGLIST_A(J)  < FOLDSTRT_MIN_A(F)) )  CYCLE

            ISIT2 = SEGLIST_A(J)
            I_DIFF = ISIT2-ISIT1
            I_IXN = I_IXN_QBIAS_A(ISIT1,ISIT2)

       IF (SS_A) THEN        
        R_DIST=DISTNE(I_IXN,1)-
     *   SS_DIST(SEGLIST_A(I),SEGLIST_A(J),SS_PATTERN_A(F))
      ENDIF

       IF (.NOT. SS_A) THEN
          R_DIST=DISTNE(I_IXN,1)-TARG_DIST(I_IXN,1)
       ENDIF 
 
        I_DIST=INT(ABS(R_DIST)/DEL_R_A(I_DIFF))+1
        IF (I_DIST.GE.N_DIVS_MAX) GOTO 100

        Q=Q+Q_IJ_A(I_DIST-1,I_DIFF)
     *       +DQ_DR_IJ_A(I_DIST,I_DIFF)*(ABS(R_DIST)!LINEARLY INTERP TO GET Q
     *       -DEL_R_A(I_DIFF)*FLOAT(I_DIST-1) )         

       FACTOR=DQ_DR_IJ_A(I_DIST,I_DIFF)/SIGN(DISTNE(I_IXN,1),R_DIST)

        Q_FORCE(ISIT1,1,1)=Q_FORCE(ISIT1,1,1)
     *                           +FACTOR*XDIFF(I_IXN,1)
        Q_FORCE(ISIT2,1,1)=Q_FORCE(ISIT2,1,1)
     *                           -FACTOR*XDIFF(I_IXN,1)
        Q_FORCE(ISIT1,2,1)=Q_FORCE(ISIT1,2,1)
     *                           +FACTOR*YDIFF(I_IXN,1)
        Q_FORCE(ISIT2,2,1)=Q_FORCE(ISIT2,2,1)
     *                           -FACTOR*YDIFF(I_IXN,1)
        Q_FORCE(ISIT1,3,1)=Q_FORCE(ISIT1,3,1)
     *                           +FACTOR*ZDIFF(I_IXN,1)
        Q_FORCE(ISIT2,3,1)=Q_FORCE(ISIT2,3,1)
     *                           -FACTOR*ZDIFF(I_IXN,1)

100     ENDDO    ! J
50    ENDDO    ! I

C     CALC Q, AND HENCE V(Q) AND DV(Q)/DQ
C        WRITE(6,*)'Q_WEIGHT_A ',Q_WEIGHT_A
C        WRITE(6,*)'N_QBIAS_A ',N_QBIAS_A
C        WRITE(6,*)'I_Q_FORMAT_A ',I_Q_FORMAT_A
C        WRITE(6,*)'Q_CLIP_A ',Q_CLIP_A
C        WRITE(6,*)'Q0_A ',Q0_A
C        WRITE(6,*)'Q ',Q

      QVALUE_A=Q
      V=0.0D0
      DV_DQ=0.0D0
      IF (I_Q_FORMAT_A.EQ.1) THEN
        DO I=1,N_QBIAS_A
          V=V+QBIASPOLY_A(I)*Q**I
          DV_DQ=DV_DQ+FLOAT(I)*QBIASPOLY_A(I)*Q**(I-1)
        ENDDO
      ELSEIF (I_Q_FORMAT_A.EQ.2 .OR.
     *     (I_Q_FORMAT_A.EQ.3.AND.ABS(Q-Q0_A).LE.Q_CLIP_A) ) THEN
        V= Q_WEIGHT_A*(Q)**4  + (-4)*Q_WEIGHT_A*Q0_A*(Q)**3
     * + 6*Q_WEIGHT_A*(Q0_A)**2*(Q)**2 + (-4)*Q_WEIGHT_A*Q0_A**3*(Q)**1
        DV_DQ=REAL(N_QBIAS_A)*Q_WEIGHT_A*(Q-Q0_A)**(N_QBIAS_A-1)
      ELSEIF (I_Q_FORMAT_A.EQ.3.AND.(Q-Q0_A.GT.Q_CLIP_A)) THEN
        DV_DQ=REAL(N_QBIAS_A)*Q_WEIGHT_A*(Q_CLIP_A)**(N_QBIAS_A-1)
        V=Q_WEIGHT_A*(Q_CLIP_A)**N_QBIAS_A + DV_DQ*(Q-Q0_A-Q_CLIP_A)
      ELSEIF (I_Q_FORMAT_A.EQ.3.AND.(Q-Q0_A.LT.-Q_CLIP_A)) THEN
        DV_DQ=REAL(N_QBIAS_A)*Q_WEIGHT_A*(-Q_CLIP_A)**(N_QBIAS_A-1)
        V=Q_WEIGHT_A*(-Q_CLIP_A)**N_QBIAS_A - DV_DQ*(Q0_A-Q-Q_CLIP_A)
      ELSE
       WRITE(6,*) 'I_Q_FORMAT_A WRONG Q_BIAS',I_Q_FORMAT_A
       STOP
      ENDIF

      E(1,10)=E(1,10)+V

C     CALC 'PROPERLY SCALED' CONTRIBUTION TO ZRCORD

       DO K =1, NUMCONST_A
          I_RES  = SEGLIST_A(K)

        DO I_CORD=1,3
          F_CORD(I_RES,I_CORD,1)=F_CORD(I_RES,I_CORD,1)-
     +                               DV_DQ*Q_FORCE(I_RES,I_CORD,1)

        ENDDO
      ENDDO

      RETURN
      END
