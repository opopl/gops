C   OPTIM: A PROGRAM FOR OPTIMIZING GEOMETRIES AND CALCULATING REACTION PATHWAYS
C   COPYRIGHT (C) 1999-2006 DAVID J. WALES
C   THIS FILE IS PART OF OPTIM.
C
C   OPTIM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C   IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C   THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C   (AT YOUR OPTION) ANY LATER VERSION.
C
C   OPTIM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
C   BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
C   GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C   YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C   ALONG WITH THIS PROGRAM; IF NOT, WRITE TO THE FREE SOFTWARE
C   FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330, BOSTON, MA  02111-1307  USA
C
      SUBROUTINE DIIS(NOPT,SVEC,ITER,QSAVE,VNEW,Q,PRMS,ENERGY,DONE)
      USE KEY
      USE GDIIS
      IMPLICIT NONE
      INTEGER J1, J2, NOPT, INDX(NDIIS+1), J, ITER
      DOUBLE PRECISION SVEC(NOPT+1,NDIIS), QD(NOPT), 
     1                 BD(NDIIS+1,NDIIS+1), CVEC(NDIIS+1), TEMP,
     2                 QSAVE(NOPT,NDIIS), D, SINV(NDIIS+1,NDIIS+1),
     3                 Q(NOPT), VNEW(NOPT), PRMS,
     4                 ESAVE(NDIIS), ENERGY
      LOGICAL SFLAG, DONE
C
C  NDIIS DEFINES THE MAXIMUM DIMENSION
C  NDIIA IS THE NUMBER OF STEPS TO USE
C  SVEC  CONTAINS SAVED STEPS
C  QSAVE CONTAINS SAVED POINTS
C  QD    CONTAINS THE EXTRAPOLATED POSITION
C  BD    IS THE B MATRIX OF DIRECT PRODUCTS
C
C  DIMENSION IS SO SMALL THAT I MIGHT AS WELL RECOMPUTE THE WHOLE
C  B MATRIX EACH TIME.
C
      DO J1=1,NDIIA-1
         ESAVE(J1)=ESAVE(J1+1)
         DO J2=1,NOPT+1
            SVEC(J2,J1)=SVEC(J2,J1+1)
            QSAVE(J2,J1)=QSAVE(J2,J1+1)
         ENDDO
      ENDDO
      ESAVE(NDIIA)=ENERGY
      DO J2=1,NOPT
         SVEC(J2,NDIIA)=VNEW(J2)
         QSAVE(J2,NDIIA)=Q(J2)
      ENDDO

      IF ((MOD(ITER,NINTV).EQ.0).AND.(PRMS.LT.PCUT).AND.(ITER.GT.1).AND.(ITER.GE.NDIIA)) THEN
         WRITE(*,'(A)') ' TAKING A DIIS STEP'
         DONE=.TRUE.
      ELSE
         RETURN
      ENDIF

      DO J1=1,NDIIA
         DO J2=J1,NDIIA
            TEMP=0.0D0
C           DO J3=1,NOPT
C              TEMP=TEMP+SVEC(J3,J2)*SVEC(J3,J1)
C           ENDDO
            TEMP=(ESAVE(J1)-ESAVE(NDIIA)+(ESAVE(NDIIA-1)-ESAVE(NDIIA)))*
     1           (ESAVE(J2)-ESAVE(NDIIA)+(ESAVE(NDIIA-1)-ESAVE(NDIIA)))/(ESAVE(NDIIA-1)-ESAVE(NDIIA))**2
            BD(J2,J1)=TEMP
            BD(J1,J2)=TEMP
         ENDDO
      ENDDO

      DO J1=1,NDIIA+1
         BD(NDIIA+1,J1)=1.0D0
         BD(J1,NDIIA+1)=1.0D0
      ENDDO
      BD(NDIIA+1,NDIIA+1)=0.0D0

       PRINT*,'B MATRIX:'
       DO J1=1,NDIIA+1
          WRITE(*,98) (BD(J1,J2),J2=1,NDIIA+1)
 98       FORMAT(10G13.6)
       ENDDO

C      PRINT*,'QSAVE MATRIX:'
C      DO J1=1,NOPT
C         WRITE(*,96) (QSAVE(J1,J2),J2=1,NDIIA)
C96       FORMAT(10F13.7)
C      ENDDO

      DO J1=1,NDIIA+1
         DO 52 J2=1,NDIIA+1
            SINV(J1,J2)=0.0D0
52       CONTINUE
         SINV(J1,J1)=1.0D0
      ENDDO
      SFLAG=.FALSE.
      CALL LUDCMP(BD,NDIIA+1,NDIIS+1,INDX,D,SFLAG)
      IF (SFLAG) PRINT*,'SINGULAR MATRIX'
      DO J=1,NDIIA+1
         D=D*BD(J,J)
      ENDDO
      WRITE(*,'(A,G15.8)') ' DIIS DETERMINANT=',D
      DO J1=1,NDIIA+1
         CALL LUBKSB(BD,NDIIA+1,NDIIS+1,INDX,SINV(1,J1))
      ENDDO
C
C  SINV IS SYMMETRIC, SO NO PROBLEM HERE.
C
      DO J1=1,NDIIA
         CVEC(J1)=SINV(J1,NDIIA+1)
      ENDDO
      WRITE(*,'(A)') ' VECTOR OF DIIS EXPANSION COEFFICIENTS:'
      WRITE(*,93) (CVEC(J1),J1=1,NDIIA)
93    FORMAT(6(2X,E12.5))
C     PRINT*,'DIIS RESIDUAL=',CVEC(NDIIA+1)

      DO J1=1,NOPT
         QD(J1)=0.0D0
      ENDDO
      DO J1=1,NDIIA
         DO J2=1,NOPT
            QD(J2)=QD(J2)+CVEC(J1)*QSAVE(J2,J1)
         ENDDO
      ENDDO
      DO J1=1,NOPT
         Q(J1)=QD(J1)
      ENDDO

      RETURN
      END
