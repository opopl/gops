
C**************************************************************


      SUBROUTINE CH_SEED(I,J,K,Q,BOND1,BOND2, ANGLE1,
     &   ANGLE2, PHI)
      USE MODAMBER9
      USE COMMONS, ONLY : NATOMS
      IMPLICIT NONE
 
      DOUBLE PRECISION, INTENT(OUT) :: Q(*)
      DOUBLE PRECISION, INTENT(IN)  :: BOND1(*),BOND2(*),ANGLE1(*),ANGLE2(*),PHI(*)
!      INTEGER, INTENT(IN) :: IC_COORDS(NRES*95+5*NRES,4)
!      CHARACTER(LEN=3)    :: IC_IMPROP(NRES*95+5*NRES)
      INTEGER, INTENT(IN) :: I,J,K
      DOUBLE PRECISION              :: RIJ, RJK, THETA
      INTEGER             :: IIC
      DOUBLE PRECISION              :: PI
      DATA PI /3.1415926535897931D0/

      RIJ = 0.0
      RJK = 0.0
      THETA = 0.0
      DO IIC = 1,LENIC
         IF(BOND1(IIC).GT.0.0) THEN
            IF(IC_COORDS(IIC,1).EQ.I.AND.IC_COORDS(IIC,2).EQ.J.AND.
     &          IC_IMPROP(IIC).EQ."NOT")
     &            RIJ=BOND1(IIC)
            IF(IC_COORDS(IIC,1).EQ.J.AND.IC_COORDS(IIC,2).EQ.I.AND.
     &          IC_IMPROP(IIC).EQ."NOT")
     &            RIJ=BOND1(IIC)
            IF(IC_COORDS(IIC,1).EQ.I.AND.IC_COORDS(IIC,3).EQ.J.AND.
     &          IC_IMPROP(IIC).EQ."IMP")
     &            RIJ=BOND1(IIC)
            IF(IC_COORDS(IIC,1).EQ.J.AND.IC_COORDS(IIC,3).EQ.I.AND.
     &          IC_IMPROP(IIC).EQ."IMP")
     &            RIJ=BOND1(IIC)
            IF(IC_COORDS(IIC,1).EQ.K.AND.IC_COORDS(IIC,2).EQ.J.AND.
     &          IC_IMPROP(IIC).EQ."NOT")
     &            RJK=BOND1(IIC)
            IF(IC_COORDS(IIC,1).EQ.J.AND.IC_COORDS(IIC,2).EQ.K.AND.
     &          IC_IMPROP(IIC).EQ."NOT")
     &            RJK=BOND1(IIC)
            IF(IC_COORDS(IIC,1).EQ.K.AND.IC_COORDS(IIC,3).EQ.J.AND. 
     &          IC_IMPROP(IIC).EQ."IMP")
     &            RJK=BOND1(IIC)
            IF(IC_COORDS(IIC,1).EQ.J.AND.IC_COORDS(IIC,3).EQ.K.AND.
     &          IC_IMPROP(IIC).EQ."IMP")
     &            RJK=BOND1(IIC)
         ENDIF
         IF(BOND2(IIC).GT.0.0) THEN
            IF(IC_COORDS(IIC,4).EQ.I.AND.IC_COORDS(IIC,3).EQ.J) RIJ=BOND2(IIC)
            IF(IC_COORDS(IIC,4).EQ.J.AND.IC_COORDS(IIC,3).EQ.I) RIJ=BOND2(IIC)
            IF(IC_COORDS(IIC,4).EQ.K.AND.IC_COORDS(IIC,3).EQ.J) RJK=BOND2(IIC)
            IF(IC_COORDS(IIC,4).EQ.J.AND.IC_COORDS(IIC,3).EQ.K) RJK=BOND2(IIC)
         ENDIF
C
         IF(IC_COORDS(IIC,3).EQ.J) THEN
            IF(ANGLE2(IIC).GT.0.0) THEN
               IF(IC_COORDS(IIC,4).EQ.I.AND.IC_COORDS(IIC,2).EQ.K) 
     &                 THETA=ANGLE2(IIC)
               IF(IC_COORDS(IIC,4).EQ.K.AND.IC_COORDS(IIC,2).EQ.I) 
     &                 THETA=ANGLE2(IIC)
            ENDIF
            IF(ANGLE1(IIC).GT.0.0) THEN
               IF(IC_COORDS(IIC,1).EQ.I.AND.IC_COORDS(IIC,2).EQ.K.AND.
     &                IC_IMPROP(IIC).EQ."IMP")
     &                  THETA=ANGLE1(IIC)
               IF(IC_COORDS(IIC,1).EQ.K.AND.IC_COORDS(IIC,2).EQ.I.AND.
     &                IC_IMPROP(IIC).EQ."IMP")
     &                  THETA=ANGLE1(IIC)
            ENDIF
         ELSE
            IF(IC_COORDS(IIC,2).EQ.J.AND.IC_IMPROP(IIC).EQ."NOT"
     &           .AND.ANGLE1(IIC).GT.0.0)THEN
               IF(IC_COORDS(IIC,1).EQ.I.AND.IC_COORDS(IIC,3).EQ.K)
     &                THETA=ANGLE1(IIC)
               IF(IC_COORDS(IIC,1).EQ.K.AND.IC_COORDS(IIC,3).EQ.I) 
     &                THETA=ANGLE1(IIC)
            ENDIF
         ENDIF
      ENDDO
C
      IF(RIJ.EQ.0.0.OR.RJK.EQ.0.0.OR.THETA.EQ.0.0) THEN
         PRINT*, "ERROR IN SEED"
         PRINT '(A,3(1X,I5),3(1X,F7.2))',
     &    ' IC SEED> I,J,K,RIJ,RJK,THETA=',I,J,K,RIJ,RJK,THETA
         RETURN
      ENDIF
C
      Q(3*(I-1)+1) = 0.0
      Q(3*(I-1)+2) = 0.0
      Q(3*(I-1)+3) = 0.0 
      Q(3*(J-1)+1) = RIJ
      Q(3*(J-1)+2) = 0.0
      Q(3*(J-1)+3) = 0.0
      THETA=THETA*(PI/180.0)
      Q(3*(K-1)+1) = RIJ-RJK*COS(THETA)
      Q(3*(K-1)+2) = RJK*SIN(THETA)
      Q(3*(K-1)+3) = 0.0

      RETURN 
      END SUBROUTINE CH_SEED

C****************************************************************************
C
C FROM PERTDIHE IN TWIST.SRC
C
C      SUBROUTINE PERTDIHAM(Q,CHPMIN,CHPMAX,CHNMIN,CHNMAX,ISEED)
C      USE MODAMBER9
C      USE COMMONS
C      USE KEY, ONLY: BHDEBUG, BHSTEPSIZE
C      IMPLICIT NONE
C      DOUBLE PRECISION::  Q(3*NATOMS)
C      DOUBLE PRECISION::  P,ANGLE,DPRAND,MYRANDOM
C      DOUBLE PRECISION::  CHPMIN,CHPMAX
C      INTEGER::           ATOT,A,B,C,I1,J1,IICD, III
!      INTEGER::           RESNUMSEG,J3,ISEG,IRES,TOTPHIPSI,TOTSIDECHAIN
!      INTEGER::           CHNMIN,CHNMAX,ISEED
!     DOUBLE PRECISION::    X(NATOMS),Y(NATOMS),Z(NATMS)
!      LOGICAL::   TPP(NATOMS),TS(NATOMS),TO(NATOMS),TT
!      INTEGER::   LENIC2
!      DOUBLE PRECISION :: BOND1(NBONH+NBONA+NBPER), BOND2(NBONH+NBONA+NBPER),
!     1       THET1(NTHETH+NTHETA+NGPER), THET2(NTHETH+NTHETA+NGPER),
!     2       PHI(NPHIA+NPHIH)
!      DOUBLE PRECISION :: ANGLE_SCALE(LENIC)
!      INTEGER:: COUNT, P_RESPAR, P_RESMAX
!      DOUBLE PRECISION:: ANGMAX,ANGMIN
!      DOUBLE PRECISION :: PROBABIL
!      DOUBLE PRECISION :: SLOPE
!
!      COUNT=0
!C      WRITE(*,*)'CHPMIN,CHPMAX,CHNMIN,CHNMAX= ',CHPMIN,CHPMAX,CHNMIN,CHNMAX
!
!      !MSB50 - PRELIMINARY -  HOW MANY RESIDUES HAVE A LIN DE/INCREASING PROBABILITY
!       P_RESPAR = 6 !NUMBER OF RESIDUES FOR WHICH TWISTING PROB DECREASES
!       P_RESMAX = 15
!      !ANGMAX, ANGMIN FOR ANGLES RESCALING - TWIST MORE WHEN AT CHAIN END
!       ANGMAX= 1.2
!       ANGMIN= 0.6
!
!C  FILL IC TABLE WITH ACTUAL CARTESIANS
!      CALL CHGETICVAL(Q,BOND1, BOND2, THET1, THET2, PHI, .FALSE.)
!      
!C INITIALISE RANDOM NMBER GENERATOR WITH INPUT SEED
!      IF(ISEED.GT.-1) CALL SDPRND(ISEED)
!C
!C WILL BE SENT BACK TO 192 IF TOO MANY OR TOO FEW DIHEDRALS ARE ALTERED
!C AS DETERMINED BY CHNMIN AND CHNMAX
!192   CONTINUE
!
!      COUNT = COUNT +1 !TOO AVOID ENDLESS LOOP
!C
!C PHI/PSI ANGLES, OMEGA AND SIDECHAIN DIHEDRALS ARE STORED IN SEPARATE LISTS
!C
!C PHI/PSI ANGLES
!      B=0
!      ATOT=0
!      DO ISEG=1,NSEG !NOT AT THE MOMENT - CHECK TWIST.SRC FOR AMENDMENTS
!         DO A=1,NPHIPSI(ISEG)
!            TPP(ATOT+A)=.FALSE.
!C
!C  CALCULATE P, THE PROBABILITY OF TWISTING
!C
!            IF (AMBOLDPERTT) THEN
!                IF (REAL(A).LE.(0.5*(NPHIPSI(ISEG)+1))) THEN
!                   !P=CHPMAX-A*((CHPMAX-CHPMIN)/(NPHIPSI(ISEG)*0.5))
!                   SLOPE = (CHPMAX-CHPMIN)/(0.5*(NPHIPSI(ISEG)-1)-1)
!                   P=-SLOPE*A+(CHPMAX+SLOPE)
!                ELSE
!                   !P=CHPMIN+(A-0.5*NPHIPSI(ISEG))*((CHPMAX-CHPMIN)/(NPHIPSI(ISEG)*0.5))
!                   SLOPE = (CHPMAX-CHPMIN)/(0.5*(NPHIPSI(ISEG)+1))
!                   P = SLOPE*A +(CHPMAX-SLOPE*NPHIPSI(ISEG))
!                END IF
!            ELSE
!            !MSB50
!            !TAKE 2* P_RESMAX AS NPHIPSI(ISEG) = 2*RESNUMSEG(ISEG) 
!            !  ONE PHI, ONE PSI ANGLE PER CHAIN
!                P = PROBABIL(A,NPHIPSI(ISEG), CHPMAX,CHPMIN,2*P_RESMAX,2*P_RESPAR)
!               !MSB50 - CALCULATION OF P DEPENDS ON POSITION OF ANGLE IN CHAIN ONLY
!               ! CAN'T RELY ON TW_ANGLES BEING SPACE OUT EQUALLY ALONG THE CHAIN -->
!               ! WOULD NOT HAVE P=CHNMIN IN THE MIDDLE OF THE CHAIN IF P= P(NTW_ANGLES)
!                IF (AMBPERTT) THEN
!                   !PRINT '(A15, 2F7.3)', "AMBERPERT PROBS",P,  TW_DIFFP(PHIPSI(A))
!                   P = (P + TW_DIFFP(PHIPSI(A)))/2!RESCALED PROB+DIFFERENCE PROB-THEN RESCALE
!                ENDIF
!
!                ! CALCULATE SCALING FACTOR FOR ANGLE
!                ANGLE_SCALE(PHIPSI(ATOT+A)) = PROBABIL(A,NPHIPSI(ISEG),
!     &                        ANGMAX,ANGMIN,2*P_RESMAX,2*P_RESPAR)
!            ENDIF
!C            IF(BHDEBUG) WRITE(*,*)'P PHIPSI = ',P,ATOT+A
!            MYRANDOM=DPRAND()
!            !PRINT '(I4,A24,2F7.3)',PHIPSI(A), "NPHIPSI PROBABILITIES", MYRANDOM,P
!            MYRANDOM=DPRAND()
!            IF (MYRANDOM.LT.P) THEN
!               TPP(ATOT+A)=.TRUE.
!               B=B+1
!            ENDIF
!         ENDDO
!         ATOT=ATOT+NPHIPSI(ISEG)
!      ENDDO
!      TOTPHIPSI=ATOT
!C      IF(BHDEBUG) WRITE(*,*)'PHIPSI: TOT=',ATOT
!
!C AMIDE BOND
!      IF (TOMEGAC) THEN
!         ATOT=0
!         DO ISEG=1,NSEG
!            DO A=1,NOMEGAC(ISEG)
!               TO(ATOT+A)=.FALSE.
!C
!C  CALCULATE P, THE PROBABILITY OF TWISTING
!C
!               IF (REAL(A).LE.(0.5*NOMEGAC(ISEG))) THEN
!                  P=CHPMAX-A*((CHPMAX-CHPMIN)/(NOMEGAC(ISEG)*0.5))
!               ELSE
!                  P=CHPMIN+(A-0.5*NOMEGAC(ISEG))*((CHPMAX-CHPMIN)/(NOMEGAC(ISEG)*0.5))
!               END IF
!C               IF(BHDEBUG) WRITE(*,*)'P OMEGA= ',P
!               MYRANDOM=DPRAND()
!               IF (MYRANDOM.LT.P) THEN
!                  TO(ATOT+A)=.TRUE.
!                  B=B+1
!               ENDIF
!            ENDDO
!            ATOT=ATOT+NOMEGAC(ISEG)
!         ENDDO
!C         IF(BHDEBUG) WRITE(*,*)'OMEGA: TOT=',ATOT
!      ENDIF
!
!C  SIDECHAINS
!      ATOT=0
!      DO ISEG=1,NSEG
!         DO A=1,NSIDECHAIN(ISEG)
!            TS(ATOT+A)=.FALSE.
!C
!C  CALCULATE P, THE PROBABILITY OF TWISTING
!C  MAKE THE PROBABILITY DEPENDENT ON THE RESIDUE NUMBER
!C  THIS MEANS THAT ALL DIHEDRALS IN THE SAME SIDECHAIN HAVE THE SAME P
!C
!            IICD=TW_SIDECHAIN(ATOT+A)
!            J3 = IC_COORDS(IICD,2)
!            DO III = 1,NRES
!               IF (IX(I02+III-1).LE.J3 .AND.(IX(I02+III).GT.J3)) THEN
!               IRES = III
!               EXIT
!            ENDIF
!            ENDDO
!            IF (ISEG .GT. 1) THEN !NICTOT DIFFERENT FROM CHARMM!!
!               RESNUMSEG=NICTOT(ISEG)-NICTOT(ISEG-1)     ! NUMBER OF RESIDUES IN THIS SEGMENT
!               IRES=IRES-NICTOT(ISEG-1) !NO OF RESIDUE IN SEGMENT
!            ELSE 
!               RESNUMSEG=NICTOT(ISEG)
!            ENDIF
!C            IF(BHDEBUG) WRITE(*,*)'IICD, JAR, IRES, RESNUM : ',IICD,JAR,IRES,RESNUM
!            IF (AMBOLDPERTT) THEN
!                IF (REAL(IRES).LE.(0.5*(RESNUMSEG+1))) THEN
!                   P=CHPMAX-IRES*(CHPMAX-CHPMIN)/(RESNUMSEG*0.5)
!                   SLOPE = (CHPMAX-CHPMIN)/(0.5*(RESNUMSEG-1)-1) !MSB50
!                   P=-SLOPE*IRES+(CHPMAX+SLOPE)
!                ELSE
!                   P=CHPMIN+(IRES-0.5*RESNUMSEG)*(CHPMAX-CHPMIN)/(RESNUMSEG*0.5)
!                   SLOPE = (CHPMAX-CHPMIN)/(0.5*(RESNUMSEG+1))
!                   P = SLOPE*IRES +(CHPMAX-SLOPE*RESNUMSEG)
!                END IF
!            ELSE
!                P = PROBABIL(IRES,RESNUMSEG,CHPMAX,CHPMIN,P_RESMAX, P_RESPAR)
!                IF (AMBPERTT) THEN
!                   !PRINT '(A20, 2F7.3)', "AMBERPERT PROBS", P, TW_DIFFP(IICD)
!                   P = (P + TW_DIFFP((IICD)))/2 !RESCALED PROB + DIFFERENCE PROB - THEN RESCALE
!                ENDIF
!                !  CALCULATE THE ANGLE SCALING FACTOR
!                ANGLE_SCALE(IICD) = PROBABIL(IRES,RESNUMSEG,
!     &                        ANGMAX,ANGMIN,P_RESMAX,P_RESPAR)
!            ENDIF
!            !PRINT '(I5,A20,I3,A,2F10.7)',IICD, "SIDE PROBABS FOR", IRES,":", MYRANDOM,P
!
!            MYRANDOM=DPRAND()
!
!C            IF(BHDEBUG) WRITE(*,*)'P SIDECHAIN =',P,ATOT+A
!            MYRANDOM=DPRAND()
!            IF (MYRANDOM.LT.P) THEN
!               TS(ATOT+A)=.TRUE.
!               B=B+1
!            ENDIF
!         ENDDO
!         ATOT=ATOT+NSIDECHAIN(ISEG)
!      ENDDO
!      TOTSIDECHAIN=ATOT
!C      IF(BHDEBUG) WRITE(*,*)'SIDECHAIN: TOT=',ATOT
!C
!C      SHIFTING B DIHEDRALS, SHOULD BE NTEST1 < B < NTEST2
!       IF (B.LT.CHNMIN .OR. B.GT.CHNMAX) THEN
!         WRITE (*,'(A)') 'TOO MANY DIHEDRALS SHIFTED - RETRYING'
!         IF (COUNT<11) THEN
!            GOTO 192
!         ELSEIF (11.LE.COUNT .AND. COUNT.LE.10000) THEN
!            CHNMAX = CHNMAX +1 !MSB50 - QUITE OFTEN TRIES TO TWIST TOO MANY     
!            !IF AMBPERTONLY AS CHNMAX = NTW_ANGLES << NPHIPSI+NSIDE
!            GOTO 192
!         ELSE
!             PRINT*, "LOOP IN PERDIHAM FAILED"
!             STOP
!         ENDIF
!       ENDIF
!
!C  TWISTING PHI/PSI ANGLES
!       ATOT=0
!       DO ISEG=1,NSEG
!          DO A=1,NPHIPSI(ISEG)
!             IF (TPP(ATOT+A)) THEN
!                IICD=PHIPSI(ATOT+A)
!C                IF(BHDEBUG) PRINT *,'PERTDIHE> CHANGING PHIPSI ',IICD
!                IF (AMBOLDPERTT) THEN
!                    ANGLE=(DPRAND()-0.5)*2.0*BHSTEPSIZE
!                    PRINT*, "PERTDIH, CHANGING PHIPSI",IICD
!                    PRINT '(A20,I4,2F10.3)', "PHIPSI CHANGE", IICD,PHI(IICD),PHI(IICD)+ANGLE
!                ELSE
!                    PRINT*, "PERTDIH, CHANGING PHIPSI", IICD
!                    ANGLE=((DPRAND()-0.5)*2.0*BHSTEPSIZE)*ANGLE_SCALE(IICD)
!                    PRINT '(I4,A6,F7.3,A6,F10.3)',IICD,"SCALE",ANGLE_SCALE(IICD),"ANGLE", ANGLE
!                ENDIF
!                PHI(IICD) = PHI(IICD) + ANGLE
!             ENDIF
!          ENDDO
!          ATOT=ATOT+A
!       ENDDO
!C
!C  TWISTING AMIDE BOND`
!       IF (TOMEGAC) THEN
!          ATOT=0
!          DO ISEG=1,NSEG
!             DO A=1,NOMEGAC(ISEG)
!               IF (TO(ATOT+A)) THEN
!                  IICD=OMEGAC(ATOT+A)
!C                  IF(BHDEBUG) PRINT *,'PERTDIHE> CHANGING OMEGA ',IICD
!                  ANGLE=(DPRAND()-0.5)*2.0*BHSTEPSIZE
!                  PHI(IICD) = PHI(IICD) +ANGLE
!                  !PRINT '(A15,I4,2F10.3)', "OMEGA CHANGE",IICD, PHI(IICD)-ANGLE,PHI(IICD)
!               ENDIF
!             ENDDO
!             ATOT=ATOT+A
!          ENDDO
!       ENDIF
!C
!C  TWISTING SIDECHAINS
!       ATOT=0
!       DO ISEG=1,NSEG
!          DO A=1,NSIDECHAIN(ISEG)
!             IF (TS(ATOT+A)) THEN
!                IICD=TW_SIDECHAIN(ATOT+A)
!                IF(BHDEBUG) PRINT *,'PERTDIHE> CHANGING SIDECHAIN ',IICD
!                IF (AMBOLDPERTT) THEN
!                   ANGLE=(DPRAND()-0.5)*2.0*BHSTEPSIZE
!                   PRINT '(A20,I4,2F10.3)', "SIDE CHANGE", IICD,PHI(IICD),PHI(IICD)+ANGLE
!                ELSE
!                   ANGLE=((DPRAND()-0.5)*2.0*BHSTEPSIZE)*ANGLE_SCALE(IICD)
!                   PRINT '(I4,A6,F7.3,A6,F10.3)',IICD,"SCALE",ANGLE_SCALE(IICD),"ANGLE", ANGLE
!                ENDIF
!                PHI(IICD) = PHI(IICD) +ANGLE
!             ENDIF
!          ENDDO
!          ATOT=ATOT+A
!       ENDDO
!
!       IF(PHI(IICD).LT.-180.0) PHI(IICD)=PHI(IICD)+360.0
!       IF(PHI(IICD).GT.180.0) PHI(IICD)=PHI(IICD)-360.0
! 
!       CALL CHREBUILD(Q, BOND1, BOND2,THET1,
!     &        THET2, PHI)
!C      DO II =1, NATOMS
!C         PRINT '(A4,4F11.5)',IH(M04+II-1),Q(3*(II-1)+1),
!C     &          Q(3*(II-1)+2),Q(3*(II-1)+3)
!C      ENDDO
!
!
!     END SUBROUTINE PERTDIHAM

! **********************************************************************


C      SUBROUTINE SETDIHEAM()
C      USE MODAMBER9
C      USE COMMONS
C      IMPLICIT NONE
C      INTEGER IICD,ISLCT,OLDUSD,I3, J3,K3, L3,IRES,JRES,ISEG,A, NSEGLAST
C      INTEGER AP,AO,AS,AC
C      INTEGER I,J
C      INTEGER SEG_START(NATOMS)
C      LOGICAL LPHIPSI,LOMEGAC,LSIDECHAIN,LCHIRAL,LASTSIDECHAIN
C      INTEGER NPHIPSITOT, NOMEGACTOT,NSIDECHAINTOT, NCHIRALTOT
C      CHARACTER*4 TYPEI,TYPEJ,TYPEK
C      CHARACTER*8 RESLAB
C
C! MSB50 - WARNING: NICTOT DEFINED DIFFERENTLY FROM CHARMM!
C!         CHARMM - RESIDUES PER SEGMENT: NICTOT(ISEG+1) - NICTOT(ISEG) 
C!              I.E. NICTOT(ISEG) IS AT WHICH RESIDUE NEW SEGMENT STARTS
C!         AMBER  - RESIDUES PER SEGMENT: NICTOT(ISEG) - NICTOT(ISEG-1) 
C!              I.E. NICTOT(ISEG) IS AT WHICH RESIDUE SEGMENT FINISHES
C
C      IF (.NOT. ALLOCATED(NICTOT)) ALLOCATE(NICTOT(NATOMS))
C
C      IF (.NOT. ALLOCATED(IC_COORDS)) THEN
C         CALL GETICCOORDS()
C         PRINT*, "LENIC", LENIC
C      ENDIF
C
C      IF (.NOT. ALLOCATED(IS_SIDECHAIN)) THEN
C          ALLOCATE(IS_SIDECHAIN(LENIC))
C          DO IICD=1, LENIC
C             I3 = IC_COORDS(IICD,1); J3 = IC_COORDS(IICD,2)
C             K3 = IC_COORDS(IICD,3); L3 = IC_COORDS(IICD,4)
C             CALL CHECK_SIDECHAIN(I3,J3,K3,L3,IICD,IS_SIDECHAIN)
C          ENDDO
C      ENDIF
C
C      NSEG = 0
C      I = 1
C      !SEG_START _ FIRST ATOM OF NEW SEGMENT
C      SEG_START(1) =1
C      DO WHILE (I .LE. NATOMS)
C      IF (IH(M04+I-1).EQ.'OXT ') THEN !CTERM
C         NSEG = NSEG +1
C         DO J = 1, NRES  !IX(I02+1) = NO OF ATOMS IN 1ST RESIDUE +1
C            IF (IX(I02+J-1).LT.I .AND. IX(I02+J).GT.I) THEN
C            NICTOT(NSEG) = J !NUMBER OF RESIDUES PRIOR TO SEGMENT + IN SEGMENT
C            EXIT
C            ENDIF
C         ENDDO
C
C         I=I+1
C         IF (I .LT. NATOMS) THEN
C            IF (IH(M04+I-1).EQ.'N') THEN
C               SEG_START(NSEG+1) = I
C            ELSEIF (IH(M04+I).EQ.'CH3 ') THEN !STARTS AT I+1+1
C               SEG_START(NSEG+1) = I-1
C            ELSE
C               PRINT*, "SETDIHAM: SEGMENT UNKNOWN START", IH(M04+I-1), IH(M04+I-1)
C            ENDIF
C         ENDIF
C
C      ELSEIF (IH(M04+I-1).EQ.'CH3 '.AND.IH(M04+I).EQ.'HH31') THEN !C2TERM
C         NSEG = NSEG +1
C         DO J = 1, NRES  !IX(I02+1) 0 NO OF ATOMS IN 1ST RESIDUE +1
C            IF (IX(I02+J-1).LT.I .AND. IX(I02+J).GT.I) THEN
C            NICTOT(NSEG) = J !NUMBER OF RESIDUES PER SEGMENT 
C            EXIT
C            ENDIF
C         ENDDO
C         
C         I=I+4
C         IF (I .LT. NATOMS) THEN
C            IF (IH(M04+I-1).EQ.'N') THEN
C               SEG_START(NSEG+1) = I
C            ELSEIF (IH(M04+I).EQ.'CH3 ') THEN !STARTS AT I+1+1
C               SEG_START(NSEG+1) = I-1
C            ELSE
C               PRINT*, "SETDIHAM: SEGMENT UNKNOWN START", IH(M04+I-1), IH(M04+I-1)
C            ENDIF
C         ENDIF
C
CC     ELSEIF OTHER TERMINALS
C      
C      ELSE !NO TERMINAL
C         I=I+1
C      ENDIF   
C      ENDDO
C
C      IF (NSEG .EQ. 0) THEN
C         PRINT*, "IN SETDIHAM: NO TERMINAL FOUND - UNKNOWN TYPE"
C         STOP
C      ENDIF
C
C       WRITE(*,*)'NSEG=',NSEG
C       IF (.NOT. ALLOCATED(NPHIPSI)) ALLOCATE(NPHIPSI(NSEG))
C       IF (.NOT. ALLOCATED(NOMEGAC)) ALLOCATE(NOMEGAC(NSEG))
C       IF (.NOT. ALLOCATED(NSIDECHAIN)) ALLOCATE(NSIDECHAIN(NSEG))
C       IF (.NOT. ALLOCATED(NCHIRAL)) ALLOCATE(NCHIRAL(NSEG))
C       IF (.NOT. ALLOCATED(PHIPSI)) ALLOCATE(PHIPSI(NATOMS))
C       IF (.NOT. ALLOCATED(OMEGAC)) ALLOCATE(OMEGAC(NATOMS))
C       IF (.NOT. ALLOCATED(TW_SIDECHAIN)) ALLOCATE(TW_SIDECHAIN(NATOMS))
C       IF (.NOT. ALLOCATED(CHIRAL)) ALLOCATE(CHIRAL(NATOMS))
C
C       NPHIPSI(1:NSEG)=0 
C       NOMEGAC(1:NSEG)=0
C       NSIDECHAIN(1:NSEG)=0
C       NCHIRAL(1:NSEG)=0
C       PHIPSI(1:NATOMS)=0
C       OMEGAC(1:NATOMS)=0
C       TW_SIDECHAIN(1:NATOMS)=0
C       CHIRAL(1:NATOMS)=0
C
C       AP=0
C       AO=0
C       AS=0
C       AC=0
C
C       NSEGLAST=1
C       ISEG = 1
C       DO IICD=1,LENIC
C          LPHIPSI=.FALSE.
C          LOMEGAC=.FALSE.
C          LSIDECHAIN=.FALSE.
C          LCHIRAL=.FALSE.
C          I3 = IC_COORDS(IICD,1)
C          DO I = 1, NSEG
C             IF (I3 .GE. SEG_START(I)) THEN
C             ISEG =I
C             ENDIF
C          ENDDO
C          IF (ISEG .GT.NSEGLAST) THEN
C             AP=AP+NPHIPSI(NSEGLAST)
C             AO=AO+NOMEGAC(NSEGLAST)
C             AS=AS+NSIDECHAIN(NSEGLAST)
C             AC=AC+NCHIRAL(NSEGLAST)
C             NSEGLAST=ISEG
C          ENDIF
C          CALL ICTYPECHECKAM(LPHIPSI,LOMEGAC,LSIDECHAIN, LCHIRAL,IICD)
C          IF (LPHIPSI) THEN
C             NPHIPSI(ISEG)=NPHIPSI(ISEG)+1
C             PHIPSI(AP+NPHIPSI(ISEG))=IICD
CC            PRINT *,'LP: IICD=', IICD,AP+NPHIPSI(ISEG)
C          ENDIF
C          IF (LOMEGAC) THEN
C             NOMEGAC(ISEG)=NOMEGAC(ISEG)+1
C             OMEGAC(AO+NOMEGAC(ISEG))=IICD
CC            PRINT *,'LO: IICD=', IICD,AO+NOMEGAC(ISEG)
C          ENDIF
C          IF (LSIDECHAIN) THEN
C             NSIDECHAIN(ISEG)=NSIDECHAIN(ISEG)+1
C             TW_SIDECHAIN(AS+NSIDECHAIN(ISEG))=IICD
C            PRINT *,'LS: IICD=', IICD, AS+NSIDECHAIN(ISEG)
C          ENDIF
C          IF (LCHIRAL) THEN
C             NCHIRAL(ISEG)=NCHIRAL(ISEG)+1
C             CHIRAL(AC+NCHIRAL(ISEG))=IICD
CC            PRINT *,'LC: IICD=', IICD, AC+NCHIRAL(ISEG)
C          ENDIF
C       ENDDO
C
C       NPHIPSITOT=0
C       NOMEGACTOT=0
C       NSIDECHAINTOT=0
C       NCHIRALTOT=0
C       DO ISEG=1,NSEG
C          NPHIPSITOT=NPHIPSITOT+NPHIPSI(ISEG)
C          NOMEGACTOT=NOMEGACTOT+NOMEGAC(ISEG)
C          NSIDECHAINTOT=NSIDECHAINTOT+NSIDECHAIN(ISEG)
C          NCHIRALTOT=NCHIRALTOT+NCHIRAL(ISEG)
C          WRITE(*,'(A,I4)')'NUMBER OF INTERNAL COORDINATES FOR SEGMENT ',ISEG
C          PRINT *,'SETDIHEAM NPHIPSI',NPHIPSI(ISEG)
C          PRINT *,'SETDIHEAM NOMEGAC',NOMEGAC(ISEG)
C          PRINT *,'SETDIHEAM NSIDECHAIN',NSIDECHAIN(ISEG)
C          PRINT *,'SETDIHEAM NCHIRAL',NCHIRAL(ISEG)
C       ENDDO
C       WRITE(*,'(A)')'TOTAL NUMBER OF INTERNAL COORDINATES'
C       PRINT *,'SETDIHEAM> NPHIPSITOT= ',NPHIPSITOT
C       PRINT *,'SETDIHEAM> NOMEGACTOT= ',NOMEGACTOT
C       PRINT *,'SETDIHEAM> NSIDECHAINTOT= ',NSIDECHAINTOT
C       PRINT *,'SETDIHEAM> NCHIRALTOT= ',NCHIRALTOT
C SET NSEGATOMS, IE. NUMBER OF ATOMS PER SEGMENT
C       ALLOCATE(NSEGATOMS(NSEG))
C       DO ISEG=2,NSEG+1
C          NSEGATOMS(ISEG-1)=IBASE(NICTOT(ISEG)+1)-IBASE(NICTOT(ISEG-1)+1)
C       ENDDO
C       DO ISEG=1,NSEG
C          WRITE(*,'(A,I4,I6)')'SEG-NR,NSEGATOMS : ',ISEG,NSEGATOMS(ISEG)
C       ENDDO

C      END SUBROUTINE SETDIHEAM




      SUBROUTINE AMB_PATOM(ATOM_NO, ATRES, ATOM)
!MSB50: GIVE IT A RESIDUE NUMBER AND E.G. "CD1" AND IN GIVES YOU THE NUMBER OF CD1
      USE MODAMBER9
      IMPLICIT NONE
      CHARACTER(LEN=4),INTENT(IN) :: ATOM 
      INTEGER,INTENT(IN) :: ATRES
      INTEGER, INTENT(OUT) :: ATOM_NO
      INTEGER ::K
      
!     FOR GOD'S SAKE REMEMBER
!     IX(I02) STARTS WITH 1
!
      ATOM_NO = -9999
!     NAT_RES =IX(I02+ATRES)- IX(I02+ATRES-1)  !NUMBER OF ATOMS IN CURRENT RESIDUE
      DO K=IX(I02+ATRES-1),IX(I02+ATRES)
          IF (ATOM==IH(M04+K-1)) THEN
             ATOM_NO = K
             EXIT
          ENDIF
      ENDDO 
      IF (ATOM_NO.LT.0) THEN
         PRINT*, "ERROR: ATOM NOT FOUND", ATOM
      ENDIF
      END SUBROUTINE AMB_PATOM
