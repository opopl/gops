!   OPTIM: A PROGRAM FOR OPTIMIZING GEOMETRIES AND CALCULATING REACTION PATHWAYS
!   COPYRIGHT (C) 1999-2006 DAVID J. WALES
!   THIS FILE IS PART OF OPTIM.
!
!   OPTIM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
!   IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
!   THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
!   (AT YOUR OPTION) ANY LATER VERSION.
!
!   OPTIM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
!   BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
!   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
!   GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
!
!   YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
!   ALONG WITH THIS PROGRAM; IF NOT, WRITE TO THE FREE SOFTWARE
!   FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330, BOSTON, MA  02111-1307  USA
!
!   FINDS THE MINIMUM DISTANCE BETWEEN TWO GEOMETRIES.
!   GEOMETRY IN RA SHOULD NOT CHANGE. RB IS RETURNED AS THE
!   CLOSEST GEOMETRY TO RA IF PRESERVET IS .FALSE.
!
!   NEW ANALYTIC METHOD BASED ON QUATERIONS FROM
!   KEARSLEY, ACTA CRYST. A, 45, 208-210, 1989.
!
! JMC AS LONG AS ZSYM ISN'T 'W' (IN WHICH CASE MIND DOES SOMETHING SPECIAL) MIND
! DOESN'T CARE WHAT ATOMIC SYMBOL WE GIVE IT.
!
!  IF PRESERVET IS FALSE WE PUT RB INTO BEST CORRESPONDENCE WITH RA. THIS INVOLVES
!  A TRANSLATION TO THE SAME CENTRE OF COORDINATES, FOLLOWED BY A ROTATION ABOUT THAT
!  CENTRE.
!
SUBROUTINE NEWMINDIST(RA,RB,NATOMS,DIST,BULKT,TWOD,ZUSE,PRESERVET,RIGIDBODY,DEBUG,RMAT)
USE COMMONS,ONLY : PARAM1, PARAM2, PARAM3
USE KEY,ONLY : STOCKT, NFREEZE, RBAAT, PULLT, EFIELDT

IMPLICIT NONE
INTEGER J1, NATOMS, NSIZE, INFO, JINFO, JMIN
DOUBLE PRECISION RA(3*NATOMS), RB(3*NATOMS), DIST, QMAT(4,4), XM, YM, ZM, XP, YP, ZP, OVEC(3), H1VEC(3), H2VEC(3), &
  &              DIAG(4), TEMPA(9*NATOMS), RMAT(3,3), MINV, Q1, Q2, Q3, Q4, CMXA, CMYA, CMZA, CMXB, CMYB, CMZB, &
  &              MYROTMAT(3,3), OMEGATOT(3,3)
DOUBLE PRECISION, ALLOCATABLE :: XA(:), XB(:)
LOGICAL BULKT, TWOD, RIGIDBODY, PRESERVET, DEBUG
CHARACTER(LEN=5) ZUSE
COMMON /MINDOM/ MYROTMAT, OMEGATOT
INTEGER NCIT
DOUBLE PRECISION XSHIFT, YSHIFT, ZSHIFT, XSHIFTNEW, YSHIFTNEW, ZSHIFTNEW, BOXLX, BOXLY, BOXLZ
DOUBLE PRECISION ENERGY, VNEW(3*NATOMS), RMS

IF (RBAAT) THEN
   CALL RBMINDIST2(RA,RB,NATOMS,DIST,RMAT,DEBUG)
   RETURN
ENDIF
! CALL POTENTIAL(RA,ENERGY,VNEW,.TRUE.,.FALSE.,RMS,.FALSE.,.FALSE.)
! PRINT '(2(A,F25.15))','NEWMINDIST> INITIAL RA ENERGY=',ENERGY,' RMS=',RMS
! CALL POTENTIAL(RB,ENERGY,VNEW,.TRUE.,.FALSE.,RMS,.FALSE.,.FALSE.)
! PRINT '(2(A,F25.15))','NEWMINDIST> INITIAL RB ENERGY=',ENERGY,' RMS=',RMS

! WRITE(*,*) NATOMS
! WRITE(*,*) 'RA STARTING GEOMETRY'
! WRITE(*,'(A3,3G20.10)') ('LA ',RA(3*(J1-1)+1),RA(3*(J1-1)+2),RA(3*(J1-1)+3),J1=1,NATOMS)
! WRITE(*,*) NATOMS
! WRITE(*,*) 'RB STARTING GEOMETRY'
! WRITE(*,'(A3,3G20.10)') ('LA ',RB(3*(J1-1)+1),RB(3*(J1-1)+2),RB(3*(J1-1)+3),J1=1,NATOMS)
! 
! CONVERT RIGID BODY COORDINATES TO CARTESIANS FOR RIGID BODIES. 
!
IF (ZUSE(1:1).EQ.'W') THEN
   ALLOCATE(XA(3*3*(NATOMS/2)),XB(3*3*(NATOMS/2)))
   NSIZE=3*(NATOMS/2)
   DO J1=1,NATOMS/2
      CALL CONVERT(RA(3*(J1-1)+1),RA(3*(J1-1)+2),RA(3*(J1-1)+3), &
     &        RA(3*(NATOMS/2+J1-1)+1),RA(3*(NATOMS/2+J1-1)+2),RA(3*(NATOMS/2+J1-1)+3),OVEC,H1VEC,H2VEC)
      XA(9*(J1-1)+0+1)=OVEC(1)
      XA(9*(J1-1)+0+2)=OVEC(2)
      XA(9*(J1-1)+0+3)=OVEC(3)
      XA(9*(J1-1)+3+1)=H1VEC(1)
      XA(9*(J1-1)+3+2)=H1VEC(2)
      XA(9*(J1-1)+3+3)=H1VEC(3)
      XA(9*(J1-1)+6+1)=H2VEC(1)
      XA(9*(J1-1)+6+2)=H2VEC(2)
      XA(9*(J1-1)+6+3)=H2VEC(3)
      CALL CONVERT(RB(3*(J1-1)+1),RB(3*(J1-1)+2),RB(3*(J1-1)+3), &
     &      RB(3*(NATOMS/2+J1-1)+1),RB(3*(NATOMS/2+J1-1)+2),RB(3*(NATOMS/2+J1-1)+3),OVEC,H1VEC,H2VEC)
      XB(9*(J1-1)+0+1)=OVEC(1)
      XB(9*(J1-1)+0+2)=OVEC(2)
      XB(9*(J1-1)+0+3)=OVEC(3)
      XB(9*(J1-1)+3+1)=H1VEC(1)
      XB(9*(J1-1)+3+2)=H1VEC(2)
      XB(9*(J1-1)+3+3)=H1VEC(3)
      XB(9*(J1-1)+6+1)=H2VEC(1)
      XB(9*(J1-1)+6+2)=H2VEC(2)
      XB(9*(J1-1)+6+3)=H2VEC(3)
   ENDDO
ELSEIF (RIGIDBODY) THEN
   PRINT '(A)',' NEWMINDIST> NEW QUATERNION PROCEDURE NOT YET CODED FOR GENERAL ANGLE-AXIS VARIABLES'
   STOP
ELSEIF ((TWOD.OR.PULLT.OR.EFIELDT).AND.(.NOT.BULKT)) THEN
!  ALLOCATE(XA(3*(NATOMS/2)*NUMBER OF SITES,XB(3*(NATOMS/2)*NUMBER OF SITES))
!  NSIZE=(NATOMS/2)*NUMBER OF SITES
!  PRINT '(A)',' NEWMINDIST> NEW QUATERNION PROCEDURE NOT YET CODED FOR FLATLAND'
! THERE IS ONE UNKNOWN ANGLE, SO THIS SHOULD BE TRIVIAL!'
   CALL MINDIST(RA,RB,NATOMS,DIST,BULKT,TWOD,ZUSE,PRESERVET)
   RMAT(1:3,1:3)=OMEGATOT(1:3,1:3)
   RETURN
!  STOP
ELSEIF (STOCKT) THEN
   ALLOCATE(XA(3*(NATOMS/2)),XB(3*(NATOMS/2)))
   NSIZE=(NATOMS/2)
!  PRINT *,'NEWMINDIST> WARNING *** FOR STOCKT ONLY COFM COORDINATES LOADED INTO XA AND XB???'
   XA(1:3*NSIZE)=RA(1:3*NSIZE)
   XB(1:3*NSIZE)=RB(1:3*NSIZE)
ELSE
   ALLOCATE(XA(3*NATOMS),XB(3*NATOMS))
   NSIZE=NATOMS
   XA(1:3*NATOMS)=RA(1:3*NATOMS)
   XB(1:3*NATOMS)=RB(1:3*NATOMS)
ENDIF
!
! IF THERE ARE FROZEN ATOMS THEN JUST CALCULATE THE DISTANCE AND RETURN.
!
IF (NFREEZE.GT.0) THEN
   DIST=0.0D0
   IF (BULKT) THEN
      BOXLX=PARAM1; BOXLY=PARAM2; BOXLZ=PARAM3
      DO J1=1,NSIZE
         DIST=DIST + (XA(3*(J1-1)+1)-XB(3*(J1-1)+1) - BOXLX*NINT((XA(3*(J1-1)+1)-XB(3*(J1-1)+1))/BOXLX))**2 &
   &               + (XA(3*(J1-1)+2)-XB(3*(J1-1)+2) - BOXLY*NINT((XA(3*(J1-1)+2)-XB(3*(J1-1)+2))/BOXLY))**2 &
   &               + (XA(3*(J1-1)+3)-XB(3*(J1-1)+3) - BOXLZ*NINT((XA(3*(J1-1)+3)-XB(3*(J1-1)+3))/BOXLZ))**2
      ENDDO
   ELSE
      DO J1=1,NSIZE
         DIST=DIST + (XA(3*(J1-1)+1)-XB(3*(J1-1)+1))**2 &
   &               + (XA(3*(J1-1)+2)-XB(3*(J1-1)+2))**2 &
   &               + (XA(3*(J1-1)+3)-XB(3*(J1-1)+3))**2
      ENDDO
   ENDIF
   DIST=SQRT(DIST)
   
   RMAT(1:3,1:3)=0.0D0 ! ROTATION MATRIX IS THE IDENTITY
   RMAT(1,1)=1.0D0; RMAT(2,2)=1.0D0; RMAT(3,3)=1.0D0
   RETURN
ENDIF
IF (BULKT) THEN
   BOXLX=PARAM1; BOXLY=PARAM2; BOXLZ=PARAM3
   DO J1=1,NSIZE
      XA(3*(J1-1)+1)=XA(3*(J1-1)+1)-BOXLX*NINT(XA(3*(J1-1)+1)/BOXLX)
      XA(3*(J1-1)+2)=XA(3*(J1-1)+2)-BOXLY*NINT(XA(3*(J1-1)+2)/BOXLY)
      IF (.NOT.TWOD) XA(3*(J1-1)+3)=XA(3*(J1-1)+3)-BOXLZ*NINT(XA(3*(J1-1)+3)/BOXLZ)
   ENDDO
   DO J1=1,NSIZE
      XB(3*(J1-1)+1)=XB(3*(J1-1)+1)-BOXLX*NINT(XB(3*(J1-1)+1)/BOXLX)
      XB(3*(J1-1)+2)=XB(3*(J1-1)+2)-BOXLY*NINT(XB(3*(J1-1)+2)/BOXLY)
      IF (.NOT.TWOD) XB(3*(J1-1)+3)=XB(3*(J1-1)+3)-BOXLZ*NINT(XB(3*(J1-1)+3)/BOXLZ)
   ENDDO
ENDIF
!
! MOVE CENTRE OF COORDINATES OF XA AND XB TO THE ORIGIN.
!
CMXA=0.0D0; CMYA=0.0D0; CMZA=0.0D0
DO J1=1,NSIZE
   CMXA=CMXA+XA(3*(J1-1)+1)
   CMYA=CMYA+XA(3*(J1-1)+2)
   CMZA=CMZA+XA(3*(J1-1)+3)
ENDDO
CMXA=CMXA/NSIZE; CMYA=CMYA/NSIZE; CMZA=CMZA/NSIZE
DO J1=1,NSIZE
   XA(3*(J1-1)+1)=XA(3*(J1-1)+1)-CMXA
   XA(3*(J1-1)+2)=XA(3*(J1-1)+2)-CMYA
   XA(3*(J1-1)+3)=XA(3*(J1-1)+3)-CMZA
ENDDO
CMXB=0.0D0; CMYB=0.0D0; CMZB=0.0D0
DO J1=1,NSIZE
   CMXB=CMXB+XB(3*(J1-1)+1)
   CMYB=CMYB+XB(3*(J1-1)+2)
   CMZB=CMZB+XB(3*(J1-1)+3)
ENDDO
CMXB=CMXB/NSIZE; CMYB=CMYB/NSIZE; CMZB=CMZB/NSIZE
DO J1=1,NSIZE
   XB(3*(J1-1)+1)=XB(3*(J1-1)+1)-CMXB
   XB(3*(J1-1)+2)=XB(3*(J1-1)+2)-CMYB
   XB(3*(J1-1)+3)=XB(3*(J1-1)+3)-CMZB
ENDDO
! PRINT '(A,6F15.7)','CMA,CMB=',CMXA,CMYA,CMZA,CMXB,CMYB,CMZB

XSHIFT=0.0D0; YSHIFT=0.0D0; ZSHIFT=0.0D0
NCIT=0
IF (BULKT) THEN 
   BOXLX=PARAM1; BOXLY=PARAM2; BOXLZ=PARAM3
! ITERATIVE SOLUTION
! 1  NCIT=NCIT+1
!    IF (NCIT.GT.1000) THEN
!       PRINT '(A)','INERTIA> WARNING - ITERATIVE CALCULATION OF CENTRE OF MASS SHIFT DID NOT CONVERGE'
!    ENDIF
!    XSHIFTNEW=0.0D0
!    YSHIFTNEW=0.0D0
!    ZSHIFTNEW=0.0D0
!    DO J1=1,NSIZE
!       XSHIFTNEW= SHIFTNEW + XA(3*(J1-1)+1)-XB(3*(J1-1)+1) - BOXLX*NINT((XA(3*(J1-1)+1)-XB(3*(J1-1)+1)-XSHIFT)/BOXLX)
!       YSHIFTNEW=YSHIFTNEW + XA(3*(J1-1)+2)-XB(3*(J1-1)+2) - BOXLY*NINT((XA(3*(J1-1)+2)-XB(3*(J1-1)+2)-YSHIFT)/BOXLY)
!       IF (.NOT.TWOD) ZSHIFTNEW=ZSHIFTNEW + XA(3*(J1-1)+3)-XB(3*(J1-1)+3) - BOXLZ*NINT((XA(3*(J1-1)+3)-XB(3*(J1-1)+3)-ZSHIFT)/BOXLZ)
!    ENDDO
!    XSHIFTNEW=XSHIFTNEW/NSIZE; YSHIFTNEW=YSHIFTNEW/NSIZE; ZSHIFTNEW=ZSHIFTNEW/NSIZE
!    IF ((ABS(XSHIFTNEW-XSHIFT).GT.1.0D-6).OR.(ABS(YSHIFTNEW-YSHIFT).GT.1.0D-6).OR.(ABS(ZSHIFTNEW-ZSHIFT).GT.1.0D-6)) THEN
! !     IF (DEBUG) PRINT '(A,I6,6F15.7)',' NEWMINDIST> ',NCIT,XSHIFTNEW,YSHIFTNEW,ZSHIFTNEW,XSHIFT,YSHIFT,ZSHIFT
!       XSHIFT=0.05D0*XSHIFT+0.95D0*XSHIFTNEW
!       YSHIFT=0.05D0*YSHIFT+0.95D0*YSHIFTNEW
!       IF (.NOT.TWOD) ZSHIFT=0.05D0*ZSHIFT+0.95D0*ZSHIFTNEW
!       GOTO 1
!    ENDIF
! !  IF (DEBUG) PRINT '(A,I6,3F15.7)',' NEWMINDIST> COORDINATE SHIFT CONVERGED. CYCLES AND VALUES: ',NCIT,XSHIFT,YSHIFT,ZSHIFT
!    XSHIFT=XSHIFTNEW
!    YSHIFT=YSHIFTNEW 
!    ZSHIFT=ZSHIFTNEW
!
! ACTUALLY, THE ITERATIVE SOLUTION SEEMS TO BE WORSE THAN SIMPLY PUTTING THE CENTRE OF MASS
! AT THE ORIGIN. 
!
   DIST=0.0D0
   DO J1=1,NSIZE
    DIST=DIST + (XA(3*(J1-1)+1)-XB(3*(J1-1)+1)-XSHIFT - BOXLX*NINT((XA(3*(J1-1)+1)-XB(3*(J1-1)+1)-XSHIFT)/BOXLX))**2 &
   &            + (XA(3*(J1-1)+2)-XB(3*(J1-1)+2)-YSHIFT - BOXLY*NINT((XA(3*(J1-1)+2)-XB(3*(J1-1)+2)-YSHIFT)/BOXLY))**2 
      IF (.NOT.TWOD) DIST=DIST &
   &            + (XA(3*(J1-1)+3)-XB(3*(J1-1)+3)-ZSHIFT - BOXLZ*NINT((XA(3*(J1-1)+3)-XB(3*(J1-1)+3)-ZSHIFT)/BOXLZ))**2
   ENDDO
   DIST=SQRT(DIST)

   RMAT(1:3,1:3)=0.0D0 ! ROTATION MATRIX IS THE IDENTITY
   RMAT(1,1)=1.0D0; RMAT(2,2)=1.0D0; RMAT(3,3)=1.0D0
ELSE
!
!  THE FORMULA BELOW IS NOT INVARIANT TO OVERALL TRANSLATION BECAUSE XP, YP, ZP
!  INVOLVE A SUM OF COORDINATES! WE NEED TO HAVE XA AND XB COORDINATE CENTRES BOTH 
!  AT THE ORIGIN!!
!
   QMAT(1:4,1:4)=0.0D0
   DO J1=1,NSIZE
      XM=XA(3*(J1-1)+1)-XB(3*(J1-1)+1)
      YM=XA(3*(J1-1)+2)-XB(3*(J1-1)+2)
      ZM=XA(3*(J1-1)+3)-XB(3*(J1-1)+3)
      XP=XA(3*(J1-1)+1)+XB(3*(J1-1)+1)
      YP=XA(3*(J1-1)+2)+XB(3*(J1-1)+2)
      ZP=XA(3*(J1-1)+3)+XB(3*(J1-1)+3)
!     PRINT '(A,I8,6G18.8)','J1,XM,YM,ZM,XP,YP,ZP=',J1,XM,YM,ZM,XP,YP,ZP
      QMAT(1,1)=QMAT(1,1)+XM**2+YM**2+ZM**2
      QMAT(1,2)=QMAT(1,2)+YP*ZM-YM*ZP
      QMAT(1,3)=QMAT(1,3)+XM*ZP-XP*ZM
      QMAT(1,4)=QMAT(1,4)+XP*YM-XM*YP
      QMAT(2,2)=QMAT(2,2)+YP**2+ZP**2+XM**2
      QMAT(2,3)=QMAT(2,3)+XM*YM-XP*YP
      QMAT(2,4)=QMAT(2,4)+XM*ZM-XP*ZP
      QMAT(3,3)=QMAT(3,3)+XP**2+ZP**2+YM**2
      QMAT(3,4)=QMAT(3,4)+YM*ZM-YP*ZP
      QMAT(4,4)=QMAT(4,4)+XP**2+YP**2+ZM**2
   ENDDO
   QMAT(2,1)=QMAT(1,2); QMAT(3,1)=QMAT(1,3); QMAT(3,2)=QMAT(2,3); QMAT(4,1)=QMAT(1,4); QMAT(4,2)=QMAT(2,4); QMAT(4,3)=QMAT(3,4)
!  PRINT '(A,G20.10)','QMAT(1,1)=',QMAT(1,1)
!  PRINT '(A,G20.10)','QMAT(1,2)=',QMAT(1,2)
!  PRINT '(A,G20.10)','QMAT(1,3)=',QMAT(1,3)
!  PRINT '(A,G20.10)','QMAT(1,4)=',QMAT(1,4)
!  PRINT '(A,G20.10)','QMAT(2,2)=',QMAT(2,2)
!  PRINT '(A,G20.10)','QMAT(2,3)=',QMAT(2,3)
!  PRINT '(A,G20.10)','QMAT(2,4)=',QMAT(2,4)
!  PRINT '(A,G20.10)','QMAT(3,3)=',QMAT(3,3)
!  PRINT '(A,G20.10)','QMAT(3,4)=',QMAT(3,4)
!  PRINT '(A,G20.10)','QMAT(4,4)=',QMAT(4,4)

   CALL DSYEV('V','U',4,QMAT,4,DIAG,TEMPA,9*NATOMS,INFO)
   IF (INFO.NE.0) PRINT '(A,I6,A)',' NEWMINDIST> WARNING - INFO=',INFO,' IN DSYEV'

   MINV=1.0D100
   DO J1=1,4
!     PRINT '(A,I8,G20.10)','NEWMINDIST> J1,DIAG=',J1,DIAG(J1)
      IF (DIAG(J1).LT.MINV) THEN
         JMIN=J1
         MINV=DIAG(J1)
      ENDIF
   ENDDO
   IF (MINV.LT.0.0D0) THEN
      IF (ABS(MINV).LT.1.0D-6) THEN
         MINV=0.0D0
      ELSE
         PRINT '(A,G20.10,A)',' NEWMINDIST> WARNING MINV IS ',MINV,' CHANGE TO ABSOLUTE VALUE'
         MINV=-MINV
      ENDIF
   ENDIF
   DIST=SQRT(MINV)

!  IF (DEBUG) PRINT '(A,G20.10,A,I6)',' NEWMINDIST> MINIMUM RESIDUAL IS ',DIAG(JMIN),' FOR EIGENVECTOR ',JMIN
   Q1=QMAT(1,JMIN); Q2=QMAT(2,JMIN); Q3=QMAT(3,JMIN); Q4=QMAT(4,JMIN)
!
! RMAT WILL CONTAIN THE MATRIX THAT MAPS XB ONTO THE BEST CORRESPONDENCE WITH XA
!
   RMAT(1,1)=Q1**2+Q2**2-Q3**2-Q4**2
   RMAT(1,2)=2*(Q2*Q3+Q1*Q4)
   RMAT(1,3)=2*(Q2*Q4-Q1*Q3)
   RMAT(2,1)=2*(Q2*Q3-Q1*Q4)
   RMAT(2,2)=Q1**2+Q3**2-Q2**2-Q4**2
   RMAT(2,3)=2*(Q3*Q4+Q1*Q2)
   RMAT(3,1)=2*(Q2*Q4+Q1*Q3)
   RMAT(3,2)=2*(Q3*Q4-Q1*Q2)
   RMAT(3,3)=Q1**2+Q4**2-Q2**2-Q3**2
ENDIF

IF (.NOT.PRESERVET) THEN
   IF (ZUSE(1:1).EQ.'W') THEN
!
!  TRANSLATE THE XB COORDINATES TO THE CENTRE OF COORDINATES OF XA.
!
      DO J1=1,NSIZE
         XB(3*(J1-1)+1)=XB(3*(J1-1)+1)+CMXA+XSHIFT
         XB(3*(J1-1)+2)=XB(3*(J1-1)+2)+CMYA+YSHIFT
         XB(3*(J1-1)+3)=XB(3*(J1-1)+3)+CMZA+ZSHIFT
      ENDDO
!
!  ROTATE XB COORDINATES ABOUT NEW CENTRE OF MASS
!
      CALL NEWROTGEOM(NSIZE,XB,RMAT,CMXA,CMYA,CMZA)
      DO J1=1,NATOMS/2
         OVEC(1)=XB(1+(J1-1)*9+0)
         OVEC(2)=XB(2+(J1-1)*9+0)
         OVEC(3)=XB(3+(J1-1)*9+0)
         H1VEC(1)=XB(1+(J1-1)*9+3)
         H1VEC(2)=XB(2+(J1-1)*9+3)
         H1VEC(3)=XB(3+(J1-1)*9+3)
         H2VEC(1)=XB(1+(J1-1)*9+6)
         H2VEC(2)=XB(2+(J1-1)*9+6)
         H2VEC(3)=XB(3+(J1-1)*9+6)
         CALL CONVERT2(OVEC,H1VEC,H2VEC,RB(3*(J1-1)+1),RB(3*(J1-1)+2),RB(3*(J1-1)+3), &
  &                    RB(3*(NATOMS/2+J1-1)+1),RB(3*(NATOMS/2+J1-1)+2),RB(3*(NATOMS/2+J1-1)+3))
      ENDDO
   ELSEIF (RIGIDBODY) THEN
!
!  NEEDS SOME THOUGHT FOR THE ANGLE/AXIS RIGID BODY FORMULATION.
!
      PRINT '(A)',' NEWMINDIST> WARNING *** BACK TRANSFORMATION NOT PROGRAMMED YET FOR RIGID BODIES'
   ELSE
!
!  TRANSLATE THE RB COORDINATES TO THE CENTRE OF COORDINATES OF RA.
!
      DO J1=1,NSIZE
         RB(3*(J1-1)+1)=RB(3*(J1-1)+1)-CMXB+CMXA+XSHIFT
         RB(3*(J1-1)+2)=RB(3*(J1-1)+2)-CMYB+CMYA+YSHIFT
         RB(3*(J1-1)+3)=RB(3*(J1-1)+3)-CMZB+CMZA+ZSHIFT
      ENDDO

      IF (.NOT.BULKT) THEN
         IF (STOCKT) THEN
            CALL NEWROTGEOMSTOCK(NATOMS,RB,RMAT,CMXA,CMYA,CMZA)
         ELSE
            CALL NEWROTGEOM(NSIZE,RB,RMAT,CMXA,CMYA,CMZA)
         ENDIF
      ENDIF
   ENDIF
ENDIF

DEALLOCATE(XA,XB)

! WRITE(*,*) NATOMS
! WRITE(*,*) 'RB FINISHING GEOMETRY'
! WRITE(*,'(A3,3G20.10)') ('LA ',RB(3*(J1-1)+1),RB(3*(J1-1)+2),RB(3*(J1-1)+3),J1=1,NATOMS)

RETURN

END SUBROUTINE NEWMINDIST

SUBROUTINE NEWROTGEOM(NATOMS,COORDS,MYROTMAT,CX,CY,CZ)
IMPLICIT NONE
INTEGER I, J, K, NATOMS
DOUBLE PRECISION COORDS(*), R1, R0(3), MYROTMAT(3,3), CX, CY, CZ

DO I=1,NATOMS
   R0(1)=COORDS(3*(I-1)+1)-CX
   R0(2)=COORDS(3*(I-1)+2)-CY
   R0(3)=COORDS(3*(I-1)+3)-CZ
   DO J=1,3
      R1=0.0D0
      DO K=1,3
         R1=R1+MYROTMAT(J,K)*R0(K)
      ENDDO
      IF (J.EQ.1) COORDS(3*(I-1)+J)=R1+CX
      IF (J.EQ.2) COORDS(3*(I-1)+J)=R1+CY
      IF (J.EQ.3) COORDS(3*(I-1)+J)=R1+CZ
   ENDDO
ENDDO

RETURN
END SUBROUTINE NEWROTGEOM

SUBROUTINE OLDROTGEOMSTOCK(NATOMS,COORDS,MYROTMAT,CX,CY,CZ)
IMPLICIT NONE
INTEGER I, J, K, NATOMS, NREALATOMS, J3, J1, OFFSET
DOUBLE PRECISION COORDS(*), R1, R0(3), MYROTMAT(3,3), CX, CY, CZ, X1, Y1, Z1, X2, Y2, Z2, CT1, ST1, P1, CP1, SP1, T1B, P1B, T1
DOUBLE PRECISION START(3), FINISH(3), DIFF, DIFFBEST, DUMMY
DOUBLE PRECISION, PARAMETER ::  PI=3.141592654D0

NREALATOMS=(NATOMS/2)
OFFSET = 3*NREALATOMS
!
! FIRST ROTATE THE DIPOLES.
!
DO J1=1,NREALATOMS
   J3=3*J1
   X1=COORDS(J3-2)-CX
   Y1=COORDS(J3-1)-CY
   Z1=COORDS(J3)-CZ
   T1=COORDS(OFFSET+J3-2)
   CT1=COS(T1)
   ST1=SIN(T1)
   P1=COORDS(OFFSET+J3-1)
   CP1=COS(P1)
   SP1=SIN(P1)
   X2=X1+ST1*CP1
   Y2=Y1+ST1*SP1
   Z2=Z1+CT1
   START(1)=MYROTMAT(1,1)*X1+MYROTMAT(1,2)*Y1+MYROTMAT(1,3)*Z1
   START(2)=MYROTMAT(2,1)*X1+MYROTMAT(2,2)*Y1+MYROTMAT(2,3)*Z1
   START(3)=MYROTMAT(3,1)*X1+MYROTMAT(3,2)*Y1+MYROTMAT(3,3)*Z1
   FINISH(1)=MYROTMAT(1,1)*X2+MYROTMAT(1,2)*Y2+MYROTMAT(1,3)*Z2
   FINISH(2)=MYROTMAT(2,1)*X2+MYROTMAT(2,2)*Y2+MYROTMAT(2,3)*Z2
   FINISH(3)=MYROTMAT(3,1)*X2+MYROTMAT(3,2)*Y2+MYROTMAT(3,3)*Z2
   DUMMY=FINISH(3)-START(3)
   IF (DUMMY.GT.1.0D0) DUMMY=1.0D0; IF (DUMMY.LT.-1.0D0) DUMMY=-1.0D0
   T1=ACOS(DUMMY)
   DIFFBEST=1.0D100
   IF (SIN(T1).NE.0.0D0) THEN
      DUMMY=(FINISH(1)-START(1))/SIN(T1)
      IF (DUMMY.GT.1.0D0) DUMMY=1.0D0; IF (DUMMY.LT.-1.0D0) DUMMY=-1.0D0
      P1=ACOS(DUMMY)
   ELSE
      P1=1.0D0
   ENDIF
   DIFFBEST=(FINISH(1)-START(1)-SIN(T1)*COS(P1))**2+(FINISH(2)-START(2)-SIN(T1)*SIN(P1))**2+(FINISH(3)-START(3)-COS(T1))**2
   T1B=T1; P1B=P1
   DIFF=(FINISH(1)-START(1)-SIN(2*PI-T1)*COS(P1))**2+(FINISH(2)-START(2)-SIN(2*PI-T1)*SIN(P1))**2+ &
  &          (FINISH(3)-START(3)-COS(2*PI-T1))**2
   IF (DIFF.LT.DIFFBEST) THEN
      T1B=2*PI-T1; P1B=P1
      DIFFBEST=DIFF
   ENDIF
   DIFF=(FINISH(1)-START(1)-SIN(2*PI-T1)*COS(2*PI-P1))**2+(FINISH(2)-START(2)-SIN(2*PI-T1)*SIN(2*PI-P1))**2+ &
  &           (FINISH(3)-START(3)-COS(2*PI-T1))**2
   IF (DIFF.LT.DIFFBEST) THEN
      T1B=2*PI-T1; P1B=2*PI-P1
      DIFFBEST=DIFF
   ENDIF
   DIFF=(FINISH(1)-START(1)-SIN(T1)*COS(2*PI-P1))**2+(FINISH(2)-START(2)-SIN(T1)*SIN(2*PI-P1))**2+(FINISH(3)-START(3)-COS(T1))**2
   IF (DIFF.LT.DIFFBEST) THEN
      T1B=T1; P1B=2*PI-P1
      DIFFBEST=DIFF
   ENDIF
   IF (DIFFBEST.GT.1.0D-5) THEN
      PRINT '(A,G20.10)','NEWROTGEOMSTOCK> WARNING - ANGLE ROTATION FAILED - DIFFBEST=',DIFFBEST
   ENDIF
!  PRINT '(A,G20.10)','NEWROTGEOMSTOCK> DIFFBEST=',DIFFBEST
!
!  INVERSE COS GIVES US AN ANGLE BETWEEN 0 AND PI. HOWEVER, 2*PI - ANGLE GIVES
!  THE SAME COS. THERE ARE THEREFORE TWO POSSIBILITIES FOR THETA AND TWO FOR PHI,
!  AND ONLY ONE SHOULD REGENERATE THE CORRECT DISPLACEMENTS. FIND IT!
!
   COORDS(OFFSET+J3-2)=T1B; COORDS(OFFSET+J3-1)=P1B
ENDDO

DO I=1,(NATOMS/2)
   R0(1)=COORDS(3*(I-1)+1)-CX
   R0(2)=COORDS(3*(I-1)+2)-CY
   R0(3)=COORDS(3*(I-1)+3)-CZ
   DO J=1,3
      R1=0.0D0
      DO K=1,3
         R1=R1+MYROTMAT(J,K)*R0(K)
      ENDDO
      IF (J.EQ.1) COORDS(3*(I-1)+J)=R1+CX
      IF (J.EQ.2) COORDS(3*(I-1)+J)=R1+CY
      IF (J.EQ.3) COORDS(3*(I-1)+J)=R1+CZ
   ENDDO
ENDDO

RETURN
END SUBROUTINE OLDROTGEOMSTOCK

SUBROUTINE NEWROTGEOMSTOCK(NATOMS,COORDS,MYROTMAT,CX,CY,CZ)
IMPLICIT NONE
INTEGER I, J, K, NATOMS, NREALATOMS, J3, J1, OFFSET
DOUBLE PRECISION COORDS(*), BEFORE(3), AFTER(3), MYROTMAT(3,3)
DOUBLE PRECISION CX, CY, CZ, THETA, PHI
DOUBLE PRECISION START(3), FINISH(3), DIFF, DIFFBEST, DUMMY
DOUBLE PRECISION, PARAMETER ::  PI=3.141592654D0

NREALATOMS=(NATOMS/2)
OFFSET = 3*NREALATOMS
DO J1=1,NREALATOMS
   J3 = J1*3
   THETA = COORDS(OFFSET+J3-2)
   PHI = COORDS(OFFSET+J3-1)
!  MAKE A UNIT VECTOR POINTING ALONG THE DIPOLE.
   BEFORE(1) = SIN(THETA) * COS(PHI)
   BEFORE(2) = SIN(THETA) * SIN(PHI)
   BEFORE(3) = COS(THETA)
!  ROTATE THE UNIT VECTOR USING THE ROTATION MATRIX.
   AFTER(1) = MYROTMAT(1,1)*BEFORE(1) + MYROTMAT(1,2)*BEFORE(2) + MYROTMAT(1,3)*BEFORE(3)
   AFTER(2) = MYROTMAT(2,1)*BEFORE(1) + MYROTMAT(2,2)*BEFORE(2) + MYROTMAT(2,3)*BEFORE(3)
   AFTER(3) = MYROTMAT(3,1)*BEFORE(1) + MYROTMAT(3,2)*BEFORE(2) + MYROTMAT(3,3)*BEFORE(3)
!  CONVERT THE UNIT VECTOR BACK TO SPHERICAL POLARS.
   IF (AFTER(3) > 1.0D0) AFTER(3)=1.0D0
   IF (AFTER(3) < -1.0D0) AFTER(3)=-1.0D0
   COORDS(OFFSET+J3-2) = ACOS(AFTER(3))
   COORDS(OFFSET+J3-1) = ATAN2(AFTER(2), AFTER(1))
ENDDO
!
! NOW ROTATE THE PARTICLE POSITIONS.
! 
DO I=1,(NATOMS/2)
   BEFORE(1)=COORDS(3*(I-1)+1)-CX
   BEFORE(2)=COORDS(3*(I-1)+2)-CY
   BEFORE(3)=COORDS(3*(I-1)+3)-CZ
   AFTER(1) = MYROTMAT(1,1)*BEFORE(1) + MYROTMAT(1,2)*BEFORE(2) + MYROTMAT(1,3)*BEFORE(3)
   AFTER(2) = MYROTMAT(2,1)*BEFORE(1) + MYROTMAT(2,2)*BEFORE(2) + MYROTMAT(2,3)*BEFORE(3)
   AFTER(3) = MYROTMAT(3,1)*BEFORE(1) + MYROTMAT(3,2)*BEFORE(2) + MYROTMAT(3,3)*BEFORE(3)
   COORDS(3*(I-1)+1) = AFTER(1) + CX
   COORDS(3*(I-1)+2) = AFTER(2) + CY
   COORDS(3*(I-1)+3) = AFTER(3) + CZ
ENDDO

RETURN
END SUBROUTINE NEWROTGEOMSTOCK
