!   NEB MODULE IS AN IMPLEMENTATION OF THE NUDGED ELASTIC BAND METHOD FOR PERFORMING DOUBLE-ENDED PATHWAY SEARCHES.
!   COPYRIGHT (C) 2003-2006 SEMEN A. TRYGUBENKO AND DAVID J. WALES
!   THIS FILE IS PART OF NEB MODULE. NEB MODULE IS PART OF OPTIM.
!
!   OPTIM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
!   IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
!   THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
!   (AT YOUR OPTION) ANY LATER VERSION.
!
!   OPTIM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
!   BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
!   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
!   GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
!
!   YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
!   ALONG WITH THIS PROGRAM; IF NOT, WRITE TO THE FREE SOFTWARE
!   FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330, BOSTON, MA  02111-1307  USA
!
MODULE NEWNEBMODULE
     IMPLICIT NONE
     CONTAINS

     SUBROUTINE NEWNEB(REDOPATH,TSREDO,EINITIAL,QQ,EFINAL,FINFIN,MOREP,NATOMSIN,NOPTIN,NINTSIN)
          USE PORFUNCS
          USE NEBDATA
          USE KEYNEB
          USE MINIMISER1
          USE MINIMISER2
          USE MINIMISER3
          USE NEBOUTPUT
          USE NEBUTILS
          USE KEY, ONLY : UNRST, GROWSTRINGT, FREEZENODEST, DESMDEBUG, &
               & NEBMUPDATE, MUPDATE, DEBUG, BFGSSTEPS, NEBRESEEDT, &
               & INTCONMAX, ORDERI, ORDERJ, EPSALPHA, REDOBFGSSTEPS, & 
               & NREPMAX, DISTREF, NEBKINITIAL, ADDREPT, REPPOW, REDOTSIM, MIN1REDO, MIN2REDO, PUSHOFF, &
               & CONI, CONJ, CONDISTREF, AMHT, NUMGLY, REPI, REPJ, BULKT, D1INIT, D2INIT, &
               & REDOKADD, REDOPATH1, &
               & REDOPATH2, NREPI, NREPJ, REPCUT, NREPCUT
          USE GROWSTRINGUTILS, ONLY: GROWSTRING, TOTSTEPS
          USE GSDATA, ONLY : KEYGSPRINT
          USE MODGUESS,ONLY: GUESSPATHT,NINTERP
          USE MODMEC,ONLY: MECCANOT          
          USE INTCOMMONS, ONLY : DESMINT, INTINTERPT, NINTIM, NDIH, DIHINFO, ALIGNDIR, PREVDIH, NINTC
          USE INTCUTILS, ONLY : INTINTERPOLATE, CART2INT
          USE SPFUNCTS, ONLY : DUMPCOORDS
          USE NEBTOCONNECT
          USE AMHGLOBALS, ONLY : NMRES
          USE COMMONS,ONLY: PARAM1,PARAM2,PARAM3,REDOPATHNEB,ZSYM
          IMPLICIT NONE

          COMMON /OLDC/ EMAX

          DOUBLE PRECISION,INTENT(IN)           :: EINITIAL, EFINAL
          DOUBLE PRECISION,DIMENSION(:)         :: QQ,FINFIN
          LOGICAL,INTENT(IN),OPTIONAL  :: MOREP
          INTEGER,INTENT(IN),OPTIONAL  :: NATOMSIN,NOPTIN,NINTSIN

          INTEGER :: J1,JMAX, NPERSIST, ITDONE, K, I, J2
          DOUBLE PRECISION :: EMAX
          DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: MYPTS ! JMC
          DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: VNEW, LCOORDS ! JMC
          LOGICAL PERSISTENT(NIMAGE+2)
          LOGICAL REDOPATH, MFLAG, PTEST, LPTEST, LRESET
          DOUBLE PRECISION ENERGY, RMS2, EREAL, TSREDO(*)

          ! EFK: FOR GROWSTRINGS AND INTERNALS
          DOUBLE PRECISION, ALLOCATABLE :: DELTAX(:)
          DOUBLE PRECISION, POINTER :: TANPTR(:,:)
          LOGICAL :: GSMFLAG
          LOGICAL :: FAILED

          LOGICAL :: KNOWE, KNOWG, KNOWH 
          COMMON /KNOWN/ KNOWE, KNOWG, KNOWH 

          IF (DESMDEBUG) THEN
          ! OUTPUT COORDINATES OF ENDPOINTS WE'RE TRYING TO CONNECT          
             CALL DUMPCOORDS(QQ,'TRYCONNECT.A.XYZ', .FALSE.)
             CALL DUMPCOORDS(FINFIN,'TRYCONNECT.B.XYZ', .FALSE.)
          ENDIF
          
          CALL MYCPU_TIME(STARTTIME,.TRUE.)
          ! SETUP PARAMETERS
          ! NATOMS,NOPT,NINTS,NIMAGE
          IF (PRESENT(NATOMSIN)) THEN
               NATOMS=NATOMSIN
          ELSE
               NATOMS=SIZE(QQ)/3
          ENDIF
          IF (NATOMS<=0) THEN
               PRINT '(1X,A)', 'NUMBER OF ATOMS IS LESS OR EQUAL TO ZERO. STOP.'
               CALL TSUMMARY
               STOP
          ELSE IF (DEBUG) THEN
               PRINT *, 'NEWNEB> NUMBER OF ATOMS = ',NATOMS
          ENDIF
          ALLOCATE(ORDERI(NREPMAX),ORDERJ(NREPMAX),EPSALPHA(NREPMAX),DISTREF(NREPMAX),REPPOW(NREPMAX))
          ALLOCATE(BADIMAGE(NIMAGE+2),BADPEPTIDE(NIMAGE+2))
          ADDREPT=.FALSE.
          IF (PRESENT(NOPTIN)) THEN
               NOPT=NOPTIN
          ELSE
             IF (DESMINT) THEN
                NOPT = NINTC
             ELSE IF (AMHT) THEN
                NOPT = 3*(NMRES*3)-NUMGLY*3 
             ELSE
                NOPT=3*NATOMS
             ENDIF
          ENDIF
          IF (PRESENT(NINTSIN)) THEN
               NINTS=NINTSIN
          ENDIF
          IF (NIMAGE<=0) THEN
               PRINT '(1X,A)', 'NUMBER OF IMAGES IS LESS OR EQUAL TO ZERO. STOP.'
               CALL TSUMMARY
               STOP
          ENDIF
          ! PRINTING
          IF (PRESENT(MOREP)) THEN
               MOREPRINTING=MOREP
          ENDIF
          IF (DEBUG.OR.DESMDEBUG) MOREPRINTING=.TRUE.
          IF (MOREPRINTING) THEN
             IF (GROWSTRINGT) THEN
                CALL KEYGSPRINT(.FALSE.)
             ELSE
                CALL ALLKEYNEBPRINT
             ENDIF
             PRINT*
          ENDIF

          IF (UNRST) THEN
               ALLOCATE(MYPTS(3*NATOMS*NIMAGE)) ! JMC
               GRADTYPE="DNEBU"
               TANTYPE=4
          ENDIF
          IF (OLDCONNECT) OPTIMIZETS = .FALSE.
          BADTAU=.FALSE.
          
          ! SET UP ARRAYS
          ALLOCATE(XYZ(NOPT*(NIMAGE+2)),GGG(NOPT*(NIMAGE+2)),SSS(NOPT*(NIMAGE+2)),EEE(NIMAGE+2), &
   &               RRR(NIMAGE+2),TANVEC(NOPT,NIMAGE),DVEC(NIMAGE+1),NEWNEBK(NIMAGE+1),DEVIATION(NIMAGE+1),STEPIMAGE(NIMAGE))

!         NEWNEBK(1:NIMAGE+1)=NEBK
          NEWNEBK(1:NIMAGE+1)=NEBKINITIAL

          IF (DESMINT) THEN
             ALLOCATE(XYZCART(3*NATOMS*(NIMAGE+2)), GGGCART(3*NATOMS*(NIMAGE+2)), TRUEGRAD(3*NATOMS*(NIMAGE+2)))
             ALLOCATE(DIHINFO(NIMAGE+2,NDIH))
             XCART => XYZCART(3*NATOMS+1:3*NATOMS*(NIMAGE+1))
             GCART => GGGCART(3*NATOMS+1:3*NATOMS*(NIMAGE+1))
             DIHINFO(:,:) = 0.0D0
          ELSE
             ALLOCATE(TRUEGRAD(NOPT*(NIMAGE+2)))
          ENDIF          

          X         => XYZ(NOPT+1:NOPT*(NIMAGE+1))
          EIMAGE    => EEE(2:NIMAGE+1)
          G         => GGG(NOPT+1:NOPT*(NIMAGE+1))
          GSPR      => SSS(NOPT+1:NOPT*(NIMAGE+1))
          RMSFIMAGE => RRR(2:NIMAGE+1)
          TANPTR => TANVEC
          EEE = 0.0D0
          EEE(1)=EINITIAL
          EEE(NIMAGE+2)=EFINAL
          IF (DESMINT.AND..NOT.GROWSTRINGT) THEN
          PRINT*, "NEWNEB>"
             XYZCART(:3*NATOMS) = QQ
             XYZCART(3*NATOMS*(NIMAGE+1)+1:) = FINFIN

             PREVDIH => DIHINFO(1,:)
             CALL CART2INT(QQ,XYZ(:NOPT))

             DO J1 = 2,NIMAGE+2
                ! ALIGN ALL OTHER DIHEDRALS TO START
                DIHINFO(J1,:) = DIHINFO(1,:)
             ENDDO

             ALIGNDIR = .TRUE.
             PREVDIH => DIHINFO(NIMAGE+2,:)
             CALL CART2INT(FINFIN,XYZ(NOPT*(NIMAGE+1)+1:))
             ALIGNDIR = .FALSE.
          ELSE
             XYZ(:NOPT)=QQ
             XYZ(NOPT*(NIMAGE+1)+1:)=FINFIN
          ENDIF
          TANPTR => TANVEC

          IF (FREEZENODEST.OR.NEBRESEEDT) THEN
             ALLOCATE(IMGFREEZE(NIMAGE))
             IMGFREEZE(:) = .FALSE.
          ENDIF

          IF(GROWSTRINGT) THEN
             IF((DESMINT.AND.NOPT.NE.NINTC).OR.(.NOT.DESMINT.AND.NOPT.NE.3*NATOMS)) THEN
                PRINT*, 'NOPT MUST BE EQUAL TO 3*NATOMS OR NINTC TO USE GROWSTRING.'
                PRINT*, DESMINT, NINTC, 3*NATOMS, NOPT
                STOP
             ENDIF
             IF (DESMINT) THEN
                CALL GROWSTRING(QQ, FINFIN, NIMAGE, XCART, EIMAGE, TANPTR,RMS,GSMFLAG)
                XYZ(:) = 0.0D0
             ELSE
                CALL GROWSTRING(QQ, FINFIN, NIMAGE, X, EIMAGE, TANPTR,RMS,GSMFLAG)
                CALL IMAGEDISTRIBUTION
             ENDIF
             NITERDONE = TOTSTEPS
             
          ELSE
             ! CONSTRUCT THE BAND
             IF (READGUESS.OR.(GUESSPATHT.AND.UNRST.AND.(NINTERP.GT.1)).OR.(MECCANOT)) THEN
                CALL RWG("R",.TRUE.,1)
                READGUESS = .FALSE.
             ELSE
                IF (UNRST) THEN ! JMC
                   CALL UNRESDIHENEB(QQ,FINFIN,MYPTS)
                   XYZ(NOPT+1:NOPT*(NIMAGE+1))=MYPTS(1:NOPT*NIMAGE)
                ELSEIF (REDOPATHNEB) THEN
                   REDOKADD=.TRUE.
                   REDOPATH1=.TRUE.
                   REDOTSIM=NIMAGE*D1INIT/(D1INIT+D2INIT)+1
                   XYZ(NOPT*REDOTSIM+1:NOPT*(REDOTSIM+1))=TSREDO(1:NOPT)
                   ALLOCATE(DELTAX(NOPT))
                   IF (BULKT) THEN
                      DO K=1,NATOMS
                         DELTAX(3*(K-1)+1)=XYZ(NOPT*REDOTSIM+3*(K-1)+1) - XYZ(3*(K-1)+1) &
  &                          -PARAM1*NINT((XYZ(NOPT*REDOTSIM+3*(K-1)+1) - XYZ(3*(K-1)+1))/PARAM1)
                         DELTAX(3*(K-1)+2)=XYZ(NOPT*REDOTSIM+3*(K-1)+2) - XYZ(3*(K-1)+2) &
  &                          -PARAM2*NINT((XYZ(NOPT*REDOTSIM+3*(K-1)+2) - XYZ(3*(K-1)+2))/PARAM2)
                         DELTAX(3*(K-1)+3)=XYZ(NOPT*REDOTSIM+3*(K-1)+3) - XYZ(3*(K-1)+3) &
  &                          -PARAM3*NINT((XYZ(NOPT*REDOTSIM+3*(K-1)+3) - XYZ(3*(K-1)+3))/PARAM3)
                      ENDDO
                      DELTAX(1:NOPT)=DELTAX(1:NOPT)/REDOTSIM
                   ELSE
                      DELTAX(1:NOPT) = ( XYZ(NOPT*REDOTSIM+1:NOPT*(REDOTSIM+1) ) - XYZ(1:NOPT) )/REDOTSIM
                   ENDIF
                   DO I=2,REDOTSIM
                      XYZ(NOPT*(I-1)+1:NOPT*I) = XYZ(1:NOPT) + DELTAX*(I-1)
                   ENDDO
                   IF (.NOT.ALLOCATED(VNEW)) ALLOCATE(VNEW(NOPT))
                   IF (.NOT.ALLOCATED(LCOORDS)) ALLOCATE(LCOORDS(NOPT))
                   IF (DEBUG) PRINT '(A)',' NEWNEB> MINIMISING ON THE START SIDE TO MAKE DNEB IMAGES'
                   LPTEST=.TRUE.
                   LCOORDS(1:NOPT)=TSREDO(1:NOPT)+PUSHOFF*(MIN1REDO(1:NOPT)-TSREDO(1:NOPT))/D1INIT
                   KNOWE=.FALSE.; KNOWG=.FALSE.
                   LRESET=.TRUE.
                   DO I=REDOTSIM,2,-1
                      CALL MYLBFGS(NOPT,MUPDATE,LCOORDS,.FALSE.,MFLAG,ENERGY,RMS2,EREAL,RMS,REDOBFGSSTEPS,LRESET, &
  &                                ITDONE,LPTEST,VNEW,.TRUE.,.FALSE.)
                      LRESET=.FALSE.
                      XYZ(NOPT*(I-1)+1:NOPT*I)=LCOORDS(1:NOPT)
                      IF (DEBUG) PRINT '(A,I6,A,F20.10)',' NEWNEB> ENERGY OF IMAGE ',I,' IS ',EREAL
                   ENDDO
                   REDOPATH1=.FALSE.
                   REDOPATH2=.TRUE.
                   IF (BULKT) THEN
                      DO K=1,NATOMS
                         DELTAX(3*(K-1)+1)=XYZ(NOPT*(NIMAGE+1)+3*(K-1)+1) - XYZ(NOPT*REDOTSIM+3*(K-1)+1) &
  &                          -PARAM1*NINT((XYZ(NOPT*(NIMAGE+1)+3*(K-1)+1) - XYZ(NOPT*REDOTSIM+3*(K-1)+1))/PARAM1)
                         DELTAX(3*(K-1)+2)=XYZ(NOPT*(NIMAGE+1)+3*(K-1)+2) - XYZ(NOPT*REDOTSIM+3*(K-1)+2) &
  &                          -PARAM2*NINT((XYZ(NOPT*(NIMAGE+1)+3*(K-1)+2) - XYZ(NOPT*REDOTSIM+3*(K-1)+2))/PARAM2)
                         DELTAX(3*(K-1)+3)=XYZ(NOPT*(NIMAGE+1)+3*(K-1)+3) - XYZ(NOPT*REDOTSIM+3*(K-1)+3) &
  &                          -PARAM3*NINT((XYZ(NOPT*(NIMAGE+1)+3*(K-1)+3) - XYZ(NOPT*REDOTSIM+3*(K-1)+3))/PARAM3)
                      ENDDO
                      DELTAX(1:NOPT)=DELTAX(1:NOPT)/(NIMAGE-REDOTSIM+1)
                   ELSE
                      DELTAX(1:NOPT) = ( XYZ(NOPT*(NIMAGE+1)+1:NOPT*(NIMAGE+2))    &
  &                                    - XYZ(NOPT*REDOTSIM+1:NOPT*(REDOTSIM+1)) )/(NIMAGE-REDOTSIM+1)
                   ENDIF
                   DO I=REDOTSIM+2,NIMAGE+1
                      XYZ(NOPT*(I-1)+1:NOPT*I) = TSREDO(1:NOPT) + DELTAX*(I-REDOTSIM-1)
                   ENDDO
                   IF (DEBUG) PRINT '(A)',' NEWNEB> MINIMISING ON THE FINISH SIDE TO MAKE DNEB IMAGES'
                   LCOORDS(1:NOPT)=TSREDO(1:NOPT)+PUSHOFF*(MIN2REDO(1:NOPT)-TSREDO(1:NOPT))/D2INIT
                   KNOWE=.FALSE.; KNOWG=.FALSE.
                   LRESET=.TRUE.
                   DO I=REDOTSIM+2,NIMAGE+1
                      CALL MYLBFGS(NOPT,MUPDATE,LCOORDS,.FALSE.,MFLAG,ENERGY,RMS2,EREAL,RMS,REDOBFGSSTEPS,LRESET, &
  &                                ITDONE,LPTEST,VNEW,.TRUE.,.FALSE.)
                      LRESET=.FALSE.
                      XYZ(NOPT*(I-1)+1:NOPT*I)=LCOORDS(1:NOPT)
                      IF (DEBUG) PRINT '(A,I6,A,F20.10)',' NEWNEB> ENERGY OF IMAGE ',I,' IS ',EREAL
                   ENDDO
                   DEALLOCATE(DELTAX,VNEW,LCOORDS)
                   KNOWE=.FALSE.; KNOWG=.FALSE.; KNOWH=.FALSE.
                   REDOKADD=.FALSE.
                   REDOPATH2=.FALSE.
                ELSEIF (REDOPATH) THEN
                   XYZ(NOPT+1:NOPT*2) = TSREDO(1:NOPT)
                   EEE(2)=1.0D100
                ELSE
                   IF (INTINTERPT) THEN
                      CALL INTINTERPOLATE(QQ,FINFIN,NINTIM,NIMAGE,X,DESMDEBUG,FAILED)
                   ELSE
                      CALL MAKEIMAGE(EINITIAL,EFINAL,QQ,FINFIN)
!                      PRINT *, 'XYZ'
!                      DO J1 = 1, NIMAGE+2
!                         DO J2 = 3,3 !1, NATOMS/2
!                            K = (J1-1)*3*NATOMS+J2*3
!                            PRINT *, K, XYZ(K)
!                         ENDDO
!                      ENDDO
!                      STOP
                   ENDIF
                ENDIF
             ENDIF
             IF (UNRST) DEALLOCATE(MYPTS) ! JMC

             ! PREOPTIMISE IF REQUESTED        
             IF (SQVVGUESS) THEN
                STEPTOT = 5.0D0 ! TO AVOID GRADIENT SCALING DURING SQVV
                CALL NEBSQVV(NOPT*NIMAGE)
             ENDIF
             
             NPERSIST=0
             IF ((.NOT.REDOPATH).OR.REDOPATHNEB) THEN
                SELECT CASE(MINTYPE)
                CASE("LBFGS")
                   IF (UNRST) THEN
                      CALL NEBBFGSINT(NINTS*NIMAGE,NEBMUPDATE)
                   ELSE
                      CALL NEBBFGS(NOPT*NIMAGE,NEBMUPDATE,NPERSIST,PERSISTENT)
                   END IF
                CASE("SQVV")
                   CALL NEBSQVV(NOPT*NIMAGE)
                END SELECT
             ENDIF
          ENDIF
          
          ! SAVE FINAL NEB COORDINATES AND ENERGY PROFILE
          IF (DEBUG) THEN
             PRINT '(A,F12.4)',' NEWNEB> MEAN IMAGE SEPARATION IS ',SEPARATION/(NIMAGE+1)
!            DO J1=1,NIMAGE+1
!               PRINT '(A,F12.4,A,I8,A,F12.4)',' NEWNEB> NEB K IS ',NEWNEBK(J1),' FOR GAP ',J1,' VALUE=',DVEC(J1)
!            ENDDO
          ENDIF

          IF (DUMPNEBEOS) CALL WRITEPROFILE(0)
!          PRINT *, 'XYZ'
!          DO J1 = 1, NIMAGE+2
!             DO J2 = 3,3 !1, NATOMS/2
!                K = (J1-1)*3*NATOMS+J2*3
!                PRINT *, K, XYZ(K)
!             ENDDO
!          ENDDO
!          STOP
          IF (DUMPNEBXYZ) CALL RWG("W",.FALSE.,0)
          IF (DUMPNEBPTS) CALL SAVEBANDCOORD

          IF (OLDCONNECT) THEN ! FIND THE HIGHEST ENERGY IMAGE
             IF (DESMINT) THEN
                PRINT*, 'NEWNEB>> ERROR! OLDCONNECT NOT IMPLEMENTED WITH DESMINT'
                STOP
             ENDIF
               EMAX=MAXVAL(EIMAGE)
               DO J1=1,NIMAGE
                    IF (EMAX == EIMAGE(J1)) JMAX=J1
               ENDDO
               QQ = X(NOPT*(JMAX-1)+1:NOPT*JMAX)
          ENDIF
          
          CALL MYCPU_TIME(ENDTIME,.FALSE.)

          NMINFOUND=0
          NTSFOUND=0
!
!  CURRENT STRUCTURE PRECLUDES SEARCHING THE NEB PROFILE FOR
!  BOTH MINIMA AND TS. COULD PERHAPS CHANGE THIS. CURRENT PHILOSOPHY IS
!  THAT IF WE HAVE PERSISTENT MINIMA WE SHOULD START THE WHOLE DNEB AGAIN
!  WITHOUT TS SEARCHES.
!
          IF (NPERSIST.GT.0) THEN
             PTEST=.FALSE.
             IF (DEBUG) PTEST=.TRUE.
             PRINT '(A,I8)',' NEWNEB> NUMBER OF PERSISTENT MINIMA IN DNEB PROFILE=',NPERSIST 
             DO J1=2,NIMAGE+1
                IF (PERSISTENT(J1)) THEN
                   KNOWG=.FALSE.
                   KNOWE=.FALSE. ! COULD USE EEE VALUE
                   IF (.NOT.ALLOCATED(VNEW)) ALLOCATE(VNEW(NOPT))
                   PRINT '(A,I8,A,F20.10)',' NEWNEB> MINIMISING IMAGE ',J1,' INITIAL ENERGY=',EEE(J1)
                   CALL MYLBFGS(NOPT,MUPDATE,XYZ(NOPT*(J1-1)+1:NOPT*J1),.FALSE., &
   &                            MFLAG,ENERGY,RMS2,EREAL,RMS,BFGSSTEPS,.TRUE.,ITDONE,PTEST,VNEW,.TRUE.,.FALSE.)
                   IF (MFLAG) THEN
                      NMINFOUND=NMINFOUND+1
!
!  WE HAVE TO COMMUNICATE THE MINIMA FOUND BACK TO TRYCONNECT USING THE DATA STRUCTURE
!  SET UP FOR NEW TRANSITION STATES. 
!  ADDED NEW VARIABLE MINFOUND TO ALLOW FOR THIS CHECK IN TRYCONNECT.
!  IT SEEMS IMPOSSIBLE TO MAKE NEWNEB SEE ISNEWMIN AND ADDNEWMIN FOR SOME REASON.
!
                      ALLOCATE(MINFOUND(NMINFOUND)%E,MINFOUND(NMINFOUND)%COORD(NOPT))
                      MINFOUND(NMINFOUND)%COORD(1:NOPT)=XYZ(NOPT*(J1-1)+1:NOPT*J1)
                      MINFOUND(NMINFOUND)%E=EREAL
                      WRITE(987,'(I6)') NATOMS
                      WRITE(987,'(A,I5)') 'IMAGE ',J1
                      WRITE(987,'(A,3G20.10)') (ZSYM(J2), MINFOUND(NMINFOUND)%COORD(3*(J2-1)+1:3*(J2-1)+3),J2=1,NATOMS)
                   ENDIF
                   DEALLOCATE(VNEW)
                ENDIF
             ENDDO
          ELSE
             CALL PRINTSUMMARY
             CALL TSLOCATOR
          ENDIF

          NULLIFY(X,EIMAGE)
          DEALLOCATE(DVEC,NEWNEBK,XYZ,EEE,GGG,TRUEGRAD,SSS,RRR,DEVIATION,TANVEC,STEPIMAGE,ORDERI,ORDERJ,EPSALPHA,DISTREF,REPPOW)
          DEALLOCATE(BADIMAGE,BADPEPTIDE)
          IF (FREEZENODEST) DEALLOCATE(IMGFREEZE)
          IF (DESMINT) THEN
             NULLIFY(XCART, GCART)
             DEALLOCATE(XYZCART,GGGCART,DIHINFO)
          ENDIF

     END SUBROUTINE NEWNEB
END MODULE NEWNEBMODULE
