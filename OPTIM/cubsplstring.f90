MODULE CUBSPLSTRING
  ! FUNCTIONS FOR DEALING WITH A STRING INTERPOLATED VIA CUBIC SPLINES
  ! WARNING: ARC LENGTH DERIVATIVES ARE NOT ALWAYS QUITE RIGHT!!!!
  ! THIS CAN OCCASSIONALLY MAKE FOLLOWARCNEWT FAIL TO CONVERGE

  USE GSDATA

  IMPLICIT NONE

  INTEGER :: DQAGKEY

  DOUBLE PRECISION, ALLOCATABLE, TARGET :: COEFF(:,:,:), ABSC(:)
  DOUBLE PRECISION, TARGET :: ARCTOL
  COMPLEX, PARAMETER :: CMPLXI=(0.0D0,1.0D0)

  INTEGER :: GLOBALB ! FOR USE IN CALCULATING ARCLENGTH WITH DQAG ONLY

CONTAINS
  SUBROUTINE INTERPCUBSPL
    ! STRING WITH INTERPOLATE WITH CUBIC SPLINES

    IMPLICIT NONE
    TYPE(IMGNODE), POINTER :: DUMMYP
    INTEGER, PARAMETER :: IBCBEG = 0, IBCEND = 0
    INTEGER :: CRD, IM

    DUMMYP => FIRST%PREV
    DO IM = 1, NIM+1 
       DUMMYP => DUMMYP%NEXT
       DUMMYP%DIFF(:) = DUMMYP%XYZ(:) - DUMMYP%PREV%XYZ(:)
       DUMMYP%CHORD = SQRT(DOT_PRODUCT(DUMMYP%DIFF, DUMMYP%DIFF))
       ABSC(IM+1) = ABSC(IM) + DUMMYP%CHORD ! ABSCISSA
       IF(.NOT.CUBSPLT) DUMMYP%ARC=ABSC(IM+1)
       COEFF(1,IM+1,:) = DUMMYP%XYZ(:) ! CUBIC SPLINE COEFFICIENTS  
    ENDDO

    DO CRD = 1,NC
       ! SET SECOND DERIVATIVES AT END POINTS EQUAL TO ZERO
       COEFF(2,1,CRD) = 0.0D0; COEFF(2,NIM+2,CRD) = 0.0D0

       CALL CUBSPL(ABSC(1:NIM+2), COEFF(1:4,1:NIM+2,CRD), NIM+2, IBCBEG, IBCEND)       
       COEFF(3,1:NIM+2,CRD) = COEFF(3,1:NIM+2,CRD) / 2
       COEFF(4,1:NIM+2,CRD) = COEFF(4,1:NIM+2,CRD) / 6
    ENDDO    
    
    IF(CUBSPLT) THEN
    ! CALCULATE THE ARC LENGTHS AT EACH IMAGE
    DUMMYP => FIRST%PREV
    DO IM = 1,NIM+1
       DUMMYP => DUMMYP%NEXT
       DUMMYP%ARCDIFF = ARCLENGTH(DUMMYP%CHORD, IM-1)
       DUMMYP%ARC = DUMMYP%PREV%ARC + DUMMYP%ARCDIFF
    ENDDO
    ENDIF
    STRINGLEN = DUMMYP%ARC

  END SUBROUTINE INTERPCUBSPL

  SUBROUTINE GETSPLVAL(X,B,N,ANS)
    ! GET VALUE OF NTH DERIVATIVE OF SPLINE, AT ABSCISSA X OVER B, PUT INTO ANS
    ! WARNING: DOES NOT CHECK FOR X TO BE WITHIN LIMITS

    DOUBLE PRECISION, INTENT(IN) :: X
    INTEGER, INTENT(IN) :: B, N
    DOUBLE PRECISION, INTENT(OUT) :: ANS(NC)

    IF (N.EQ.0) THEN
       ANS(:) = COEFF(4,B+1,:)*X**3+COEFF(3,B+1,:)*X**2+COEFF(2,B+1,:)*X + COEFF(1,B+1,:)
    ELSE IF(N.EQ.1) THEN
       ANS(:) = 3*COEFF(4,B+1,:)*X**2+2*COEFF(3,B+1,:)*X+COEFF(2,B+1,:)
    ELSE IF(N.EQ.2) THEN
       ANS(:) = 6*COEFF(4,B+1,:)*X+2*COEFF(3,B+1,:)
    ELSE
       PRINT*, 'N MUST BE 0,1,OR 2', N
       STOP
    ENDIF

  END SUBROUTINE GETSPLVAL

  DOUBLE PRECISION FUNCTION ARCDERV(X,B)
    ! GET NORM OF TANGENT AT SPLINE PARAMETER X OVER B
    IMPLICIT NONE

    DOUBLE PRECISION :: X, D(NC)
    INTEGER :: B

    CALL GETSPLVAL(X,B,1,D) ! GET SPLINE DERIVATIVE
    ARCDERV = SQRT(DOT_PRODUCT(D,D))
!    IF(BMCURPAIR.EQ.10) PRINT*, 'TESTXA: ', X, B, ARCDERV
    IF (ARCDERV.LT.TINY) THEN
       PRINT*, 'ERROR: VERY SMALL ARCDERV - BAD PARAMETRIZATION', X, B, ARCDERV
       STOP
    ENDIF
  END FUNCTION ARCDERV  

  DOUBLE PRECISION FUNCTION ARCDERVF(X)
    ! FUNCTION FOR CALLING WITH DQAG INTEGRATION
    ! WORKS JUST LIKE FUNCTION ARCDERV BUT USES THE 
    ! VARIABLE GLOBALB INSTEAD OF B
    ! GET NORM OF TANGENT AT SPLINE PARAMETER X OVER B
    IMPLICIT NONE

    DOUBLE PRECISION :: X
    DOUBLE PRECISION :: D(NC)

    CALL GETSPLVAL(X,GLOBALB,1,D) ! GET SPLINE DERIVATIVE
    ARCDERVF = SQRT(DOT_PRODUCT(D,D))
    IF (ARCDERVF.LT.TINY) THEN
       PRINT*, 'ERROR: VERY SMALL ARCDERV - BAD PARAMETRIZATION', &
            & X, GLOBALB, ARCDERVF
       STOP
    ENDIF
  END FUNCTION ARCDERVF

  DOUBLE PRECISION FUNCTION ARCLENGTH(X,B)
    ! CALCULATE THE ARC LENGTH FROM BASE IMAGE B TO X ABOVE THAT IMAGE
    ! ASSUME X IS BETWEEN 0 AND ABSC(B+2)-ABSC(B+1)
    ! USES ADAPTIVE QUADRATURE FUNCTION FROM SLATEC (DQAG)

    IMPLICIT NONE
    
    DOUBLE PRECISION :: X
    INTEGER :: B
    
    INTEGER, PARAMETER :: LIMIT = 100 ! MAXIMAL NUMBER OF SUBDIVISIONS
    DOUBLE PRECISION :: ANS, ERR
    INTEGER :: NEVAL, IERR
    INTEGER :: LAST, IWORK(LIMIT)
    DOUBLE PRECISION :: WORK(LIMIT*4)

    GLOBALB = B
    CALL DQAG(ARCDERVF,0.0D0, X, ARCTOL*0.1, 1.0D-16, DQAGKEY, ANS, ERR, NEVAL, IERR, LIMIT, LIMIT*4, LAST, IWORK, WORK)
    
    ARCLENGTH = ANS

!    PRINT*, 'TESTXA:', ANS, ERR, LAST
    IF(IERR.NE.0) THEN
       PRINT*, 'ERROR IN CALCULATING ARC LENGTH: ', X, B, ANS, ERR
       STOP
    ENDIF
    RETURN

  END FUNCTION ARCLENGTH    

  DOUBLE PRECISION FUNCTION FOLLOWARCNEWT(A, S, R)
    ! S IS THE IMAGE PROVIDING THE STARTING POINT
    ! R IS LOCATION OF S RELATIVE TO A: IF R = 0, S IS LOWER BOUND, IF R=1, S IS UPPER BOUND
    ! USE NEWTON-RAPHSTON TO FIND THE PARAMETER VALUE WITHIN APPROPRIATE SPLINE SEGMENT
    ! THAT GIVES AN ARC LENGTH OF A WITHIN THAT SEGMENT

    IMPLICIT NONE

    DOUBLE PRECISION :: A
    INTEGER :: S, R

    INTEGER :: ITS, MAXITS, B
    DOUBLE PRECISION :: X, FX, FPX, STEP
    DOUBLE PRECISION :: LOWER, UPPER

    MAXITS = 20

    IF (R.EQ.0) THEN
       B = S
    ELSE IF (R.EQ.1) THEN
       B = S-1
    ELSE
       PRINT*, 'R MUST BE 0 OR 1.'
       STOP
    ENDIF

    UPPER = ABSC(B+2)-ABSC(B+1)
    LOWER = 0.0D0

!    PRINT*, 'TESTFOLLOWARCNEWT: ', A, S, B, R, NIM, TIM
    
    X = ABSC(S+1)-ABSC(B+1)
    STEP = ARCTOL + 1
    ITS = 0
    DO WHILE (STEP.GT.ARCTOL)
       ITS = ITS + 1
       IF (ITS.GT.MAXITS) THEN
          IF (PTEST) PRINT*, 'FOLLOWARC NEWT FAILED! TAKING BISECTION STEP', A, S, R, ITS          
          X = (UPPER+LOWER)/2
          ITS = 1          
       ENDIF       
       FX = ARCLENGTH(X,B) - A

       ! KEEPS TRACK OF A LOWER AND UPPER BOUND IN CASE HAVE TO CALL BISECTION METHOD LATER

       IF (FX.GT.0.AND.X.LT.UPPER) THEN
          UPPER = X
       ELSE IF (FX.LT.0.AND.X.GT.LOWER) THEN
          LOWER = X
       ENDIF

       FPX = ARCDERV(X,B)
       STEP = ABS(FX/FPX)
       X = X-FX/FPX
    ENDDO

    FOLLOWARCNEWT = X
        
    RETURN
  END FUNCTION FOLLOWARCNEWT

  DOUBLE PRECISION FUNCTION FOLLOWARCBIS(A, B, L, U)
    ! FIND PARAMETER CORRESPONDING TO GIVEN ARCLENGTH BY BISECTION
    ! LESS EFFICIENT THAN FOLLOWARCNEWT, ONLY FOR USE WHERE THAT DOESN'T CONVERGE
    ! RETURNS PARAMETER ABOVE BASE IMAGE B CORRESPONDING TO ARCLENGTH A ABOVE B
    ! L AND U ARE STARTING UPPER AND LOWER BOUNDS

    DOUBLE PRECISION :: A, L, U
    INTEGER :: B, ITS
    DOUBLE PRECISION :: LOWER, UPPER, X, AX
    
    LOWER = L
    UPPER = U
    ITS = 0
    DO WHILE (ABS(AX-A).GT.ARCTOL.OR.ITS.EQ.0)
       ITS = ITS+1
       X = (UPPER+LOWER)/2
       AX = ARCLENGTH(X,B)
       PRINT '(A,5F20.10)', 'TESTXB: ', X, AX, LOWER, UPPER, A
       IF (AX.GT.A) THEN
          UPPER = X
       ELSE
          LOWER = X
       ENDIF
       IF (ITS.GT.1.0D6) THEN
          PRINT*, 'ERROR: BISECTION METHOD NOT CONVERGING! SOMETHING IS WRONG.'
          STOP
       ENDIF
    ENDDO
    FOLLOWARCBIS = X
    RETURN
  END FUNCTION FOLLOWARCBIS

END MODULE CUBSPLSTRING

