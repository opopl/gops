!   COPYRIGHT (C) 2010- DAVID J. WALES
!
!   OPTIM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
!   IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
!   THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
!   (AT YOUR OPTION) ANY LATER VERSION.
!
!   OPTIM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
!   BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
!   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
!   GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
!
!   YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
!   ALONG WITH THIS PROGRAM; IF NOT, WRITE TO THE FREE SOFTWARE
!   FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330, BOSTON, MA  02111-1307  USA
!
SUBROUTINE MAKE_CONPOT(NCPFIT,MINCOORDS)
USE KEY, ONLY : INTCONSEP, NREPMAX, NREPULSIVE, CONDISTREF, DEBUG, REPCON, INTCONSTRAINTREP, &
  & REPCUT, NCONSTRAINT, CONI, CONJ, CONDISTREF, CONDISTREFLOCAL, INTCONMAX, CONACTIVE, &
  & INTCONSTRAINREPCUT, INTREPSEP, REPI, REPJ, INTCONSTRAINTTOL, REPCUT, NREPI, NREPJ, NREPCUT, NNREPULSIVE
USE COMMONS, ONLY : NATOMS

IMPLICIT NONE 
DOUBLE PRECISION DMAX, DS, DF, DSHORT
DOUBLE PRECISION, ALLOCATABLE :: CPTEMP(:)
INTEGER, ALLOCATABLE :: ICPTEMP(:)
INTEGER :: J2,ISTAT,J1,J3,J4,NCPFIT,J5
INTEGER NCONFORNEWATOM, CONLIST(NATOMS), NCONATOM(NATOMS)
DOUBLE PRECISION :: DUMMY, NDIST, CONDIST(NATOMS), MINCOORDS(NCPFIT,3*NATOMS), DMIN, LINTCONSTRAINTTOL
LOGICAL CHANGED
INTEGER NDIST1(NATOMS), NCYCLE, DMIN1, DMAX1, NUNCON1

!
! FIND DISTANCES THAT ARE CONSERVED WITHIN TOLERANCE BETWEEN THE NCPFIT, MINIMA.
!
IF (.NOT.ALLOCATED(CONI)) THEN 
   ALLOCATE(CONI(INTCONMAX),CONJ(INTCONMAX),CONDISTREF(INTCONMAX))
   ALLOCATE(REPI(NREPMAX),REPJ(NREPMAX),NREPI(NREPMAX),NREPJ(NREPMAX),REPCUT(NREPMAX),NREPCUT(NREPMAX))
ENDIF
LINTCONSTRAINTTOL=INTCONSTRAINTTOL

51 NCONSTRAINT=0 
DSHORT=1.0D100
DO J2=1,NATOMS
   ATOM2: DO J3=J2+1,NATOMS
      IF (J3-J2.GT.INTCONSEP) CYCLE ATOM2 ! FORBID CONSTRAINTS CORRESPONDING TO ATOMS DISTANT IN SEQUENCE
      DUMMY=0.0D0
      DO J4=1,NCPFIT
         DO J5=J4+1,NCPFIT
!
!  DON;T CONSIDER CONSTRAINTS IF EITHER ENDPOINT DISTANCE IS > 5. 
!  DO WE REALLY NEED THIS? TURN IT OFF?
!
            DS=SQRT((MINCOORDS(J4,3*(J2-1)+1)-MINCOORDS(J4,3*(J3-1)+1))**2 &
  &                +(MINCOORDS(J4,3*(J2-1)+2)-MINCOORDS(J4,3*(J3-1)+2))**2 &
  &                +(MINCOORDS(J4,3*(J2-1)+3)-MINCOORDS(J4,3*(J3-1)+3))**2) 
            IF (DS.GT.5.0D0) CYCLE ATOM2
            DF=SQRT((MINCOORDS(J5,3*(J2-1)+1)-MINCOORDS(J5,3*(J3-1)+1))**2 &
  &                +(MINCOORDS(J5,3*(J2-1)+2)-MINCOORDS(J5,3*(J3-1)+2))**2 &
  &                +(MINCOORDS(J5,3*(J2-1)+3)-MINCOORDS(J5,3*(J3-1)+3))**2) 
            IF (DF.GT.5.0D0) CYCLE ATOM2
            IF (ABS(DS-DF).GT.LINTCONSTRAINTTOL) CYCLE ATOM2
            DUMMY=DUMMY+(DS+DF)/2.0D0
         ENDDO
      ENDDO
!
!  ADD CONSTRAINT FOR THIS DISTANCE TO THE LIST.
!
      NCONSTRAINT=NCONSTRAINT+1
!     PRINT '(A,2I6,A,I6)','MAKE_CONPOT> ADDING CONSTRAINT FOR ATOMS ',J2,J3,'  TOTAL=',NCONSTRAINT
      IF (NCONSTRAINT.GT.INTCONMAX) THEN
         ALLOCATE(ICPTEMP(INTCONMAX))
               
         ICPTEMP(1:INTCONMAX)=CONI(1:INTCONMAX)
         DEALLOCATE(CONI)
         ALLOCATE(CONI(2*INTCONMAX))
         CONI(1:INTCONMAX)=ICPTEMP(1:INTCONMAX)
               
         ICPTEMP(1:INTCONMAX)=CONJ(1:INTCONMAX)
         DEALLOCATE(CONJ)
         ALLOCATE(CONJ(2*INTCONMAX))
         CONJ(1:INTCONMAX)=ICPTEMP(1:INTCONMAX)
               
         DEALLOCATE(ICPTEMP)
         ALLOCATE(CPTEMP(1:INTCONMAX))
               
         CPTEMP(1:INTCONMAX)=CONDISTREF(1:INTCONMAX)
         DEALLOCATE(CONDISTREF)
         ALLOCATE(CONDISTREF(2*INTCONMAX))
         CONDISTREF(1:INTCONMAX)=CPTEMP(1:INTCONMAX)

         INTCONMAX=2*INTCONMAX
         DEALLOCATE(CPTEMP)
      ENDIF
      CONI(NCONSTRAINT)=J2
      CONJ(NCONSTRAINT)=J3
      CONDISTREF(NCONSTRAINT)=DUMMY/(NCPFIT*(NCPFIT-1)/2.0D0)
!     IF (DEBUG) PRINT '(A,2I6,A,2F12.2,A,F12.4,A,I8)',' MAKE_CONPOT> CONSTRAIN DISTANCE FOR ATOMS ',CONI(NCONSTRAINT), &
! &                     CONJ(NCONSTRAINT),' VALUES ARE ',DS,DF,' FRACTION=',2*ABS(DS-DF)/(DS+DF), &
! &                    ' # CONSTRAINTS=',NCONSTRAINT
   ENDDO ATOM2
ENDDO
!
! CHECK THAT WE HAVE A PERCOLATING CONSTRAINT NETWORK. IF NOT, INCREASE THE TOLERANCE AND TRY AGAIN!
! CALCULATE MINIMUM NUMBER OF STEPS OF EACH ATOM FROM NUMBER 1.
!
NDIST1(1:NATOMS)=1000000
NDIST1(1)=0
NCYCLE=0
5 CHANGED=.FALSE.
NCYCLE=NCYCLE+1
DMIN1=100000
DMAX1=0
NUNCON1=0
DO J1=1,NATOMS
   IF (NDIST1(J1).EQ.0) CYCLE ! MINIMUM 1
   DO J2=1,NCONSTRAINT
      IF (CONI(J2).EQ.J1) THEN
         IF (NDIST1(CONJ(J2))+1.LT.NDIST1(J1)) THEN
            CHANGED=.TRUE.
            NDIST1(J1)=NDIST1(CONJ(J2))+1
         ENDIF
      ELSE IF (CONJ(J2).EQ.J1) THEN
         IF (NDIST1(CONI(J2))+1.LT.NDIST1(J1)) THEN
            CHANGED=.TRUE.
            NDIST1(J1)=NDIST1(CONI(J2))+1
         ENDIF
      ENDIF
   ENDDO
   IF ((NDIST1(J1).GT.DMAX1).AND.(NDIST1(J1).NE.1000000)) DMAX1=NDIST1(J1)
   IF (NDIST1(J1).LT.DMIN1) DMIN1=NDIST1(J1)
   IF (NDIST1(J1).EQ.1000000) NUNCON1=NUNCON1+1
ENDDO
IF (CHANGED) GOTO 5
! PRINT '(3(A,I8))',' MAKE_CONPOT> STEPS TO ATOM 1 CONVERGED IN ',NCYCLE-1, &
!      &                    ' CYCLES; MAXIMUM=',DMAX1,' DISCONNECTED=',NUNCON1
IF (NUNCON1.GT.0) THEN
   LINTCONSTRAINTTOL=LINTCONSTRAINTTOL*1.1D0
   IF (DEBUG) PRINT '(A,F15.5)',' MAKE_CONPOT> INCREASING THE LOCAL CONSTRAINT TOLERANCE PARAMETER TO ',LINTCONSTRAINTTOL
   GOTO 51
ENDIF
NCONATOM(1:NATOMS)=0

! PRINT '(A,I6,2(A,F15.5))',' MAKE_CONPOT> TOTAL DISTANCE CONSTRAINTS=',NCONSTRAINT
! REPCON=-INTCONSTRAINTREP/INTCONSTRAINREPCUT**6
REPCON=-INTCONSTRAINTREP/INTCONSTRAINREPCUT
IF (ALLOCATED(CONDISTREFLOCAL)) THEN
   DEALLOCATE(CONDISTREFLOCAL)
ENDIF
ALLOCATE(CONDISTREFLOCAL(NCONSTRAINT))
CONDISTREFLOCAL(1:NCONSTRAINT)=CONDISTREF(1:NCONSTRAINT)
DUMMY=1.0D100
NREPULSIVE=0
!
! ADD REPULSIONS TO NON-CONSTRAINED ATOMS.
! NOTE THAT WE DO NOT LIMIT THE NUMBER OF CONSTRAINTS PER SITE IN THIS
! ROUTINE, UNLIKE NEB/LBFGS.F90, WHERE THE RESULT WILL DEPEND ON THE
! ORDER IN WHICH THE CONSTRAINTS ARE TURNED ON. 
!
DO J1=1,NATOMS
   REP2: DO J2=J1+1,NATOMS
      IF (ABS(J1-J2).LE.INTREPSEP) CYCLE ! NO REPULSION FOR ATOMS TOO CLOSE IN SEQUENCE
      DO J3=1,NCONSTRAINT
         IF ((CONI(J3).EQ.J1).AND.(CONJ(J3).EQ.J2)) CYCLE REP2
         IF ((CONI(J3).EQ.J2).AND.(CONJ(J3).EQ.J1)) CYCLE REP2
      ENDDO
      DMIN=1.0D100
      DMAX=-1.0D0
      DO J3=1,NCPFIT
         DF=SQRT((MINCOORDS(J3,3*(J1-1)+1)-MINCOORDS(J3,3*(J2-1)+1))**2+ &
  &              (MINCOORDS(J3,3*(J1-1)+2)-MINCOORDS(J3,3*(J2-1)+2))**2+ &
  &              (MINCOORDS(J3,3*(J1-1)+3)-MINCOORDS(J3,3*(J2-1)+3))**2)
         IF (DF.GT.DMAX) DMAX=DF
         IF (DF.LT.DMIN) DMIN=DF
      ENDDO
      
      NREPULSIVE=NREPULSIVE+1
      IF (NREPULSIVE.GT.NREPMAX) THEN
         ALLOCATE(ICPTEMP(NREPMAX),CPTEMP(NREPMAX))

         ICPTEMP(1:NREPMAX)=REPI(1:NREPMAX)
         DEALLOCATE(REPI)
         ALLOCATE(REPI(2*NREPMAX))
         REPI(1:NREPMAX)=ICPTEMP(1:NREPMAX)
         ICPTEMP(1:NREPMAX)=REPJ(1:NREPMAX)
         DEALLOCATE(REPJ)
         ALLOCATE(REPJ(2*NREPMAX))
         REPJ(1:NREPMAX)=ICPTEMP(1:NREPMAX)
         CPTEMP(1:NREPMAX)=REPCUT(1:NREPMAX)
         DEALLOCATE(REPCUT)
         ALLOCATE(REPCUT(2*NREPMAX))
         REPCUT(1:NREPMAX)=CPTEMP(1:NREPMAX)

         ICPTEMP(1:NREPMAX)=NREPI(1:NREPMAX)
         DEALLOCATE(NREPI)
         ALLOCATE(NREPI(2*NREPMAX))
         NREPI(1:NREPMAX)=ICPTEMP(1:NREPMAX)
         ICPTEMP(1:NREPMAX)=NREPJ(1:NREPMAX)
         DEALLOCATE(NREPJ)
         ALLOCATE(NREPJ(2*NREPMAX))
         NREPJ(1:NREPMAX)=ICPTEMP(1:NREPMAX)
         CPTEMP(1:NREPMAX)=NREPCUT(1:NREPMAX)
         DEALLOCATE(NREPCUT)
         ALLOCATE(NREPCUT(2*NREPMAX))
         NREPCUT(1:NREPMAX)=CPTEMP(1:NREPMAX)

         DEALLOCATE(ICPTEMP,CPTEMP)
         NREPMAX=2*NREPMAX
      ENDIF
      REPI(NREPULSIVE)=J1
      REPJ(NREPULSIVE)=J2
!
! USE THE MINIMUM OF THE END POINT DISTANCES AND INTCONSTRAINREPCUT FOR EACH CONTACT.
!
      REPCUT(NREPULSIVE)=MIN(DMIN-1.0D-3,INTCONSTRAINREPCUT)
!     IF (DEBUG) PRINT '(A,I6,A,I6,A,F15.5,A,I10)',' MAKE_CONPOT> ADDING REPULSION FOR ATOM ',J1, &
! &              ' WITH ATOM ',J2,' CUTOFF=',DMIN,' # REPULSIONS ',NREPULSIVE
   ENDDO REP2
ENDDO

IF (DEBUG) PRINT '(A,2I10,A,G20.10)',' MAKE_CONPOT> TOTAL NUMBER OF CONSTRAINTS AND REPULSIONS=',NCONSTRAINT,NREPULSIVE, &
  & ' FOR TOLERANCE PARAMETER ',LINTCONSTRAINTTOL

IF (ALLOCATED(CONACTIVE)) DEALLOCATE(CONACTIVE)
ALLOCATE(CONACTIVE(NCONSTRAINT))
CONACTIVE(1:NCONSTRAINT)=.TRUE. 
!
! CONGRAD ROUTINES ACTUALLY USE NREPI, NREPJ, ETC., SO WE MUST ASSIGN THESE.
!
NREPI(1:NREPULSIVE)=REPI(1:NREPULSIVE)
NREPJ(1:NREPULSIVE)=REPJ(1:NREPULSIVE)
NNREPULSIVE=NREPULSIVE
NREPCUT(1:NREPULSIVE)=REPCUT(1:NREPULSIVE)

RETURN
END SUBROUTINE MAKE_CONPOT

SUBROUTINE CONPOT(COORDS1,COORDS2,ETOTAL)
USE KEY, ONLY : NREPMAX, NREPULSIVE, CONDISTREF, DEBUG, INTCONSTRAINTDEL, &
  & REPCUT, NCONSTRAINT, CONI, CONJ, INTCONMAX, INTCONSTRAINTREP, &
  & INTCONSTRAINREPCUT, REPI, REPJ, REPCUT, CONDISTREFLOCAL, NNREPULSIVE, NREPCUT, NREPI, NREPJ
USE COMMONS, ONLY : NATOMS
IMPLICIT NONE
           
INTEGER :: J1,J2,NI,NJ
DOUBLE PRECISION :: ECON, EREP, ETOTAL
DOUBLE PRECISION R1AX,R1AY,R1AZ,R2AX,R2AY,R2AZ,R1BX,R1BY,R1BZ,R2BX,R2BY,R2BZ,DMIN,DMAX
DOUBLE PRECISION G1MAX(3),G2MIN(3),CONCUT,DINT,G1INT(3),G2INT(3)
DOUBLE PRECISION DUMMY, REPGRAD(3), INTCONST, D12, DSQ0, DSQP, DSQI, COORDS1(3*NATOMS), COORDS2(3*NATOMS)
LOGICAL NOINT

ECON=0.0D0; EREP=0.0D0
!
!  CONSTRAINT POTENTIAL ENERGY AND (OPTIONALLY) FORCES.
!
DO J2=1,NCONSTRAINT
!
! WE CONSIDER THE LINE SEGMENT BETWEEN COORDS1 AND COORDS2
! A AND B REFER TO ATOMS, 1 AND 2 TO COORDS1 AND COORDS2
!
   NI=3*(CONI(J2)-1)
   NJ=3*(CONJ(J2)-1)
   R1AX=COORDS1(NI+1); R1AY=COORDS1(NI+2); R1AZ=COORDS1(NI+3)
   R1BX=COORDS1(NJ+1); R1BY=COORDS1(NJ+2); R1BZ=COORDS1(NJ+3)
   R2AX=COORDS2(NI+1); R2AY=COORDS2(NI+2); R2AZ=COORDS2(NI+3)
   R2BX=COORDS2(NJ+1); R2BY=COORDS2(NJ+2); R2BZ=COORDS2(NJ+3)
   CALL MINMAXD2(R1AX,R1AY,R1AZ,R2AX,R2AY,R2AZ,R1BX,R1BY,R1BZ,R2BX,R2BY,R2BZ, &
  &              DMIN,DMAX,DINT,G1MAX,G2MIN,G1INT,G2INT,NOINT,.FALSE.)
!
! NEED TO INCLUDE BOTH DMIN AND DMAX CONTRIBUTIONS IF THEY ARE BOTH OUTSIDE TOLERANCE.
! OTHERWISE WE GET DISCONTINUITIES IF THEY ARE VERY CLOSE AND SWAP OVER.
!
! TERMS FOR IMAGE J1 - NON-ZERO DERIVATIVES ONLY FOR J1
!
   IF (ABS(DMIN-CONDISTREFLOCAL(J2)).GT.CONCUT) THEN 
      DUMMY=DMIN-CONDISTREFLOCAL(J2)  
      ECON=ECON+INTCONSTRAINTDEL*(DUMMY**2-CONCUT**2)**2/(2.0D0*CONCUT**2)
   ENDIF
!
! TERMS FOR IMAGE J1-1 - NON-ZERO DERIVATIVES ONLY FOR J1-1
!
   IF (ABS(DMAX-CONDISTREFLOCAL(J2)).GT.CONCUT) THEN  
      DUMMY=DMAX-CONDISTREFLOCAL(J2)  
      ECON=ECON+INTCONSTRAINTDEL*(DUMMY**2-CONCUT**2)**2/(2.0D0*CONCUT**2)
   ENDIF
   IF ((.NOT.NOINT).AND.(ABS(DINT-CONDISTREFLOCAL(J2)).GT.CONCUT)) THEN
      DUMMY=DINT-CONDISTREFLOCAL(J2)  
      ECON=ECON+INTCONSTRAINTDEL*(DUMMY**2-CONCUT**2)**2/(2.0D0*CONCUT**2)
   ENDIF
ENDDO

DO J2=1,NNREPULSIVE
!  INTCONST=NREPCUT(J2)**13
   INTCONST=NREPCUT(J2)**3
   NI=3*(NREPI(J2)-1)
   NJ=3*(NREPJ(J2)-1)
   R1AX=COORDS1(NI+1); R1AY=COORDS1(NI+2); R1AZ=COORDS1(NI+3)
   R1BX=COORDS1(NJ+1); R1BY=COORDS1(NJ+2); R1BZ=COORDS1(NJ+3)
   R2AX=COORDS2(NI+1); R2AY=COORDS2(NI+2); R2AZ=COORDS2(NI+3)
   R2BX=COORDS2(NJ+1); R2BY=COORDS2(NJ+2); R2BZ=COORDS2(NJ+3)
   CALL MINMAXD2R(R1AX,R1AY,R1AZ,R2AX,R2AY,R2AZ,R1BX,R1BY,R1BZ,R2BX,R2BY,R2BZ, &
  &                 DMIN,DMAX,DINT,DSQ0,DSQP,DSQI,G1MAX,G2MIN,G1INT,G2INT,NOINT,.FALSE.,NREPCUT(J2))
   DUMMY=0.0D0 
   IF (DMIN.LT.NREPCUT(J2)) THEN ! TERMS FOR IMAGE J1 - NON-ZERO DERIVATIVES ONLY FOR J1
!     D12=DSQ0**6
      D12=DSQ0
!     DUMMY=INTCONSTRAINTREP*(1.0D0/D12+(12.0D0*DMIN-13.0D0*NREPCUT(J2))/INTCONST)
      DUMMY=INTCONSTRAINTREP*(1.0D0/D12+(2.0D0*DMIN-3.0D0*NREPCUT(J2))/INTCONST)
      EREP=EREP+DUMMY
   ENDIF
   DUMMY=0.0D0
   IF (DMAX.LT.NREPCUT(J2)) THEN ! TERMS FOR IMAGE J1-1 - NON-ZERO DERIVATIVES ONLY FOR J1-1
!     D12=DSQP**6
      D12=DSQP
!     DUMMY=INTCONSTRAINTREP*(1.0D0/D12+(12.0D0*DMAX-13.0D0*NREPCUT(J2))/INTCONST)
      DUMMY=INTCONSTRAINTREP*(1.0D0/D12+(2.0D0*DMAX-3.0D0*NREPCUT(J2))/INTCONST)
      EREP=EREP+DUMMY
   ENDIF
   DUMMY=0.0D0
   IF ((.NOT.NOINT).AND.(DINT.LT.NREPCUT(J2))) THEN
!     D12=DSQI**6
      D12=DSQI
!     DUMMY=INTCONSTRAINTREP*(1.0D0/D12+(12.0D0*DINT-13.0D0*NREPCUT(J2))/INTCONST)
      DUMMY=INTCONSTRAINTREP*(1.0D0/D12+(2.0D0*DINT-3.0D0*NREPCUT(J2))/INTCONST)
      EREP=EREP+DUMMY
   ENDIF
ENDDO

ETOTAL=EREP+ECON

END SUBROUTINE CONPOT

