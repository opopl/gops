C   GPL LICENSE INFO {{{      
C   OPTIM: A PROGRAM FOR OPTIMIZING GEOMETRIES AND CALCULATING REACTION PATHWAYS
C   COPYRIGHT (C) 1999-2006 DAVID J. WALES
C   THIS FILE IS PART OF OPTIM.
C
C   OPTIM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C   IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C   THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C   (AT YOUR OPTION) ANY LATER VERSION.
C
C   OPTIM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
C   BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
C   GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C   YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C   ALONG WITH THIS PROGRAM; IF NOT, WRITE TO THE FREE SOFTWARE
C   FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330, BOSTON, MA  02111-1307  USA
C}}}
C
C        LIMITED MEMORY BFGS METHOD FOR LARGE SCALE OPTIMIZATION
C                          JORGE NOCEDAL
C                        *** JULY 1990 ***
C
C        LINE SEARCH REMOVED PLUS SMALL MODIFICATIONS, DJW 2001
C        IF INTMINT IS TRUE, THEN N IS NINTS, 
C        OTHERWISE N = NOPT JMC
C        CHANGED DECLARATION OF X(N) TO X(3*NATOMS) 30/4/04
C        X IS PASSED IN AND OUT IN CARTESIANS.
C
C  CARTESIAN COORDINATE AND GRADIENT VECTORS ARE DECLARED 3*NATOMS - THE COMPLICATION
C  IS THAT FOR INTERNAL COORDINATE OPTIMISATIONS WE CAN HAVE A NUMBER OF DEGREES OF
C  FREEDOM THAT IS MORE OR LESS THAN 3*NATOMS. N SHOULD SPECIFY THIS DIMENSION.
C
      SUBROUTINE MYLBFGS(N,M,X,DIAGCO,MFLAG,ENERGY,RMS,EREAL,REALRMS,ITMAX,
     1                   RESET,ITDONE,PTEST,GSAVE,NODUMP,PROJECT)
      ! DECLARATIONS {{{
      USE COMMONS
      USE KEY
      USE MODTWOEND
      USE MODHESS
      USE ZWK
      USE MODUNRES
      USE MODCHARMM
      USE MODAMBER9, ONLY : NRESPA2, IRESPA2
      USE PORFUNCS
      USE SPFUNCTS, ONLY : DUMPCOORDS
      
      IMPLICIT NONE
      INTEGER N,M,J1,J2,ITMAX,ITDONE,NFAIL,NCOUNT
C     DOUBLE PRECISION X(*),G(3*NATOMS),DIAG(N),W(N*(2*M+1)+2*M),SLENGTH,DDOT,VEC2(3*NATOMS),OVERLAP
      DOUBLE PRECISION X(3*NATOMS),G(3*NATOMS),SLENGTH,DDOT,VEC2(3*NATOMS),OVERLAP,DISTF,DISTS,GAMMA
      DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) :: DIAG, W
      DOUBLE PRECISION DUMMY1,ENERGY,ENEW,RMS,EREAL,REALRMS,RVEC(3*NATOMS),ALPHA,GSAVE(3*NATOMS),DUMMY2
      LOGICAL DIAGCO, RESET, PTEST, NODUMP, PROJECT
      DOUBLE PRECISION GNORM,STP,YS,YY,SQ,YR,BETA
      LOGICAL NOCOOR, NODERV ! INTERNALS STUFF
      DOUBLE PRECISION DELTAQ(N),DELTACART(3*NATOMS)
      DOUBLE PRECISION CART(3*NATOMS),OLDQ(N),NEWQ(N),OLDGINT(N),GINT(N),XINT(N) ! JMC
      DOUBLE PRECISION OLDCART(3*NATOMS),TMPINT(NINTS) ! JMC
      DOUBLE PRECISION GLAST(3*NATOMS),XSAVE(N)
      INTEGER ITER,POINT,ISPT,IYPT,BOUND,NPT,CP,I,INMC,IYCN,ISCN,I1,NREV
      INTEGER KD, NNZ
      LOGICAL MFLAG,FAILED
      DOUBLE PRECISION GSQSCALE, GSTHRESH, DOT1, DOT2
      INTEGER NSPECIAL, NALLOW, NINFO, FRAME
      LOGICAL PVFLAG
      COMMON /PVF/ PVFLAG
      COMMON /G2/ GSTHRESH, GSQSCALE, NSPECIAL, NALLOW, NINFO
      LOGICAL PATHT, DRAGT
      INTEGER NPATHFRAME, NDECREASE, ISTAT
      COMMON /RUNTYPE/ DRAGT, PATHT, NPATHFRAME
      LOGICAL KNOWE, KNOWG, KNOWH
      COMMON /KNOWN/ KNOWE, KNOWG, KNOWH
      CHARACTER ESTRING*87, GPSTRING*80, NSTRING*80, FSTRING*80
      COMMON /STRINGS/ ESTRING, GPSTRING, NSTRING, FSTRING
      LOGICAL RADMOVED, OVERLP
      COMMON /DISCON/ RADMOVED, OVERLP
      LOGICAL PUSH, PULL
      COMMON /MORPHDATA/ PUSH, PULL
      CHARACTER(LEN=5) ZSYMSAVE
      COMMON /SYS/ ZSYMSAVE

C
C  NUMERICAL DERIVATIVE FOR G^2
C
C     DOUBLE PRECISION SHIT, EPLUS, EMINUS, GDUM(3*NATOMS), RMSDUM, HDUM(3*NATOMS,3*NATOMS)
C     LOGICAL FIXSAVE
C
C  SGI APPEARS TO NEED THIS SAVE STATEMENT!
C
      SAVE W, DIAG, ITER, POINT, ISPT, IYPT, NPT
!}}}

      IF (.NOT.ALLOCATED(DIAG)) ALLOCATE(DIAG(N))       ! SAVE DOESN'T WORK OTHERWISE FOR SUN
      IF (.NOT.ALLOCATED(W)) ALLOCATE(W(N*(2*M+1)+2*M)) ! SAVE DOESN'T WORK OTHERWISE FOR SUN
      IF (SIZE(W,1).NE.N*(2*M+1)+2*M) THEN ! MUSTN'T CALL MYLBFGS WITH CHANGING NUMBER OF VARIABLES!!!
         PRINT '(A,I10,A,I10,A)', ' MYLBFGS> ERROR, DIMENSION OF W=',SIZE(W,1),' BUT N*(2*M+1)+2*M=',N*(2*M+1)+2*M
         STOP
      ENDIF

      IF (N.NE.3*NATOMS) THEN
         IF ((.NOT.UNRST).AND.(.NOT.(CHRMMT.AND.INTMINT)).AND.(.NOT.VARIABLES).AND.(.NOT.RINGPOLYMERT)) THEN
            PRINT*,'ERROR - N AND 3*NATOMS ARE DIFFERENT IN MYLBFGS: ',N,3*NATOMS
            STOP
         ENDIF
      ENDIF
! FOR CHARMM: UPDATE NONBONDED LIST AT THE START OF EACH MINIMIZATION
      IF(CHRMMT) CALL UPDATENBONDS(X)

      ALPHA=1.0D0
      NFAIL=0
      FRAME=1
      CFUSIONT=.FALSE.
      IF (RESET) ITER=0
      ITDONE=0
      IF (RESET.AND.PTEST) WRITE(*,'(A)') ' MYLBFGS> RESETTING LBFGS MINIMISER'
      IF ((.NOT.RESET).AND.PTEST) WRITE(*,'(A)') ' MYLBFGS> NOT RESETTING LBFGS MINIMISER'
1     FIXIMAGE=.FALSE.
      IF (PV.AND.(.NOT.PROJECT)) THEN
         IF (.NOT.KNOWE) THEN 
            CALL POTENTIAL(X,ENERGY,GSAVE,.FALSE.,.FALSE.,RMS,.FALSE.,.FALSE.)

! CHECK FOR COLD FUSION
            PRINT*, "MSB50 IN MYLBFGS, ENERGY", ENERGY
            IF (ENERGY.LT.COLDFUSIONLIMIT) THEN
               WRITE(*,'(A,2G20.10)') ' MYLBFGS> COLD FUSION DIAGNOSED - STEP DISCARDED, ENERGY, LIMIT=',ENERGY,COLDFUSIONLIMIT
               ENERGY=1.0D60
               EREAL=1.0D60
               RMS=1.0D1
               CFUSIONT=.TRUE.
               RETURN
            ENDIF
         ENDIF
         PVFLAG=.FALSE.
         CALL PVOPT(X,ENERGY,GSAVE)
      ENDIF

      IF (UNRST) THEN
         DO J2=1,NRES
            C(1,J2)=X(6*(J2-1)+1)
            C(2,J2)=X(6*(J2-1)+2)
            C(3,J2)=X(6*(J2-1)+3)
            C(1,J2+NRES)=X(6*(J2-1)+4)
            C(2,J2+NRES)=X(6*(J2-1)+5)
            C(3,J2+NRES)=X(6*(J2-1)+6)
         END DO
         CALL UPDATEDC
!CALL INT_FROM_CART(.TRUE.,.FALSE.)
C
C JMC 9/1/03 NEED THIS CALL TO CHAINBUILD TO CALCULATE XROT,XLOC MATRICES WHICH ARE USED
C IN THE CALCULATION OF D(BOND VECTORS) BY D(INTERNALS).
C
!CALL CHAINBUILD
      ENDIF

      IF ((.NOT.KNOWE).OR.(.NOT.KNOWG)) THEN
         IF(AMBERT.OR.NABT) IRESPA2=ITDONE+1
         RMS=0.0D0
         CALL POTENTIAL(X,ENERGY,GSAVE,.TRUE.,GRADSQ,RMS,.FALSE.,.FALSE.)
         REALRMS=RMS
         IF (ENERGY.LT.COLDFUSIONLIMIT) THEN
            WRITE(*,'(A,2G20.10)') ' MYLBFGS> COLD FUSION DIAGNOSED - STEP DISCARDED, ENERGY, LIMIT=',ENERGY,COLDFUSIONLIMIT
            ENERGY=1.0D60
            EREAL=1.0D60
            RMS=1.0D1
            REALRMS=RMS
            CFUSIONT=.TRUE.
            RETURN
         ENDIF
      ELSE
         RMS=REALRMS
      ENDIF

      G(1:3*NATOMS)=GSAVE(1:3*NATOMS)
      GLAST(1:3*NATOMS)=GSAVE(1:3*NATOMS)
      IF (.NOT.(NODUMP)) CALL DUMPP(X,ENERGY)


      IF (TWOENDS.AND.(.NOT.TTDONE).AND.(FORCE.NE.0.0D0)) THEN
         IF (CHRMMT.AND.INTMINT) THEN
            PRINT*,'ERROR - TWOENDS NOT AVAILABLE FOR CHARMM INTERNAL COORDINATES'
            STOP
         ENDIF
         DUMMY1=0.0D0
         DO J1=1,N
            RVEC(J1)=FIN(J1)-X(J1)
            DUMMY1=DUMMY1+RVEC(J1)**2
         ENDDO
         DUMMY1=1.0D0/SQRT(DUMMY1)
         IF (1.0D0/DUMMY1.GT.0.05D0) THEN
            RMS=0.0D0
            DO J1=1,N
               G(J1)=G(J1)+FORCE*RVEC(J1)*DUMMY1
               RMS=RMS+G(J1)**2
            ENDDO
            RMS=SQRT(RMS/N)
         ENDIF
      ELSE IF (DRAGT) THEN
         IF (CHRMMT.AND.INTMINT) THEN
            PRINT*,'ERROR - DRAG NOT AVAILABLE FOR CHARMM INTERNAL COORDINATES'
            STOP
         ENDIF
         IF (N.GT.3*NATOMS) THEN
            PRINT*,'ERROR N > 3*NATOMS IN MYLBFGS'
            STOP
         ENDIF
         DUMMY1=0.0D0
         DO J1=1,N
            RVEC(J1)=FIN(J1)-X(J1)
            DUMMY1=DUMMY1+RVEC(J1)**2
         ENDDO
         DUMMY1=1.0D0/SQRT(DUMMY1)
         WRITE(*,'(A,F20.10)') 'DIST=',1.0D0/DUMMY1
         DO J1=1,N
            RVEC(J1)=RVEC(J1)*DUMMY1
         ENDDO
         DUMMY1=0.0D0
         DO J1=1,N
            DUMMY1=DUMMY1+RVEC(J1)*G(J1)
         ENDDO
         PRINT*,'PROJECTION OF GRADIENT=',DUMMY1
C        IF (DUMMY1.GT.0.0D0) THEN
            RMS=0.0D0
            DO J1=1,N
               G(J1)=G(J1)-DUMMY1*RVEC(J1)-0.1D0*RVEC(J1)
               RMS=RMS+G(J1)**2
            ENDDO
            RMS=SQRT(RMS/N)
C        ENDIF
      ELSE IF (PROJECT) THEN
C
C  FOR CHARMM INTERNAL COORDINATE MINIMISATION WE PROJECT THE UPHILL DIRECTION
C  OUT OF THE CARTESIAN GRADIENT EVERY TIME. IF MYLBFGS IS RESET ON EACH CALL THEN
C  THE TOTAL STEP SHOULD BE A LINEAR COMBINATION OF GRADIENTS THAT ALL HAVE THIS
C  COMPONENT REMOVED. HOWEVER - IF WE DON'T RESET THEN ON PREVIOUS CALLS THE
C  UPHILL DIRECTION WILL BE DIFFERENT! SUGGESTS THAT WE SHOULD RESET IN BFGSTS.
C
         DO J2=1,NUP
            IF (FREEZE) THEN
               DO J1=1,NATOMS
                  IF (.NOT.FROZEN(J1)) CYCLE
                  ZWORK(3*(J1-1)+1,J2)=0.0D0
                  ZWORK(3*(J1-1)+2,J2)=0.0D0
                  ZWORK(3*(J1-1)+3,J2)=0.0D0
               ENDDO
            ENDIF
            DUMMY2=0.0D0
            DO J1=1,N
               DUMMY2=DUMMY2+ZWORK(J1,J2)**2
            ENDDO
!           PRINT '(A,G20.10)','  MYLBFGS> UPHILL VECTOR MOD SQUARED=',DUMMY2
            IF (ABS(DUMMY2-1.0D0).GT.1.0D-10) THEN
               DUMMY2=1.0D0/SQRT(DUMMY2)
               PRINT '(A,G20.10)',' MYLBFGS> RENORMALISING UPHILL VECTOR BY FACTOR OF ',DUMMY2
               DO J1=1,N
                  ZWORK(J1,J2)=ZWORK(J1,J2)*DUMMY2
               ENDDO
            ENDIF
            DUMMY1=0.0D0
            IF (UNRST) THEN ! FOR UNRST N < 3*NATOMS
               DO J1=1,N
                  DUMMY1=DUMMY1+ZWORK(J1,J2)*G(J1)
               ENDDO
               RMS=0.0D0
               DO J1=1,N
                  G(J1)=G(J1)-ZWORK(J1,J2)*DUMMY1
                  RMS=RMS+G(J1)**2
               ENDDO
               RMS=SQRT(RMS/N)
            ELSE
               DUMMY2=0.0D0
               DO J1=1,N
                  DUMMY1=DUMMY1+ZWORK(J1,J2)*G(J1)
               ENDDO
               RMS=0.0D0
               DO J1=1,N
                  G(J1)=G(J1)-ZWORK(J1,J2)*DUMMY1
                  RMS=RMS+G(J1)**2
               ENDDO
               RMS=SQRT(RMS/N)
            ENDIF
         ENDDO
C        CALL ORTHOGOPT(W,X,.FALSE.)
      ENDIF
C
C  IF INTMINT AND CHRMMT NEED TO TRANSFORM TO INTERNAL COORDINATES
C  SEE COPTIM.2.3 FOR SWITCHING TO INTERNALS FROM CARTESIANS USING LIMINCUT.
C
      IF (INTMINT) THEN
         OLDCART(1:3*NATOMS)=X(1:3*NATOMS) ! STORE CARTESIANS IN OLDCART FOR BOTH CHARMM AND UNRES
         IF (UNRST) THEN
C
C STORE INTERNALS (IN OLDQ) AND UPDATE X TO CONTAIN INTERNALS
C
!CALL GEOM_TO_VAR(N,OLDQ)
            X(1:N)=OLDQ(1:N)
         ELSE IF (CHRMMT) THEN 
            CALL GETKD(KD) ! GET WIDTH OF SPARSE BAND IN G MATRIX KD
            CALL GETNNZ(NNZ) ! GET NUMBER OF NON-ZERO ELEMENTS IN B-MATRIX
            NOCOOR=.FALSE. ! CALCULATE INTERNALS THEREFORE NOCOOR IS FALSE
            NODERV = .FALSE.
            GINT(1:N)=0.0D0 ! TO PREVENT NAN'S FOR SUN!
            XINT(1:N)=0.0D0 ! TO PREVENT NAN'S FOR SUN!
            CALL TRANSFORM(X,G,XINT,GINT,N,3*NATOMS,NNZ,NOCOOR,NODERV,KD,INTEPSILON)
            OLDQ(1:N)=XINT(1:N)    ! STORE INTERNALS
            OLDGINT(1:N)=GINT(1:N) ! STORE GRADIENT IN INTERNALS
         ELSE IF (AMBERT.OR.NABT) THEN
            PRINT*, "NOT YET SET UP FOR AMBER"
            STOP
         ENDIF
      ENDIF
C
C  FOR CHRMMT:
C  X       CONTAINS CURRENT CARTESIANS
C  G       CONTAINS CURRENT GRADIENT
C  XINT    CONTAINS CURRENT INTERNALS
C  GINT    CONTAINS CURRENT GRADIENT IN INTERNALS
C  OLDQ    CONTAINS INTERNALS FOR INITIAL GEOMETRY
C  OLDGINT CONTAINS GRADIENT IN INTERNALS FOR INITIAL GEOMETRY
C  OLDCART CONTAINS CARTESIAN COORDINATES FOR INITIAL GEOMETRY
C
      IF (GRADSQ) THEN
         IF (CHRMMT.AND.INTMINT) THEN
            PRINT*,'ERROR - GRADSQ MINIMISATION INCOMPATIBLE WITH INTERNAL COORDINATES'
            STOP
         ENDIF
         EREAL=ENERGY
         REALRMS=RMS
         ENERGY=DDOT(3*NATOMS,G,1,G,1)
C        ENERGY=SQRT(DDOT(3*NATOMS,G,1,G,1))
         CALL DSYMV('U',3*NATOMS,2.0D0,HESS,SIZE(HESS,1),G,1,0.0D0,VEC2,1)
         RMS=DSQRT(DDOT(3*NATOMS,VEC2,1,VEC2,1)/(3*NATOMS))
         IF (RMS.LT.GSTHRESH) THEN
            IF (NSPECIAL.GT.0) THEN
               IF (MOD(ITER+1,NSPECIAL).EQ.0) THEN
                  CALL G2SPECIAL(NATOMS,X,G,VEC2,ENERGY,RMS,EREAL,REALRMS,MFLAG)
               ENDIF
            ELSE IF (FIXAFTER.EQ.0) THEN
               FIXAFTER=ITER+1
               PRINT*,'MYLBFGS> CHANGING TO ATOM TYPE LC AND SETTING FIXAFTER=',ITER+1
               DO J1=1,NATOMS
                  ZSYM(J1)='LC'
               ENDDO
               GOTO 1
            ENDIF
         ENDIF
         DO J1=1,3*NATOMS
            G(J1)=VEC2(J1)
C           G(J1)=VEC2(J1)/ENERGY
         ENDDO
      ELSE
         EREAL=ENERGY
         REALRMS=RMS
      ENDIF

      IF (PTEST) WRITE(*,'(A,2G20.10,A,I6,A)') 
     1             ' MYLBFGS> ENERGY AND RMS FORCE=',ENERGY,RMS,' AFTER ',ITDONE,' STEPS'
      WRITE(ESTRING,16) ' MYLBFGS> ENERGY FOR LAST CYCLE=',ENERGY,' '
16    FORMAT(A,27X,F20.10,A)

10    CALL FLUSH(6,ISTAT)

      MFLAG=.FALSE.
      IF (RMS.LE.GMAX) THEN ! GMAX IS IN KEY MODULE, SO CAN BE CHANGED BY CHANGEP CALL
         IF (CHRMMT.AND.ACESOLV) THEN
            NCHENCALLS=ACEUPSTEP-1
            CALL POTENTIAL(X,ENERGY,GSAVE,.TRUE.,.FALSE.,RMS,.FALSE.,.FALSE.)
            IF(DEBUG) WRITE(*,'(A,2G20.10,A)')
     $           ' MYLBFGS> ENERGY AND RMS FORCE=',ENERGY,RMS,
     1           ' AFTER ACE UPDATE'
            IF (RMS.LE.GMAX) MFLAG=.TRUE.
!         ELSE IF (AMBERT.OR.NABT) THEN
!            BORN RADII UPDATE DISABLED FOR THE MOMENT, UNTIL WE FIGURE OUT WHAT THE HELL IS GOING WRONG
!            IRESPA2=NRESPA2
!            RMS=0.0D0
!            CALL POTENTIAL(X,ENERGY,GSAVE,.TRUE.,.FALSE.,RMS,.FALSE.,.FALSE.)
!            IF(DEBUG) WRITE(*,'(A,2G20.10,A)')
!     $           ' MYLBFGS> ENERGY AND RMS FORCE=',ENERGY,RMS,
!     1           ' AFTER BORN RADII UPDATE'
!            IF(RMS.LE.GMAX) MFLAG=.TRUE.
         ELSE
            MFLAG=.TRUE.
         ENDIF
         IF (ITDONE.LT.NSTEPMIN) MFLAG=.FALSE.
         IF (PV.AND.(.NOT.PVFLAG)) MFLAG=.FALSE.
         IF (MFLAG) THEN
            IF (GRADSQ.AND.PTEST) WRITE(*,'(A,4F20.10)')
     $           ' MYLBFGS> G^2, RMS FORCE AND REAL ENERGY AND RMS=',ENERGY,RMS,EREAL,REALRMS
            FIXIMAGE=.FALSE.
            IF (INTMINT) THEN
C
C JMC PUT CARTESIANS IN X FOR RETURN
C
               IF (UNRST) THEN
                  TMPINT(1:N)=X(1:N)
!CALL VAR_TO_GEOM(N,TMPINT) ! JMC UPDATE INTERNALS
!CALL CHAINBUILD ! GET CARTESIANS
                  DO I1=1,NRES
                     X(6*(I1-1)+1)=C(1,I1)
                     X(6*(I1-1)+2)=C(2,I1)
                     X(6*(I1-1)+3)=C(3,I1)
                     X(6*(I1-1)+4)=C(1,I1+NRES)
                     X(6*(I1-1)+5)=C(2,I1+NRES)
                     X(6*(I1-1)+6)=C(3,I1+NRES)
                  ENDDO
               ENDIF
            ENDIF
C           WRITE(*,'(A,F20.10)') ' MYLBFGS> DIAGONAL INVERSE HESSIAN ELEMENTS ARE NOW ',DIAG(1)
C           DGUESS=DIAG(1) ! SAVED FOR SUBSEQUENT CALLS - SHOULD BE OK FOR THE SAME SYSTEM?
C                          ! MAY MAKE REDOPATH RUNS UNREPRODUCIBLE?
            IF (PTEST) WRITE(*,'(A,G25.17)') ' MYLBFGS> FINAL ENERGY IS ',ENERGY
            RETURN
         ENDIF
      ENDIF

      IF (ITDONE.EQ.ITMAX) THEN
         FIXIMAGE=.FALSE.
         IF (INTMINT) THEN
            IF (UNRST) THEN
               TMPINT(1:N)=X(1:N) ! UPDATE INTERNALS
!CALL VAR_TO_GEOM(N,TMPINT)
!CALL CHAINBUILD ! GET CARTESIANS
               DO I1=1,NRES
                  X(6*(I1-1)+1)=C(1,I1)
                  X(6*(I1-1)+2)=C(2,I1)
                  X(6*(I1-1)+3)=C(3,I1)
                  X(6*(I1-1)+4)=C(1,I1+NRES)
                  X(6*(I1-1)+5)=C(2,I1+NRES)
                  X(6*(I1-1)+6)=C(3,I1+NRES)
               ENDDO
            ENDIF
         ENDIF
C        WRITE(*,'(A,F20.10)') ' MYLBFGS> DIAGONAL INVERSE HESSIAN ELEMENTS ARE NOW ',DIAG(1)
C        DGUESS=DIAG(1) ! SAVED FOR SUBSEQUENT CALLS - SHOULD BE OK FOR THE SAME SYSTEM?
C                          ! MAY MAKE REDOPATH RUNS UNREPRODUCIBLE?
         RETURN
      ENDIF

      IF (ITER.EQ.0) THEN
         IF (N.LE.0.OR.M.LE.0) THEN
            WRITE(*,240)
 240        FORMAT(' IMPROPER INPUT PARAMETERS (N OR M ARE NOT POSITIVE)')
            STOP
         ENDIF
         POINT=0
         MFLAG=.FALSE.
         IF (DIAGCO) THEN
            PRINT*,'USING ESTIMATE OF THE INVERSE DIAGONAL ELEMENTS'
            DO I=1,N
               IF (DIAG(I).LE.0.0D0) THEN
                  WRITE(*,235) I
 235              FORMAT(' THE',I5,'-TH DIAGONAL ELEMENT OF THE',/,
     1                   ' INVERSE HESSIAN APPROXIMATION IS NOT POSITIVE')
                  STOP
               ENDIF
            ENDDO
         ELSE
C           INQUIRE(FILE='DIAG',EXIST=YESNO)
C           IF (YESNO) THEN
C              OPEN(UNIT=34,FILE='DIAG',STATUS='OLD')
C              READ(34,*) (DIAG(I),I=1,N)
C              PRINT*,'DIAG READ IN LBFGS'
C              WRITE(*,'(6F15.5)') (DIAG(I),I=1,N)
C           ELSE
            DO I=1,N
               DIAG(I)=DGUESS
            ENDDO
         ENDIF
C
C     THE WORK VECTOR W IS DIVIDED AS FOLLOWS:
C     ---------------------------------------
C     THE FIRST N LOCATIONS ARE USED TO STORE THE GRADIENT AND
C         OTHER TEMPORARY INFORMATION.
C     LOCATIONS (N+1)...(N+M) STORE THE SCALARS RHO.
C     LOCATIONS (N+M+1)...(N+2M) STORE THE NUMBERS ALPHA USED
C         IN THE FORMULA THAT COMPUTES H*G.
C     LOCATIONS (N+2M+1)...(N+2M+NM) STORE THE LAST M SEARCH
C         STEPS.
C     LOCATIONS (N+2M+NM+1)...(N+2M+2NM) STORE THE LAST M
C         GRADIENT DIFFERENCES.
C
C     THE SEARCH STEPS AND GRADIENT DIFFERENCES ARE STORED IN A
C     CIRCULAR ORDER CONTROLLED BY THE PARAMETER POINT.
C
         ISPT= N+2*M
         IYPT= ISPT+N*M
C
C  NR STEP FOR DIAGONAL INVERSE HESSIAN
C
         IF (CHRMMT.AND.INTMINT) THEN
            DO I=1,N
               W(ISPT+I)= -GINT(I)*DIAG(I)
               W(I)= -GINT(I)*DIAG(I)
            ENDDO
            GNORM= DSQRT(DDOT(N,GINT,1,GINT,1))
         ELSE
            DO I=1,N
               W(ISPT+I)= -G(I)*DIAG(I)
               W(I)= -G(I)*DIAG(I)
            ENDDO
            GNORM= DSQRT(DDOT(N,G,1,G,1))
         ENDIF
C
C  MAKE THE FIRST GUESS FOR THE STEP LENGTH CAUTIOUS.
C
         IF (GNORM.EQ.0.0D0) THEN
            GNORM=1.0D0 ! EXACT ZERO IS PRESUMABLY WRONG!
            PRINT '(A)','WARNING - GNORM WAS ZERO IN MYLBFGS, RESETTING TO ONE'
         ENDIF
         STP=MIN(1.0D0/GNORM,GNORM)
C        STP=1.0D0
      ELSE 
         BOUND=ITER
         IF (ITER.GT.M) BOUND=M
C        PRINT*,'BEFORE OVERLAP W, W: ITER,M,ISPT,IYPT,NPT=',ITER,M,ISPT,IYPT,NPT
C        WRITE(*,'(I5,2E20.10)') (J1,W(ISPT+NPT+J1),W(IYPT+NPT+J1),J1=1,10)
         YS= DDOT(N,W(IYPT+NPT+1),1,W(ISPT+NPT+1),1)
C        WRITE(*,'(A,E20.10)') 'YS=',YS
         IF (YS.EQ.0.0D0) YS=1.0D0
C
C  UPDATE ESTIMATE OF DIAGONAL INVERSE HESSIAN ELEMENTS
C  WE DIVIDE BY BOTH YS AND YY AT DIFFERENT POINTS, SO
C  THEY HAD BETTER NOT BE ZERO!
C  W(ISPT+NPT+1:ISPT+NPT+N) STORES THE PREVIOUS STEP VECTOR
C  W(IYPT+NPT+1:IYPT+NPT+N) STORES THE PREVIOUS DIFFERENCE OF GRADIENT VECTORS
C
         IF (.NOT.DIAGCO) THEN
C
C  SCALING INDIVIDUAL COMPONENTS
C
            IF (.FALSE.) THEN
               YY= DDOT(N,W(IYPT+NPT+1),1,W(IYPT+NPT+1),1)
               IF (YY.EQ.0.0D0) YY=1.0D0
               GAMMA=YS/YY
               DO I=1,N
                  DUMMY1=0.0D0
                  DUMMY2=0.0D0
                  DO J1=1,M
                     DUMMY1=DUMMY1+W(ISPT+N*(J1-1)+I)*W(IYPT+N*(J1-1)+I)
                     DUMMY2=DUMMY2+W(IYPT+N*(J1-1)+I)**2
                  ENDDO
                  IF (DUMMY2.LT.1.0D-5) THEN
                     DIAG(I)=GAMMA
                  ELSE 
                     DIAG(I)=DUMMY1/DUMMY2
                  ENDIF
               ENDDO
            ELSE
               YY= DDOT(N,W(IYPT+NPT+1),1,W(IYPT+NPT+1),1)
C              WRITE(*,'(A,E20.10)') 'YY=',YY
               IF (YY.EQ.0.0D0) YY=1.0D0
               DUMMY1=YS/YY
C              DUMMY1=ABS(YS/YY) ! IF THE PREVIOUS STEP WAS REVERSED THIS ABS SEEMS A BAD IDEA!  DJW
                              ! AN ALTERNATIVE WOULD BE TO REVERSE THE GRADIENT DIFFERENCE AS WELL.
                              ! HOWEVER, YS IS THE DOT PRODUCT OF THE GRADIENT CHANGE WITH THE STEP
                              ! SO IF WE DON'T TAKE THE ABS VALUE THE SIGNS SHOULD PROBABLY BE RIGHT.
C              WRITE(*,'(A,E20.10)') 'DUMMY1=',DUMMY1
               DO I=1,N
                  DIAG(I)=DUMMY1
               ENDDO
            ENDIF
         ELSE
            PRINT*,'USING ESTIMATE OF THE INVERSE DIAGONAL ELEMENTS'
            DO I=1,N
               IF (DIAG(I).LE.0.0D0) THEN
                  WRITE(*,235) I
                  STOP
               ENDIF
            ENDDO
         ENDIF
C
C     COMPUTE -H*G USING THE FORMULA GIVEN IN: NOCEDAL, J. 1980,
C     "UPDATING QUASI-NEWTON MATRICES WITH LIMITED STORAGE",
C     MATHEMATICS OF COMPUTATION, VOL.24, NO.151, PP. 773-782.
C     ---------------------------------------------------------
C
         CP= POINT
         IF (POINT.EQ.0) CP=M
         W(N+CP)= 1.0D0/YS
C        PRINT*,'W(I) GETS SET TO -G(I):'
C        WRITE(*,'(I5,2E20.10)') (J1,W(J1),G(J1),J1=1,10)
         IF (CHRMMT.AND.INTMINT) THEN
            DO I=1,N
               W(I)= -GINT(I)
            ENDDO
         ELSE
            DO I=1,N
               W(I)= -G(I)
            ENDDO
         ENDIF
         CP= POINT
         DO I= 1,BOUND
            CP=CP-1
            IF (CP.EQ. -1)CP=M-1
            SQ= DDOT(N,W(ISPT+CP*N+1),1,W,1)
            INMC=N+M+CP+1
            IYCN=IYPT+CP*N
            W(INMC)= W(N+CP+1)*SQ
            CALL DAXPY(N,-W(INMC),W(IYCN+1),1,W,1)
         ENDDO
        
         DO I=1,N
            W(I)=DIAG(I)*W(I)
         ENDDO

         DO I=1,BOUND
            YR= DDOT(N,W(IYPT+CP*N+1),1,W,1)
            BETA= W(N+CP+1)*YR
            INMC=N+M+CP+1
            BETA= W(INMC)-BETA
            ISCN=ISPT+CP*N
            CALL DAXPY(N,BETA,W(ISCN+1),1,W,1)
            CP=CP+1
            IF (CP.EQ.M) CP=0
         ENDDO
         STP=1.0D0
      ENDIF
C
C  IF THIS IS A BFGSTST OR MORPHT  RUN PROJECT OUT THE UPHILL DIRECTION.
C  FOR CHARMM INTERNALS WE PROJECT THE CARTESIAN STEP BELOW.
C
!     PRINT '(A,6G20.10)','DIAG=',DIAG(1:3)
!     PRINT '(A,6G20.10)','COORDS=',X(1:3)
!     PRINT '(A,6G20.10)','G=',G(1:3)
!     PRINT '(A,6G20.10)','W=',W(1:3)
!     PRINT '(A,6G20.10)','ZWORK=',ZWORK(1:3,1)
      IF ((PROJECT).AND.(.NOT.TWOENDS).AND.(.NOT.(CHRMMT.AND.INTMINT))) THEN
         DO J2=1,NUP

            IF (FREEZE) THEN ! THIS MAY DUPLICATE THE BLOCK IN THE PROJECTION OF THE GRADIENT
               DO J1=1,NATOMS
                  IF (.NOT.FROZEN(J1)) CYCLE
                  ZWORK(3*(J1-1)+1,J2)=0.0D0
                  ZWORK(3*(J1-1)+2,J2)=0.0D0
                  ZWORK(3*(J1-1)+3,J2)=0.0D0
               ENDDO
            ENDIF

            DUMMY1=0.0D0
            DO J1=1,N
               DUMMY1=DUMMY1+ZWORK(J1,J2)*W(J1)
            ENDDO
            DO J1=1,N
               W(J1)=W(J1)-ZWORK(J1,J2)*DUMMY1
            ENDDO
         ENDDO
      ENDIF
C
C  STORE THE NEW SEARCH DIRECTION
C
C     PRINT*,'W(I):'
C     WRITE(*,'(I5,E20.10)') (J1,W(J1),J1=1,10)
      IF (ITER.GT.0) THEN
         DO I=1,N
            W(ISPT+POINT*N+I)= W(I)
         ENDDO
      ENDIF

!     PRINT*,'BEFORE OVERLAP TEST ITER, DIAG(1)=',ITER, DIAG(1)
!     PRINT*,'BEFORE OVERLAP TEST  X, G, W:'
!     WRITE(*,'(I5,3E20.10)') (J1,X(J1),G(J1),W(ISPT+POINT*N+J1),J1=1,N)

      IF (CHRMMT.AND.INTMINT) THEN
         DOT1=SQRT(DDOT(N,GINT,1,GINT,1))
      ELSE
         DOT1=SQRT(DDOT(N,G,1,G,1))
      ENDIF
      DOT2=SQRT(DDOT(N,W,1,W,1))
      OVERLAP=0.0D0
      IF (DOT1*DOT2.NE.0.0D0) THEN
         IF (CHRMMT.AND.INTMINT) THEN
            OVERLAP=DDOT(N,GINT,1,W,1)/(DOT1*DOT2)
         ELSE
            OVERLAP=DDOT(N,G,1,W,1)/(DOT1*DOT2)
        ENDIF
      ENDIF
C     PRINT*,'OVERLAP,DIAG(1)=',OVERLAP,DIAG(1)
C     PRINT*,'G . G=',DDOT(N,G,1,G,1)
C     PRINT*,'W . W=',DDOT(N,W,1,W,1)
C
C  THE STEP IS SAVED IN W(ISPT+POINT*N+1:ISPT+POINT*N+N). 
C  W(1:N) IS OVERWRITTEN BY THE GRADIENT.
C
      IF (OVERLAP.GT.0.0D0) THEN
         IF (PTEST) PRINT '(A,G20.10,A)','SEARCH DIRECTION HAS POSITIVE PROJECTION ONTO GRADIENT ',OVERLAP,' REVERSING STEP'
         DO I=1,N
            W(ISPT+POINT*N+I)= -W(I)  ! IF WE REVERSE THE STEP IT IS IMPORTANT NOT TO TAKE THE ABS VALUE OF YS/YY!
         ENDDO
C        ITER=0
C        GOTO 10
      ENDIF
C
C  IS IT BETTER TO REVERSE INDIVIDUAL COMPONENTS? NO!
C
!     NREV=0
!     DO I=1,N
!        IF (W(I)*G(I).GT.0.0D0) THEN
!           W(ISPT+POINT*N+I)= -W(I)
!           NREV=NREV+1
!        ENDIF
!     ENDDO
!     IF (PTEST.AND.(NREV.GT.0)) PRINT '(A,I6,A)',' MYLBFGS> ',NREV,' SEARCH DIRECTION COMPONENTS WERE REVERSED'

      IF (CHRMMT.AND.INTMINT) THEN
         DO I=1,N
            W(I)=GINT(I)
         ENDDO
      ELSE
         DO I=1,N
            W(I)=G(I)
         ENDDO
      ENDIF
      SLENGTH=0.0D0
      DO J1=1,N
         SLENGTH=SLENGTH+W(ISPT+POINT*N+J1)**2
      ENDDO
      SLENGTH=SQRT(SLENGTH)
      IF (STP*SLENGTH.GT.MAXBFGS) STP=MAXBFGS/SLENGTH
      NCOUNT = 0
 19   CONTINUE

      IF (CHRMMT.AND.INTMINT) THEN
         GNORM= DSQRT(DDOT(N,GINT,1,GINT,1))
         DO J1=1,N
            XINT(J1)=XINT(J1)+STP*W(ISPT+POINT*N+J1)
            DELTAQ(J1)=STP*W(ISPT+POINT*N+J1)
         ENDDO 
      ELSE
         GNORM= DSQRT(DDOT(N,G,1,G,1))
!
! SAVE X HERE SO THAT WE CAN UNDO THE STEP RELIABLY.
!
         XSAVE(1:N)=X(1:N)
         DO J1=1,N
            X(J1)=X(J1)+STP*W(ISPT+POINT*N+J1)
         ENDDO 
      ENDIF
!     PRINT '(A,L5)',' MYLBFGS> X,GRAD,PROPOSED STEP: PROJECT=',PROJECT
!     DO J1=1,N
!        PRINT '(3F20.10)', X(J1),G(J1),STP*W(ISPT+POINT*N+J1)
!     ENDDO
C
C  TO PLAY WITH STEP SIZES FOR DIFFERENT SORTS OF INTERNAL COORDINATES
C  SEE COPTIM.2.3. WOULD USE MAKESTPVEC.
C
      KNOWE=.FALSE.
      KNOWG=.FALSE.
      KNOWH=.FALSE.
C
C AT THIS POINT WE HAVE NEW CARTESIAN OR INTERNAL COORDINATES AFTER TAKING A FULL
C OR DECREASED STEP. THE GRADIENT IS NOT KNOWN AT THIS GEOMETRY.
C IF INTMIN MUST TRANSFORM TO CARTESIANS HERE.
C

      NDECREASE=0

20    IF (INTMINT) THEN
         IF (CHRMMT) THEN

            NEWQ(1:N)=OLDQ(1:N)
            CART(1:3*NATOMS)=OLDCART(1:3*NATOMS)
C
C NEED TO KEEP OLDQ CONSTANT FOR REPEATED BACK-TRANSFORMATIONS IF FIRST STEP SIZE FAILS.
C THEREFORE PASS DUMMY ARRAY NEWQ THAT CAN CHANGE.
C SIMILARLY WITH CART AND OLDCART.
C
            CALL TRANSBACKDELTA(DELTAQ,DELTACART,CART,N,3*NATOMS,NNZ,KD,FAILED,.FALSE.,INTEPSILON) ! TRANSFORM STEP TO CARTESIANS
            IF (FAILED) THEN
              NCOUNT=NCOUNT+1
              IF (NCOUNT.GT.10) THEN
                 PRINT*, 'FAILED TO SUCCESSFULLY TRANSFORM
     $                FROM INTERNAL TO CARTESIAN STEP'
                 STOP
              ENDIF

              DO J1=1,N
                 XINT(J1)=XINT(J1)-STP*W(ISPT+POINT*N+J1)
              ENDDO
              STP = STP*0.1
              PRINT*, ' MYLBFGS>> BACKTRANSFORM FAILED; DECREASING STEP', STP
              GOTO 19

            ENDIF
C
C IF THIS IS A BFGSTST OR MORPHT RUN PROJECT OUT THE UPHILL DIRECTION IN CARTESIANS.
C X IS UPDATED FROM THE OLDCARTS VALUE WITH THE PROJECTED STEP. HOWEVER,
C XINT CONTAINS THE INTERNAL COORDINATES WITHOUT PROJECTION.
C
            IF ((PROJECT).AND.(.NOT.TWOENDS)) THEN
               DO J2=1,NUP
                  DUMMY1=0.0D0
                  DO J1=1,NOPT
                     DUMMY1=DUMMY1+ZWORK(J1,J2)*DELTACART(J1)
                  ENDDO
                  DO J1=1,NOPT
                     DELTACART(J1)=DELTACART(J1)-ZWORK(J1,J2)*DUMMY1
                  ENDDO
               ENDDO
            ENDIF
C
C NOW ADD DELTACART TO CART TO GET NEW CARTESIANS. PUT THESE IN X.
C
            CART(1:3*NATOMS)=OLDCART(1:3*NATOMS)+DELTACART(1:3*NATOMS)
            X(1:3*NATOMS)=OLDCART(1:3*NATOMS)+DELTACART(1:3*NATOMS)
C
C  FOR CHRMMT:
C  CART    CONTAINS NEW CARTESIANS (AFTER STEP) 
C  X       CONTAINS NEW CARTESIANS (AFTER STEP)
C  XINT    CONTAINS NEW INTERNALS (AFTER STEP)
C  G       CONTAINS OLD GRADIENT
C  GINT    CONTAINS OLD GRADIENT IN INTERNALS
C  OLDQ    CONTAINS OLD INTERNALS
C  OLDGINT CONTAINS OLD GRADIENT IN INTERNALS FOR THE LAST SUCCESSFUL GEOMETRY
C  NEWQ    CONTAINS OLD INTERNALS FOR THE LAST SUCCESSFUL GEOMETRY
C  OLDCART CONTAINS OLD CARTESIANS FOR THE LAST SUCCESSFUL GEOMETRY
C
         ELSEIF (UNRST) THEN
            NEWQ(1:N)=X(1:N) ! STORE NEW INTERNALS IN NEWQ
C
C NEED A TEMPORARY ARRAY NEWQ HERE AS ARGUMENT TO VAR_TO_GEOM TO KEEP X UNCHANGED IN CASE WE NEED TO
C MODIFY THE STEP BELOW.
C
!CALL VAR_TO_GEOM(N,NEWQ) ! UPDATE INTERNALS
!CALL CHAINBUILD ! GET CARTESIANS
         ENDIF
      ENDIF

      IF (PV) THEN
         CALL POTENTIAL(X,ENEW,GSAVE,.FALSE.,.FALSE.,RMS,.FALSE.,.FALSE.)
         PVFLAG=.FALSE.
         CALL PVOPT(X,ENEW,GSAVE)
      ENDIF
      IF(AMBERT.OR.NABT) IRESPA2=ITDONE+1
      CALL POTENTIAL(X,ENEW,GSAVE,.TRUE.,GRADSQ,RMS,.FALSE.,.FALSE.)

      IF (ENEW.LT.COLDFUSIONLIMIT) THEN
         WRITE(*,'(A,2G20.10)') ' MYLBFGS> COLD FUSION DIAGNOSED - STEP DISCARDED, ENERGY, LIMIT=',ENEW,COLDFUSIONLIMIT
         ENERGY=1.0D60
         EREAL=1.0D60
         RMS=1.0D1
         CFUSIONT=.TRUE.
         RETURN
      ENDIF

C     WRITE(*,'(A3,6F20.10)') ('LA ',X(3*(J1-1)+1),X(3*(J1-1)+2),X(3*(J1-1)+3),
C    1                     GSAVE(3*(J1-1)+1),GSAVE(3*(J1-1)+2),GSAVE(3*(J1-1)+3),J1=1,N/3)
C!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
C     FIXSAVE=FIXIMAGE
C     FIXIMAGE=.TRUE.
C     SHIT=1.0D-6
C     DO J1=1,3*NATOMS
C        VEC2(J1)=0.0D0
C     ENDDO
C     CALL DSYMV('U',3*NATOMS,1.0D0,HESS,3*NATOMS,GSAVE,1,0.0D0,VEC2,1)
C     DO J1=1,3*NATOMS
C        VEC2(J1)=2*VEC2(J1)
C     ENDDO
C     DO J1=150,160
C        DUMMY1=X(J1)
C        X(J1)=X(J1)+SHIT
C        CALL POTENTIAL(X,EPLUS,GDUM,.TRUE.,.FALSE.,RMSDUM,.FALSE.,.FALSE.)
C        EPLUS=DDOT(3*NATOMS,GDUM,1,GDUM,1)
C        X(J1)=X(J1)-2.0D0*SHIT
C        CALL POTENTIAL(X,EMINUS,GDUM,.TRUE.,.FALSE.,RMSDUM,.FALSE.,.FALSE.)
C        EMINUS=DDOT(3*NATOMS,GDUM,1,GDUM,1)
C        X(J1)=DUMMY1
C        IF (100.0D0*ABS((VEC2(J1)-(EPLUS-EMINUS)/(2.0D0*SHIT))/VEC2(J1)).GT.1.0D0) 
C    1     WRITE(*,'(A,I5,5G20.10)') 'J1,ANAL,NUM,%,+,-=',J1,VEC2(J1),(EPLUS-EMINUS)/(2.0D0*SHIT),
C    2                  100.0D0*ABS((VEC2(J1)-(EPLUS-EMINUS)/(2.0D0*SHIT))/VEC2(J1)),EPLUS,EMINUS
C     ENDDO
C     FIXIMAGE=FIXSAVE
C!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      G(1:N)=GSAVE(1:N)

      IF (TWOENDS.AND.(.NOT.TTDONE)) THEN
         IF (CHRMMT.AND.INTMINT) THEN
            PRINT*,'ERROR - CANT USE TWOENDS WITH INTERNALS'
            STOP
         ENDIF
         IF (FORCE.NE.0.0D0) THEN
            DUMMY1=0.0D0
            DO J1=1,N
               RVEC(J1)=FIN(J1)-X(J1)
               DUMMY1=DUMMY1+RVEC(J1)**2
            ENDDO
            DUMMY1=1.0D0/SQRT(DUMMY1)
            IF (1.0D0/DUMMY1.GT.0.05D0) THEN
               RMS=0.0D0
                  DO J1=1,N
                  G(J1)=G(J1)+FORCE*RVEC(J1)*DUMMY1
                  RMS=RMS+G(J1)**2
               ENDDO
               RMS=SQRT(RMS/N)
            ENDIF
         ENDIF
      ELSE IF (DRAGT) THEN
         IF (CHRMMT.AND.INTMINT) THEN
            PRINT*,'ERROR - CANT USE DRAGT WITH INTERNALS'
            STOP
         ENDIF
         DUMMY1=0.0D0
         DO J1=1,N
            RVEC(J1)=FIN(J1)-X(J1)
            DUMMY1=DUMMY1+RVEC(J1)**2
         ENDDO
         DUMMY1=1.0D0/SQRT(DUMMY1)
         WRITE(*,'(A,F20.10)') 'DIST=',1.0D0/DUMMY1
         IF (1.0D0/DUMMY1.GT.0.3D0) THEN
            DO J1=1,N
               RVEC(J1)=RVEC(J1)*DUMMY1
            ENDDO
            DUMMY1=0.0D0
            DO J1=1,N
               DUMMY1=DUMMY1+RVEC(J1)*G(J1)
            ENDDO
            PRINT*,'PROJECTION OF GRADIENT=',DUMMY1
            RMS=0.0D0
            DO J1=1,N
               G(J1)=G(J1)-DUMMY1*RVEC(J1)-ALPHA*RVEC(J1)
               RMS=RMS+G(J1)**2
            ENDDO
            RMS=SQRT(RMS/N)
         ENDIF
      ELSE IF (PROJECT) THEN
         DO J2=1,NUP
            DUMMY1=0.0D0
            IF (UNRST) THEN
               DO J1=1,N
                  DUMMY1=DUMMY1+ZWORK(J1,J2)*G(J1)
               ENDDO
               RMS=0.0D0
               DO J1=1,N
                  G(J1)=G(J1)-ZWORK(J1,J2)*DUMMY1
                  RMS=RMS+G(J1)**2
               ENDDO
               RMS=SQRT(RMS/N)
            ELSE
               DO J1=1,N
                  DUMMY1=DUMMY1+ZWORK(J1,J2)*G(J1)
               ENDDO
               RMS=0.0D0
               DO J1=1,N
                  G(J1)=G(J1)-ZWORK(J1,J2)*DUMMY1
                  RMS=RMS+G(J1)**2
               ENDDO
               RMS=SQRT(RMS/N)
            ENDIF
         ENDDO
      ENDIF
C
C  WE NEED TO TRANSFORM THE NEWLY OBTAINED CARTESIAN GRADIENT FOR CHARMM AND INTERNALS. 
C  NOCOOR IS TRUE BECAUSE WE DONT NEED TO TRANSFORM THE COORDINATES.
C
      IF (CHRMMT.AND.INTMINT) THEN
         NOCOOR=.TRUE.; NODERV = .FALSE.
         CALL TRANSFORM(X,G,XINT,GINT,N,3*NATOMS,NNZ,NOCOOR,NODERV,KD,INTEPSILON)
      ENDIF

      IF (GRADSQ) THEN
         EREAL=ENEW
         REALRMS=RMS
         ENEW=DDOT(3*NATOMS,G,1,G,1)
C        ENEW=SQRT(DDOT(3*NATOMS,G,1,G,1))
         CALL DSYMV('U',3*NATOMS,1.0D0,HESS,SIZE(HESS,1),G,1,0.0D0,VEC2,1)
         DO J1=1,3*NATOMS
            G(J1)=2*VEC2(J1)
C           G(J1)=VEC2(J1)/ENERGY
         ENDDO
         RMS=DSQRT(DDOT(3*NATOMS,G,1,G,1)/(3*NATOMS))
C
C  NINFO WAS DESIGNED TO FIND GRADSQ DISCONTINUITIES. NOT SET AT PRESENT - WE CAN
C  DEAL WITH THIS USING THE "TOO MANY FAILURES" ROUTE BELOW.
C
         IF (NINFO.GT.100) THEN
            OPEN(UNIT=96,FILE='DISCONN',STATUS='UNKNOWN')
            PRINT*,' MYLBFGS> INTRACTABLE DISCONTINUITY - QUIT '
            WRITE(96,'(A)') ' MYLBFGS> INTRACTABLE DISCONTINUITY'
            CLOSE(96)
            WRITE(*,'(A,4F20.10)')
     $           ' MYLBFGS>  G^2, RMS FORCE AND REAL ENERGY AND RMS=',ENERGY,RMS,EREAL,REALRMS
            CALL DUMPIT(X,'POINTS.FINAL')
            STOP
         ENDIF
      ELSE
         EREAL=ENEW
         REALRMS=RMS
      ENDIF

      IF ((ENEW-ENERGY.LE.MAXERISE).AND.DRAGT.AND.(ITDONE.GT.NSTEPMIN)) THEN
         WRITE(*,'(A,F20.10,A,F20.10,A)')
     $        ' MYLBFGS> ENERGY FALLS FROM ',ENERGY,' TO ',ENEW,
     $        ' TRY TS SEARCH FROM PREVIOUS GEOMETRY'
         DO J1=1,N
            X(J1)=X(J1)-0.9*STP*W(ISPT+POINT*N+J1)
         ENDDO 
         KNOWE=.FALSE.
         KNOWG=.FALSE.
         KNOWH=.FALSE.
C        DGUESS=DIAG(1) ! SAVED FOR SUBSEQUENT CALLS - SHOULD BE OK FOR THE SAME SYSTEM?
C                          ! MAY MAKE REDOPATH RUNS UNREPRODUCIBLE?
         RETURN
      ENDIF
C
C  MUST ALLOW THE ENERGY TO RISE DURING A MINIMISATION TO ALLOW FOR NUMERICAL NOISE OR
C  SYSTEMATIC ERRORS DUE TO DISCONTINUITIES OR SCF CONVERGENCE PROBLEMS.
C
      IF ((ENEW-ENERGY.LE.MAXERISE).OR.PVTS.OR.DRAGT.OR.TWOENDS.OR.RADMOVED) THEN
         ITER=ITER+1
         ITDONE=ITDONE+1
         ENERGY=ENEW
         IF (PTEST) WRITE(*,'(A,2G20.10,A,I6,A,G13.5)')
     $        ' MYLBFGS> ENERGY AND RMS FORCE=',ENERGY,RMS,' AFTER ',ITDONE,
     1           ' STEPS, STEP:',STP*SLENGTH
         WRITE(ESTRING,16) ' MYLBFGS> ENERGY FOR LAST CYCLE=',ENERGY,' '
C
C  STEP FINISHED SO CAN RESET OLDQ TO NEW XINT, OLDCART TO NEW CART,
C  AS WELL AS THE CARTESIAN AND INTERNAL GRADIENTS.
C
         IF (CHRMMT.AND.INTMINT) THEN
            OLDGINT(1:N)=GINT(1:N)
            OLDCART(1:3*NATOMS)=CART(1:3*NATOMS)
C
C  NEED TO REMAKE XINT BECAUSE STEP WAS ONLY PROJECTED IN CARTESIANS?
C  ACTUALLY, JUST SETTING OLDQ=XINT WITHOUT THIS CORRECTION SEEMS TO
C  BE OK. DUE TO NUMERICAL IMPRECISION, IT MIGHT STILL BE POSSIBLE
C  FOR X AND XINT TO GET OUT OF REGISTER. PERHAPS THIS DOESN'T MATTER
C  BECAUSE THE ENERGY AND GRADIENT ARE ALWAYS CALCULATED IN CARTESIANS.
C
C           IF (PROJECT) CALL TRANSDELTA(DELTACART,DELTAQ,CART,N,3*NATOMS,NNZ,KD,INTEPSILON)
C           OLDQ(1:N)=OLDQ(1:N)+DELTAQ(1:N)
            OLDQ(1:N)=XINT(1:N)
         ELSEIF (UNRST) THEN
!           TEST1(1:N)=X(1:N)
!CALL GEOM_TO_VAR(N,X(1:N)) ! TESTING!!! - TO PUT X BACK INTO REGISTER WITH THE COMMON BLOCK INTERNALS (AND G)
!           CALL GEOM_TO_VAR(N,TEST1(1:N))
!           DO J1=1,N
!           IF (ABS((TEST1(J1)-X(J1))/X(J1))*100.0D0.GT.1.0D-6) PRINT *,'HELLO COORDS ',J1
!           ENDDO
         ENDIF
         GLAST(1:N)=GSAVE(1:N) 
         IF (.NOT.(NODUMP)) THEN ! JMC DUMPP DUMPS X BUT X IS IN INTERNALS...
            IF (INTMINT) THEN
               IF (UNRST) THEN
!                 TMPINT(1:N)=X(1:N) ! THE CARTESIANS SHOULD NOT HAVE CHANGED FROM WHEN THEY WERE SET BEFORE THE 
                                     ! CALL TO POTENTIAL ABOVE, SO COMMENTED OUT THESE THREE LINES
!                 CALL VAR_TO_GEOM(N,TMPINT)
!                 CALL CHAINBUILD
                  DO I1=1,NRES
                     CART(6*(I1-1)+1)=C(1,I1)
                     CART(6*(I1-1)+2)=C(2,I1)
                     CART(6*(I1-1)+3)=C(3,I1)
                     CART(6*(I1-1)+4)=C(1,I1+NRES)
                     CART(6*(I1-1)+5)=C(2,I1+NRES)
                     CART(6*(I1-1)+6)=C(3,I1+NRES)
                  ENDDO
                  CALL DUMPP(CART,ENERGY)
               ELSEIF (CHRMMT) THEN
                  CALL DUMPP(X,ENERGY)
               ENDIF
            ELSE
               CALL DUMPP(X,ENERGY)
            ENDIF
         ENDIF
      ELSE 
C
C  ENERGY INCREASED - TRY AGAIN WITH A SMALLER STEP SIZE. MUST CATER FOR POSSIBLE ENORMOUS
C  VALUES OF SLENGTH. DECREASING THE STEP SIZE DOESN;T SEEM TO HELP FOR CASTEP.
C
         IF (((ITER.GT.1).AND.(NDECREASE.GT.10)).OR.((ITER.LE.1).AND.(NDECREASE.GT.10)).OR.
     1              ((CASTEP.OR.ONETEP.OR.CP2K).AND.(NDECREASE.GT.10))) THEN 
            NFAIL=NFAIL+1
            IF (PTEST) WRITE(*,'(2(A,I6))') ' MYLBFGS> IN MYLBFGS STEP ',ITER,
     $           ' CANNOT FIND A LOWER ENERGY, NFAIL=',NFAIL
C
C  TRY RESETTING - GO BACK TO PREVIOUS COORDINATES, ENERGY IS NOT SET TO ENEW
C  WE NEED TO SAVE THE GRADIENT CORRESPONDING TO THE LAST SUCCESSFUL STEP
C              
            ITER=0
            IF (CHRMMT.AND.INTMINT) THEN ! NEED TO RESET X, XINT, G, GINT TO ORIGINAL VALUES 
               XINT(1:N)=XINT(1:N)-STP*W(ISPT+POINT*N+1:ISPT+POINT*N+N)
C              XINT=OLDQ ! SHOULD BE THE SAME AS SUBTRACTING THE STEP
               GINT(1:N)=OLDGINT(1:N)
               G(1:3*NATOMS)=GLAST(1:3*NATOMS)
               X(1:3*NATOMS)=OLDCART(1:3*NATOMS)
            ELSE
!
! RESETTING TO XSAVE SHOULD BE THE SAME AS SUBTRACTING THE STEP.
!
               X(1:N)=XSAVE(1:N)
               DO J1=1,N
C                 X(J1)=X(J1)-STP*W(ISPT+POINT*N+J1)
                  G(J1)=GLAST(J1)
C                 G(J1)=GSAVE(J1) ! DJW 6/5/04
               ENDDO
            ENDIF
            IF (NFAIL.GT.NFAILMAX) THEN
               WRITE(*,'(A)') ' MYLBFGS> TOO MANY FAILURES - GIVE UP'
               CALL DUMPCOORDS(X, 'LBFGSFAILED.XYZ', .FALSE.)
               FIXIMAGE=.FALSE.
C              DGUESS=DIAG(1) ! SAVED FOR SUBSEQUENT CALLS - SHOULD BE OK FOR THE SAME SYSTEM?
C                          ! MAY MAKE REDOPATH RUNS UNREPRODUCIBLE?
               RETURN
            ENDIF
            GOTO 30
         ENDIF
C
C  TRY A SMALLER STEP.
C
         IF (CHRMMT.AND.INTMINT) THEN
            DO J1=1,N
               XINT(J1)=XINT(J1)-0.9*STP*W(ISPT+POINT*N+J1)
               DELTAQ(J1)=STP*W(ISPT+POINT*N+J1)*0.1D0
            ENDDO 
         ELSE
!
! RESETTING TO XSAVE AND ADDING 0.1 OF THE STEP SHOULD BE THE SAME AS SUBTRACTING
! 0.9 OF THE STEP.
!
!        PRINT*,'X SHOULD MATCH XSAVE:'
!        WRITE(*,'(I5,2E20.10)') (J1,X(J1)-STP*W(ISPT+POINT*N+J1),XSAVE(J1),J1=1,N)
            DO J1=1,N
               X(J1)=X(J1)-0.9D0*STP*W(ISPT+POINT*N+J1)
            ENDDO 
         ENDIF
         KNOWE=.FALSE.
         KNOWG=.FALSE.
         KNOWH=.FALSE.
         STP=STP/10.0D0
         NDECREASE=NDECREASE+1
         IF (PTEST) 
     1    WRITE(*,'(A,G25.15,A,G25.15,A,G15.8)') ' ENERGY INCREASE:',ENERGY,' TO ',ENEW,
     2            ' DECREASING STEP TO ',STP*SLENGTH
!        PRINT*,'X:'
!        WRITE(*,'(I5,2E20.10)') (J1,X(J1),XSAVE(J1)+STP*W(ISPT+POINT*N+J1),J1=1,N)
C        FIXIMAGE=.TRUE. ! BLJ SEEMS TO WORK BETTER WITHOUT THIS
         GOTO 20
      ENDIF
C
C     COMPUTE THE NEW STEP AND GRADIENT CHANGE. NOTE THAT THE STEP
C     LENGTH IS ACCOUNTED FOR WHEN THE STEP TAKEN IS SAVED.
C
30    NPT=POINT*N

      IF (CHRMMT.AND.INTMINT) THEN
         DO I=1,N
            W(ISPT+NPT+I)= STP*W(ISPT+NPT+I)
            W(IYPT+NPT+I)= GINT(I)-W(I)
         ENDDO
      ELSE
         DO I=1,N
            W(ISPT+NPT+I)= STP*W(ISPT+NPT+I)
            W(IYPT+NPT+I)= G(I)-W(I)
         ENDDO
      ENDIF
      POINT=POINT+1
      IF (POINT.EQ.M) POINT=0
      IF (.NOT.(NODUMP)) THEN
         IF ((AMBER).AND.(MOVIE)) CALL AMOVIEDUMP(FRAME)
      ENDIF
      FIXIMAGE=.FALSE.
      IF ((FIXAFTER.GT.0).AND.(ITER.GE.FIXAFTER)) FIXIMAGE=.TRUE.
      GOTO 10

      RETURN
      END
