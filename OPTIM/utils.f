C   OPTIM: A PROGRAM FOR OPTIMIZING GEOMETRIES AND CALCULATING REACTION PATHWAYS
C   COPYRIGHT (C) 1999-2006 DAVID J. WALES
C   THIS FILE IS PART OF OPTIM.
C
C   OPTIM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C   IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C   THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C   (AT YOUR OPTION) ANY LATER VERSION.
C
C   OPTIM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
C   BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
C   GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C   YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C   ALONG WITH THIS PROGRAM; IF NOT, WRITE TO THE FREE SOFTWARE
C   FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330, BOSTON, MA  02111-1307  USA
C

      SUBROUTINE NORMAL(X,N)
C
C NORMALIZES VECTOR X
C
      IMPLICIT NONE
      INTEGER I,N
      DOUBLE PRECISION X(N),Q,P

      Q=0.D0
      DO I=1,N
         Q=Q+X(I)**2
      ENDDO
      P=DSQRT(Q)
      IF(P.LT.1D-14)THEN
      WRITE(6,*)' NULL VECTOR RETURNED FROM NORMAL'
      RETURN
      ENDIF
      DO I=1,N
         X(I)=X(I)/P    
      ENDDO
      RETURN
      END 
C
C  NORMALIZE VECTOR VEC1
C
      SUBROUTINE VECNORM(VEC1,NOPT)
      IMPLICIT NONE
      INTEGER J2, NOPT
      DOUBLE PRECISION DUMMY2, VEC1(NOPT)

      DUMMY2=0.0D0
      DO J2=1,NOPT
         DUMMY2=DUMMY2+VEC1(J2)**2
      ENDDO
!     PRINT '(A,G20.10)','VECNORM> DUMMY2=',DUMMY2
      IF (DUMMY2.GT.0.0D0) THEN
         DUMMY2=1.0D0/DSQRT(DUMMY2)
         DO J2=1,NOPT
            VEC1(J2)=VEC1(J2)*DUMMY2
         ENDDO
      ENDIF

      RETURN
      END
    
C      SUBROUTINE CALCVEC(A,B,V,IX)
CC
CC CALCULATES THE VECTOR V BETWEEN CARTESIAN POINTS A AND B
CC
C      IMPLICIT NONE
C      DOUBLE PRECISION A(3),B(3),V(3)
C      INTEGER IX,I
C
C      DO I=1,3
C         V(I)=B(I)-A(I)
C      ENDDO
C      IF(IX.EQ.1)CALL NORMAL(V,3)
C
C      RETURN
C      END 

      SUBROUTINE VADD(A,B,C,N,IP)
      IMPLICIT NONE
      INTEGER N,IP,I
      DOUBLE PRECISION A(N),B(N),C(N)

      DO I=1,N
         A(I)=B(I)+C(I)*IP
      ENDDO
      RETURN
      END         

      SUBROUTINE VSTAT(V,ZQ,LENGTH,N)
C
C RETURNS STATISTICAL INFO ABOUT VECTOR V IN ZQ
C     ZQ(1)  LARGEST ABSOLUTE MAGNITUDE
C     ZQ(2)  SMALLEST ABSOLUTE MAGNITUDE
C     ZQ(3)  LARGEST VALUE
C     ZQ(4)  SMALLEST VALUE
C     ZQ(5)  2-NORM
C     ZQ(6)  DYNAMIC RANGE OF THE VECTOR (ABS. MIN. - ABS. MAX.)
C   

      IMPLICIT NONE
      INTEGER N,I,LENGTH
      DOUBLE PRECISION V(N),ZQ(6),U

      U=0.D0
      ZQ(1:6)=0.0D0
      ZQ(2)=DABS(V(1))
      ZQ(4)=V(1)
C     PRINT*,'STATISTICS REPORTED FOR VECTOR:'
C     WRITE(*,10) (J,V(J),J=1,LENGTH)
C10    FORMAT(I4,F20.10)
      DO I=1,LENGTH
         ZQ(1)=MAX(ZQ(1),DABS(V(I)))
         ZQ(2)=MIN(ZQ(2),DABS(V(I)))
         ZQ(3)=MAX(ZQ(3),V(I))
         ZQ(4)=MIN(ZQ(4),V(I))
         U=U+V(I)*V(I)
      ENDDO
      IF (LENGTH .NE. 0.0) ZQ(5)=DSQRT(U/LENGTH)
      ZQ(6)=ZQ(2)-ZQ(1)
      RETURN
      END

       INTEGER FUNCTION ATOI (STRING)
C:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
C PURPOSE:      CONVERT STRING TO AN INTEGER VALUE
C
C ARGUMENTS:    STRING   CHARACTER STRING (INPUT ONLY)
C:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
C 
C REVISION 4.0  89/03/14  01:15:20  BERNHOLD
C BASELINE FOR SUN & VAX PRIOR TO PORTING EVERYWHERE
C 
C REVISION 3.0  89/01/29  23:09:23  BERNHOLD
C FIRST WORKING RELEASE FOR VAX
C 
C REVISION 2.1  89/01/02  20:35:02  BERNHOLD
C TO KEEP CONSISTENT WITH .U FILE JUST CHECKED IN.
C 
C
C SYSTEM:       STANDARD FORTRAN 77
C
C COPYRIGHT 1988 DAVID E. BERNHOLDT
C:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
       CHARACTER(LEN=80) STRING
       CHARACTER(LEN=1) C
       INTEGER I
       LOGICAL NEG
C
       ATOI = 0
       NEG = .FALSE.
       I = 1
       C = STRING(I:I)
C
C      PASS OVER ANY LEADING SPACES
C
 100   IF (C .EQ. ' ') THEN
          I = I + 1
          C = STRING(I:I)
          GOTO 100
       ENDIF
C
C      SEE IF FIRST CHARACTER MAKES THE NUMBER NEGATIVE
C      ACCEPT + AS VALID CHARACTER BEFORE THE DIGITS START
C
       IF (C .EQ. '-') THEN
          NEG = .TRUE.
          I = I + 1
          C = STRING(I:I)
       ELSEIF (C .EQ. '+') THEN
          I = I + 1
          C = STRING(I:I)
       ENDIF
C
C      CONTINUE AS LONG AS ITS A DIGIT...
C
 200   IF (LGE(C, '0') .AND. LLE(C,'9')) THEN
C            SHIFT NUMBER OVER & ADD NEW DIGIT
          ATOI = 10*ATOI + ICHAR(C)-48
          I = I + 1
          C = STRING(I:I)
          GOTO 200
       ENDIF
C
C      NEGATE THE RESULT IF NECESSARY
C
       IF (NEG) ATOI = -ATOI
       RETURN
       END
C*****************************************************
      
      SUBROUTINE MATMULV(A,B,C,NA,NB,NC)
! DOXYGEN {{{
!> \NAME MATMULV 
!> \BRIEF MULTIPLY MATRICES: A=B*C
!> \PARAM[OUT] A - OUTPUT MATRIX => A=BC 
!> \PARAM[IN] B,C - INPUT MATRICES 
!> \PARAM[IN] NA,NB,NC (INTEGER) MATRIX DIMENSIONS
! }}}
      IMPLICIT NONE
      INTEGER I,K,J,NA,NB,NC
      DOUBLE PRECISION A(NC,NA),B(NB,NA),C(NB,NC),Z

      DO I=1,NA
         DO K=1,NC
            Z=0.D0
            DO J=1,NB
               Z=Z+B(J,I)*C(J,K)
C              PRINT*,'I,K,J,B,C,Z=',I,K,J,B(J,I),C(J,K),Z
            ENDDO
            A(K,I)=Z
         ENDDO
      ENDDO

      RETURN 
      END
       CHARACTER*(*) FUNCTION ITOA(NR, FRCPLS)
! DOXYGEN {{{
!> \NAME ITOA 
!> \BRIEF CONVERT NUMBER TO A LEFT JUSTIFIED STRING
!> \PARAM[IN] NR NUMBER TO BE CONVERTED
!> \PARAM[IN] FRCPLS FORCE LEADING '+' IF NR POSITIVE
! }}}
C DESCRIPTION {{{
C:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
C PURPOSE:      CONVERT NR TO A LEFT JUSTIFIED STRING
C
C ARGUMENTS:
C     NR       NUMBER TO BE CONVERTED (INPUT ONLY)
C     FRCPLS   FORCE LEADING '+' IF NR POSITIVE (INPUT ONLY)
C
C LIMITATIONS:
C     MAY RETURN WITH INCOMPLETE CONVERSION IF LENGTH OF ITOA IS TOO
C     SHORT.  PUTS '*' IN LAST POSITION OF ITOA TO INDICATE OVERLOW.
C:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
C
C REVISION 4.0  89/03/14  01:15:45  BERNHOLD
C BASELINE FOR SUN & VAX PRIOR TO PORTING EVERYWHERE
C 
C REVISION 3.0  89/01/29  23:10:22  BERNHOLD
C FIRST WORKING RELEASE FOR VAX
C 
C REVISION 2.1  89/01/02  20:36:12  BERNHOLD
C TO KEEP CONSISTENT WITH .U FILE JUST CHECKED IN.
C 
C     REVISION 1.1  88/12/07  13:38:51  BERNHOLD
C     INITIAL REVISION
C     
C
C SYSTEM:       STANDARD FORTRAN 77
C
C COPYRIGHT 1988 DAVID E. BERNHOLDT
C:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
C }}}
      INTEGER NR, FRCPLS, NRABS
      INTEGER I, J, N, NDIG
C
C     CLEAR OUT THE STRING
C
      DO 10 I = 1, LEN(ITOA)
         ITOA = ' '
 10   CONTINUE
C
C     START COUNTING POSITION IN STRING
C
      J = 1
      NRABS = ABS (NR)
C
C     PUT IN SIGN AS APPROPRIATE
C
      IF (NR .LT. 0) THEN
         ITOA(J:J) = '-'
         J = J + 1
      ENDIF
      IF (FRCPLS .NE. 0 .AND. NR .GT. 0) THEN
         ITOA(J:J) = '+'
         J = J + 1
      ENDIF
C
C     CHECK IF WE ARE ABOUT TO OVERFLOW THE STRING
C
      IF (J .GT. LEN(ITOA)) THEN
         ITOA(J-1:J-1) = '*'
         RETURN
      ENDIF
C
C     LOOP OVER NR OF DIGITS IN NUMBER
C
      NDIG = INT( LOG10( FLOAT(NRABS)) ) + 1
      DO 100 I = NDIG, 1, -1
         N = MOD ( ( NRABS / (10**(I-1) ) ), 10)
         ITOA(J:J) = CHAR(N + 48)
         J = J + 1
C
C        CHECK FOR OVERFLOW OF THE STRING, BUT IF THIS IS LAST DIGIT
C        THEN ITS OKAY.
C
         IF (J .GT. LEN(ITOA) .AND. I .GT. 1) THEN
            ITOA(J-1:J-1) = '*'
            RETURN
         ENDIF
 100  CONTINUE
C
      RETURN
      END
      CHARACTER(LEN=4) FUNCTION STRING(NAME,IORD)
      CHARACTER(LEN=4) NAME, ITOA*3
      INTEGER IORD
      IF (NAME(2:2) .EQ. 'N') THEN
         STRING(1:1) = NAME(1:1)
         STRING(2: ) = ITOA(IORD, 0)
         STRING(LNBLNK(STRING)+1:) = NAME(3:3)
      ELSE
         STRING = NAME
      ENDIF
      RETURN
      END
      FUNCTION DOTOPT(A,B,N)
      IMPLICIT NONE
      INTEGER I,N
      DOUBLE PRECISION A(N),B(N), DOTOPT

      DOTOPT=0.D0
      DO I=1,N
         DOTOPT=DOTOPT+A(I)*B(I)
      ENDDO
      RETURN
      END

      SUBROUTINE CROSSOPT(A,B,C,IX)
C
C CALCULATES THE (OPTIONALLY) NORMALIZED VECTOR CROSS PRODUCT C=A X B
C
      IMPLICIT NONE
      INTEGER IX
      DOUBLE PRECISION A(3),B(3),C(3)

      C(3)=A(1)*B(2)-B(1)*A(2)
      C(2)=-A(1)*B(3)+A(3)*B(1)
      C(1)=A(2)*B(3)-A(3)*B(2)
      IF(IX.EQ.1)CALL NORMAL(C,3)
      RETURN
      END
C
C CALCULATES THE DISTANCE BETWEEN TWO POINTS IN CARTESIAN SPACE
C
      FUNCTION DIST(A,B)
      IMPLICIT NONE
      INTEGER I
      DOUBLE PRECISION A(3),B(3),Z,DIST

      Z=0.D0
      DO I=1,3
         Z=Z+(A(I)-B(I))**2
      ENDDO
      DIST=DSQRT(Z)
      RETURN
      END

C
C     ROBUST EQUIVALENCE CHECK - DO WELL DEFINED SORT ON COORDINATE
C     MATRIX AND COMPARE ELEMENT BY ELEMENT.  SHOULD BE FOOLPROOF.
C
C     VEC      COORDINATE VECTOR TO BE CHECKED (MODIFIED)
C     VECR     SORTED REFERENCE COORDINATE VECTOR (INPUT ONLY)
C     NORD     ???
C     ICOMP    NUMBER OF COORDINATES OUTSIDE OF TOL (OUTPUT ONLY)
C     TOL      TOLERANCE FOR COMPARISON OF COORDS (INPUT ONLY)
C
      SUBROUTINE COMPARE2(VEC,VECR,NORD,ICOMP,TOL)
      USE COMMONS
      IMPLICIT NONE
C     MAXIMUM NUMBER OF ATOMS CURRENTLY ALLOWED
      INTEGER NORD(2*NATOMS+1),I,JAP,ICOMP
      DOUBLE PRECISION VEC(3*NATOMS),VECR(3*NATOMS),Z,TOL
C
      ICOMP=0
      IF (IPRNT.GT.130) THEN
         WRITE(6,*)'INPUT VECTOR BEFORE SORTING'
         WRITE(6,80)(VEC(JAP),JAP=1,3*NATOMS)
 80   FORMAT(3(1X,F10.5))
      ENDIF
      CALL SORTXYZ(VEC,VEC,NORD(NATOMS+1),TOL)
      IF (IPRNT.GT.130) THEN
         WRITE(6,*)'COMPARISON VECTOR'
         WRITE(6,80)(VECR(JAP),JAP=1,3*NATOMS)
         WRITE(6,*)'SORTED INPUT VECTOR'
         WRITE(6,80)(VEC(JAP),JAP=1,3*NATOMS)
      ENDIF
      DO 30 I=1,NATOMS*3
         Z = DABS( VECR(I)-VEC(I) )
C        PRINT*,'I,Z,VECR,VEC=',I,Z,VECR(I),VEC(I)
         IF (Z.GT.TOL) THEN
            ICOMP = ICOMP + 1
            RETURN
         ENDIF
30    CONTINUE
      RETURN
      END

       INTEGER FUNCTION LNBLNK (STRING)
C:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
C PURPOSE:   RETURNS THE POSITION OF THE LAST NON-BLANK CHARACTER
C
C ARGUMENTS: STRING   CHARACTER STRING (INPUT ONLY)
C
C REMARKS:   ALL FORTRAN 77 CHARACTER VARIABLES ARE BLANK PADDED ON THE
C            RIGHT.  THE INTRINSIC FUNCTION LEN RETURNS THE DIMENSION
C            OF THE CHARACTER OBJECT, NOT THE LENGTH OF THE CONTENTS.
C            
C:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
C
C    REVISION 0.0  87/07/24  BERNHOLDT (VAX)
C
C    REVISION 1.1  88/01/11  22:08:15  BERNHOLD
C    INITIAL REVISION
C    
C
C SYSTEM:     STANDARD FORTRAN 77
C
C COPYRIGHT 1987 DAVID E. BERNHOLDT
C:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
       INTEGER I
       CHARACTER*(*) STRING
       CHARACTER(LEN=1) BLANK
       PARAMETER (BLANK = ' ')
C
C      START AT THE END AND WORK BACKWARDS
C
       DO 100 I = LEN(STRING), 1, -1
C         LOOK FOR FIRST NON-WHITESPACE CHARACTER
          IF (STRING(I:I) .NE. BLANK) THEN
             LNBLNK = I
             RETURN
          ENDIF
  100  CONTINUE
C
C      IF WE GET THIS FAR, THE STRING IS EMPTY
       LNBLNK = 0
       RETURN
       END

      SUBROUTINE MTRANSOPT(A,AT,NR,NC,NTR,NTC)
      IMPLICIT NONE
      INTEGER I,J,NTC,NTR,NR,NC
      DOUBLE PRECISION A(NR,NC),AT(NC,NR)

      DO I=1,NTR
         DO J=1,NTC
            AT(J,I)=A(I,J)
         ENDDO
      ENDDO
      RETURN
      END
        FUNCTION ANGMAG(ORBIT,D,IORDER,IRETURN)
        IMPLICIT NONE
        INTEGER IRETURN, IORDER
        DOUBLE PRECISION DTOR, ORDER, A1, X, TOP, BOT, ORBIT, D, ANGMAG
        IRETURN=0
        ANGMAG=0.D0
        DTOR=DACOS(-1.D0)/180.D0
        ORDER=FLOAT(IORDER)
        A1=180.D0/ORDER
        IF(DABS(A1-90.D0).LT.1.D-3)THEN
          ANGMAG=0.D0
        RETURN
        ENDIF
        X=ORBIT**2-0.25D0*D**2/DSIN(DTOR*A1)**2
        TOP=D/DTAN(DTOR*A1)
        IF(X.LT.-1.D-12)THEN
C
C THE ROTATION IS IMPOSSIBLE
C
         IRETURN=1
         RETURN
        ENDIF
        IF(DABS(X).LT.1.D-6)THEN
          ANGMAG=90.D0
        ELSE
        BOT=2.D0*DSQRT(X)
          ANGMAG=DATAN(TOP/BOT)/DTOR
        ENDIF
        RETURN
        END         
C
C REFLECTS POINTS IN PLANE
C
      SUBROUTINE REFLECT(A,SCRATCH,NATOM,IPLANE)
      IMPLICIT NONE
      INTEGER I,J,IX,NATOM,IPLANE
      DOUBLE PRECISION A(3,NATOM),SCRATCH(3,NATOM)
C
      IX(I,J)=MIN(I,J)/MAX(I,J)
C
      DO I=1,NATOM
         DO J=1,3
            SCRATCH(J,I)=A(J,I)*(1.D0-2.D0*IX(IPLANE,J))
         ENDDO
      ENDDO
      RETURN
      END

        SUBROUTINE PIKSR2(N,ARR,NLIST)
        IMPLICIT NONE
        INTEGER N,NLIST(N),I,J,NLST
        DOUBLE PRECISION ARR(N),A

        DO 12 J=2,N
        A=ARR(J)
        NLST=NLIST(J)
        DO 11 I=J-1,1,-1
         IF(ARR(I).LE.A)GOTO 10
         ARR(I+1)=ARR(I)
         NLIST(I+1)=NLIST(I)
   11   CONTINUE
        I=0
   10   ARR(I+1)=A
        NLIST(I+1)=NLST
   12   CONTINUE
        RETURN
        END

      SUBROUTINE SCDOT(X,V,N)
      IMPLICIT NONE
      INTEGER I,N
      DOUBLE PRECISION V(N), X

      DO I=1,N
         V(I)=V(I)*X
      ENDDO
      RETURN
      END
