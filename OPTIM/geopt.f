C   OPTIM: A PROGRAM FOR OPTIMIZING GEOMETRIES AND CALCULATING REACTION PATHWAYS
C   COPYRIGHT (C) 1999-2006 DAVID J. WALES
C   THIS FILE IS PART OF OPTIM.
C
C   OPTIM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C   IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C   THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C   (AT YOUR OPTION) ANY LATER VERSION.
C
C   OPTIM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
C   BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
C   GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C   YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C   ALONG WITH THIS PROGRAM; IF NOT, WRITE TO THE FREE SOFTWARE
C   FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330, BOSTON, MA  02111-1307  USA
C
      SUBROUTINE GEOPT(FNAMEF,EFNAMEF,Q)
      USE COMMONS
      USE KEY
      USE MODTWOEND
      USE MODHESS
      USE MODCHARMM
      USE PORFUNCS
      USE BINARYIO
      USE MODEFOL
      USE MODNEB,ONLY : NEWCONNECTT
      USE AMHGLOBALS, ONLY : NMRES

      IMPLICIT NONE
      INTEGER FCALL, INEG, ECALL, NPCALL, SCALL, ITDONE, INFO, NEXMODES, I1, NUMHB, J1, HORDER, J3, NSTEP, J2, 
     &        IMAX, IDONE, ITS
      DOUBLE PRECISION  DIAG(3*NATOMS), ENERGY, EREAL, EVALMAX, EVALMIN, ETIME, FTIME, STIME, Q(3*NATOMS), OMAX,
     1                  RMS, RMS2, VECS(3*NATOMS), VNEW(3*NATOMS), IT(3,3), IV(3,3), AMASS, ATMASSSAVE(NATOMS), DUMMY,
     2                  EVALUES(3*NATOMS),TEMPA(9*NATOMS), DUMQ(3*NATOMS), ITX, ITY, ITZ, RMSD, RGYR, PROD, DPRAND, TSDISP,
     &                  EVSAVE(3*NATOMS), ESAVE, TSDISPSAVE, MINFRQ2, MINCURVE, GRAD(3*NATOMS), RPBN, QFAC
      DOUBLE PRECISION DIFF, ORDERPLUS, ORDERMINUS, DIST, DIST2, RMAT(3,3), QPATH(3*NATOMS)
      DOUBLE PRECISION, ALLOCATABLE :: ORDERDERIV(:),ORDER(:),ORDERSAVE(:)
      DOUBLE PRECISION QSAVE(3*NATOMS)
      CHARACTER(LEN=80) FNAMEF
      CHARACTER(LEN=20) EFNAMEF
      CHARACTER(LEN=22) ITSTRING
      CHARACTER(LEN=5)  ADUMMY
      LOGICAL MFLAG, ZT(3*NATOMS)
      LOGICAL :: BTEST, LSELECT, LNATIVE, INERTIAT=.TRUE.
!     AMH LOCAL VARIABLES
      INTEGER :: NRES,I_RES, GLY_COUNT, IPOT
!      CHARACTER(LEN=5) :: TARFL
      CHARACTER(LEN=2) :: SDUMMY 

      COMMON /PCALL/ NPCALL, ECALL, FCALL, SCALL, ETIME, FTIME, STIME
      LOGICAL KNOWE, KNOWG, KNOWH
      COMMON /KNOWN/ KNOWE, KNOWG, KNOWH
      LOGICAL CONNECTT, DUMPPATH, READPATH, CALCRATES, STOPFIRST, PROJGRAD
      DOUBLE PRECISION TEMPERATURE, HRED, XIMAGE(GCIMAGE,3*NATOMS), XINITIAL(3*NATOMS+1)
      INTEGER NCONNECT, NEWINR, ISTAT
      COMMON /CONN/ STOPFIRST, CONNECTT, NCONNECT, DUMPPATH, READPATH, CALCRATES, TEMPERATURE, HRED
      DOUBLE PRECISION BHENERGY
      COMMON /BHINTE/ BHENERGY
      DOUBLE PRECISION BISECTENERGY
      COMMON /BISECTE/ BISECTENERGY
      LOGICAL PATHT, DRAGT, LZT(NOPT)
      INTEGER NPATHFRAME
      COMMON /RUNTYPE/ DRAGT, PATHT, NPATHFRAME
C
C  STORAGE FOR DSYEVR FOR LOWESTFRQ CALCULATION
C
      INTEGER IWORK(33*3*NATOMS)
      INTEGER ILWORK, LWORK, NFOUND, ISUPPZ(2*3*NATOMS)
      DOUBLE PRECISION WORK(33*3*NATOMS), ABSTOL, DLAMCH
      DOUBLE PRECISION, ALLOCATABLE :: ZSAVE(:,:), ZWK(:,:)

      DOUBLE PRECISION :: MSB50AR(3*NATOMS)

      INTEGER KD,NNZ,NINTB ! JMC
      DOUBLE PRECISION DIHE,ALLANG ! JMC

      DOUBLE PRECISION ETS,EPLUS,EMINUS
      COMMON /OEPATH/ ETS,EPLUS,EMINUS


      LWORK=33*3*NATOMS
      ILWORK=33*3*NATOMS
      IF (NENDHESS.LE.0) NENDHESS=NOPT
C
C  *************** TWO-ENDED PATHWAYS ********************
C
      TTDONE=.FALSE.
      IF (TWOENDS) THEN
         CALL TWOEND(ENERGY,VNEW,VECS,Q)
         TTDONE=.TRUE.
      ENDIF
C
C  *************** BFGS MINIMIZATION ********************
C
      IF ((BHINTERPT.OR.BISECTT).AND.(.NOT.NEWCONNECTT).AND.(.NOT.REOPTIMISEENDPOINTS)) THEN ! DO NOTHING
      ELSE IF ((ENDHESS.OR.ENDNUMHESS).AND.(NSTEPS.EQ.0)) THEN ! NO GEOMETRY OPTIMISATION
         MFLAG=.TRUE.
      ELSE IF (HYBRIDMINT) THEN
         NSTEP=0
         CALL HYBRIDMIN(HMNSTEPS,Q,ENERGY,VNEW,MFLAG,RMS,EVALMIN,EVALMAX,VECS,ITDONE,.TRUE.,.TRUE.)
         NSTEP=ITDONE
         IF (.NOT.MFLAG) THEN
            PRINT '(A,I8,A)',' GEOPT> SWITCHING TO LBFGS MINIMISATION AFTER ',NSTEP,' HYBRID MINIMISATION STEPS'
            KNOWE=.FALSE.
            KNOWG=.FALSE.
            IF (CHRMMT.AND.INTMINT) THEN
               CALL MYLBFGS(NINTS,MUPDATE,Q,.FALSE.,MFLAG,ENERGY,RMS2,EREAL,RMS,BFGSSTEPS,
     1                      .TRUE.,ITDONE,.TRUE.,VNEW,.FALSE.,.FALSE.)
            ELSE
               CALL MYLBFGS(NOPT,MUPDATE,Q,.FALSE.,MFLAG,ENERGY,RMS2,EREAL,RMS,BFGSSTEPS,
     1                      .TRUE.,ITDONE,.TRUE.,VNEW,.FALSE.,.FALSE.)
            ENDIF
            NSTEP=NSTEP+ITDONE
         ENDIF
      ELSE IF ((BFGSMINT.AND.(.NOT.BFGSTST).AND.(.NOT.BFGSSTEP)).OR.(BFGSTST.AND.(HINDEX.EQ.0))) THEN
         IF (UNRST.OR.(CHRMMT.AND.INTMINT)) THEN
            CALL MYLBFGS(NINTS,MUPDATE,Q,.FALSE.,MFLAG,ENERGY,RMS2,EREAL,RMS,BFGSSTEPS,
     1                   .TRUE.,ITDONE,.TRUE.,VNEW,.FALSE.,.FALSE.)
         ELSE
            CALL MYLBFGS(NOPT,MUPDATE,Q,.FALSE.,MFLAG,ENERGY,RMS2,EREAL,RMS,BFGSSTEPS,
     1                   .TRUE.,ITDONE,.TRUE.,VNEW,.FALSE.,.FALSE.)
         ENDIF
C
C  ******** GREAT CIRCLE INTERPOLATION BETWEEN END POINTS ********************
C
      ELSE IF (GREATCIRCLET.AND.(.NOT.CONNECTT)) THEN
          IF (UNRST) THEN
             PRINT *,'NOT AVAILABLE'
             CALL FLUSH(6,ISTAT)
             STOP
          ELSE
             XINITIAL(1:3*NATOMS+1)= 0.0D0
             XINITIAL(3*NATOMS)= 1.0D0
             XINITIAL(3*NATOMS+1)= 1.0D0
             CALL GCLBFGS(Q,FIN,XIMAGE,3*NATOMS+1,GCUPDATE,XINITIAL,.FALSE.,GCCONV,MFLAG,ENERGY,RMS,
     1                   GCSTEPS,.TRUE.,ITDONE,.TRUE.)
          ENDIF
C
C  *************** MORPHING VIA COARSE-GRAINED EF ****************************
C
      ELSE IF (MORPHT.AND.(.NOT.CONNECTT)) THEN
          IF (UNRST) THEN
             PRINT *,'NOT AVAILABLE'
             CALL FLUSH(6,ISTAT)
             STOP
C            CALL INTMORPH(MSTEPS,Q,ENERGY,VNEW,MFLAG,RMS,EVALMIN,EVALMAX,VECS,ITDONE,.TRUE.,.TRUE.)
          ELSE
             CALL MORPH(MSTEPS,Q,FIN,ENERGY,VNEW,MFLAG,RMS,ITDONE,.TRUE.)
          ENDIF
C
C  *************** HYBRID EF ****************************
C
      ELSE IF (BFGSTST) THEN
          IF (UNRST) THEN
             PRINT '(A)', ' GEOPT> SETTING RANDOM INITIAL VECTOR FOR EIGENVECTOR'
             DO J1=1,NINTS
                VECS(J1)=DPRAND()*2-1.0D0
             ENDDO
             CALL VECNORM(VECS,NINTS)
             CALL INTBFGSTS(NSTEPS,Q,ENERGY,VNEW,MFLAG,RMS,EVALMIN,EVALMAX,VECS,ITDONE,.TRUE.,.TRUE.) 
          ELSE
             PRINT '(A)', ' GEOPT> SETTING RANDOM INITIAL VECTOR FOR EIGENVECTOR'
             DO J1=1,NOPT
                VECS(J1)=DPRAND()*2-1.0D0
             ENDDO 
             CALL VECNORM(VECS,NOPT)
             CALL BFGSTS(NSTEPS,Q,ENERGY,VNEW,MFLAG,RMS,EVALMIN,EVALMAX,VECS,ITDONE,.TRUE.,.TRUE.)
          ENDIF
C
C  WE MAY NOW HAVE THE ENERGY AND GRADIENT, SO THE FIRST ENERGY AND GRADIENT CALL IN
C  MYLBFGS FOR BFGSSTEP MAY BE UNNECESSARY
C
          IF (BFGSSTEP) THEN
C
C  SWITCH TO APPROPRIATE MINIMIZATION AFTER PUSHOFF.
C
             IF (.NOT.(RKMIN.OR.BSMIN)) BFGSMINT=.TRUE.
             IF (RKMIN) RMS=1.0D0
             MFLAG=.FALSE.
C            NOSHIFT=.TRUE.
             BFGSSTEP=.FALSE.
             BFGSTST=.FALSE.
             IF (.NOT.BFGSMINT) WRITE(*,'(A,26X,F20.10)') ' ENERGY AFTER PUSHOFF=  ',ENERGY
             IF (BFGSMINT) THEN
                IF (UNRST.OR.(CHRMMT.AND.INTMINT)) THEN
                   CALL MYLBFGS(NINTS,MUPDATE,Q,.FALSE.,MFLAG,ENERGY,RMS2,EREAL,RMS,
     1                       BFGSSTEPS,.TRUE.,ITDONE,.TRUE.,VNEW,.FALSE.,.FALSE.)
                ELSE
                   CALL MYLBFGS(NOPT,MUPDATE,Q,.FALSE.,MFLAG,ENERGY,RMS2,EREAL,RMS,BFGSSTEPS,
     1                          .TRUE.,ITDONE,.TRUE.,VNEW,.FALSE.,.FALSE.)
                ENDIF
             ELSE IF (BSMIN.OR.RKMIN) THEN
                CALL ODESD(NSTEPS,Q,MFLAG,ITDONE,.TRUE.)
             ENDIF
          ENDIF
      ELSE IF (BSMIN.OR.RKMIN) THEN
         CALL ODESD(NSTEPS,Q,MFLAG,ITDONE,.TRUE.)
         IF (.NOT.MFLAG) THEN
            BSMIN=.FALSE.
            RKMIN=.FALSE.
            BFGSMINT=.TRUE.
            KNOWE=.FALSE.
            KNOWG=.FALSE.
            CALL MYLBFGS(NOPT,MUPDATE,Q,.FALSE.,MFLAG,ENERGY,RMS2,EREAL,RMS,BFGSSTEPS,
     1                   .TRUE.,ITDONE,.TRUE.,VNEW,.FALSE.,.FALSE.)
         ENDIF
      ELSE
C
C  *************** EF OPTIMIZATION (OR PAGE-MCIVER SECOND ORDER SD) ***************
C
         NEWINR=INR
         CALL EFOL(Q,MFLAG,NSTEPS,ENERGY,ITDONE,EVALMIN,.TRUE.,DIAG,NEWINR)
      ENDIF
C
C  *************** END OF OPTIMISATION POSSIBILITIES. CHECKINDEX IF REQUIRED. *****
C
      IF ((MFLAG.AND.CHECKINDEX).AND.(BFGSMINT.OR.BFGSTST.OR.BSMIN.OR.RKMIN)) THEN
         INEG=0
         IF (BFGSTST) INEG=1
         IF (NOHESS) THEN
            CALL CHECKIND2(Q,MFLAG,INEG,ENERGY)
         ELSE
C
C  WE NEED THE HESSIAN IN CHECKIND.
C
            IF (BFGSMINT.OR.BSMIN.OR.RKMIN) CALL POTENTIAL(Q,ENERGY,VNEW,.TRUE.,.TRUE.,RMS,.FALSE.,.FALSE.)
            CALL CHECKIND(Q,MFLAG,INEG,ENERGY,EVALMIN,EVALMAX,.FALSE.)
         ENDIF
      ENDIF
!
! IF WE HAVE JUST FINISHED THE BHINTERPT OR BISECTT PROCEDURE AND GEOPT
! IS BEING CALLED TO MAKE MIN.DATA.INFO MFLAG IS NOT SET, AND COULD BE FALSE.
!
      IF ((BHINTERPT.OR.BISECTT).AND.(.NOT.NEWCONNECTT).AND.(.NOT.REOPTIMISEENDPOINTS)) MFLAG=.TRUE.
      IF (.NOT.MFLAG) GOTO 11 ! SKIP THE CALCULATIONS FOR MIN.DATA.INFO CONSTRUCTION
C
C DAE
C MAY WANT TO CALCULATE RATE FROM SYSTEM WHICH HAS NO SECOND DERIVATIVES IN THE POTENTIAL
C THERE ARE TWO POSSIBILITES FOR DOING THIS
C ONE IS CONSTRUCTING A NUMERICAL HESSIAN AND DIAGONALISE - REMEMBER MASS WEIGHTING
C OR COULD MAKE APPROXIMATION THAT ONLY THE HIGHEST (LOWEST?!) FREQUENCY MODE IS IMPORTANT AND USE
C THE XMYLBFGS ROUTINE TO GIVE ESTIMATE OF THIS FOR STATIONARY POINTS - AGAIN NEED MASS WEIGHTING
C
C ALTERNATIVELY MAY WANT TO DO BFGS MINIMISATION ON A SYSTEM WHERE SECOND DERIVATIVES
C ARE AVAILABLE BUT ONLY USE THE SEC.DER. AT THE END
C
C IN ALL CASES AIM TO TO MIMIC OUTPUT OF EFOL OF 'LOG PRODUCT ...', SO THAT
C GREP IN FILTHY OR PATHSAMPLE CAN COPE WITHOUT MODIFICATION.
C SHOULD REMOVE NEED FOR PAUL;S GMFREQ AND CRAP (SIC!) PROGRAMS WHICH HE INTRODUCED TO DO
C MASS WEIGHTING
C
C MAY WANT TO REWRITE ABOVE CHECKINDEX CODE TO AVOID DUPLICATION OF EFFORT
C
      IF (NOFRQS) THEN
         PROD=1.0D0
!
! REOPTIMISEENDPOINTS IS SET TO FALSE AFTER A BHINTERP RUN IS FINISHED
! SO THAT SECOND DERIVATIVES ARE ONLY CALCULATED AT THE END.
!

!     ELSEIF (ENDHESS .AND. ((.NOT. (REOPTIMISEENDPOINTS.AND.(BHINTERPT.OR.BISECTT))).AND.DUMPDATAT)) THEN
      ELSEIF (ENDHESS .AND. (.NOT. (REOPTIMISEENDPOINTS.AND.(BHINTERPT.OR.BISECTT)))) THEN
         IF (ENDNUMHESS) THEN
            IF (UNRST) THEN
               CALL MAKENUMINTHESS(NINTS,NATOMS)
               WRITE (*,'(A)') ' GEOPT> VALUE BELOW CALCULATED FROM NUMERICAL HESSIAN' 
               CALL GETSTUFF(KD,NNZ,NINTB)
               CALL INTSECDET(Q,3*NATOMS,KD,NNZ,NINTB,EVALUES)
               NEXMODES=0
C JMC HOW MANY EIGENVALUES? USE NEXMODES TO GET RIGHT NUMBER FOR INTERNALS...
               IF (BFGSMINT) THEN
                  NEXMODES=3*NATOMS-NINTS
               ELSEIF (BFGSTST) THEN
                  NEXMODES=3*NATOMS-NINTS+1
               END IF
            ELSEIF (RINGPOLYMERT) THEN
               CALL MAKENUMHESSRP(Q,NOPT)
               WRITE (*,'(A)') ' GEOPT> VALUE BELOW CALCULATED FROM NUMERICAL HESSIAN'
            ELSE
               CALL MAKENUMHESS(Q,NATOMS)
               WRITE (*,'(A)') ' GEOPT> VALUE BELOW CALCULATED FROM NUMERICAL HESSIAN'
            ENDIF
         ELSE
C
C MIGHT WANT TO DO THIS IF ANALYTICAL HESSIAN IS AVAILABLE E.G. AFTER A BFGSMIN RUN
C
            CALL POTENTIAL(Q,ENERGY,VNEW,.TRUE.,.TRUE.,RMS,.FALSE.,.FALSE.)  
            WRITE (*,'(A)') ' GEOPT> VALUE BELOW CALCULATED FROM TRUE HESSIAN'
         ENDIF

         IF (.NOT.UNRST) THEN
C
C DAE DSEYV SORTS EIGENVALUES SO 6 ZERO ONES SHOULD BE AT BOTTOM
C THEREFORE DO PRODUCT UP TO 3*NATOMS-6
C THIS WILL ONLY WORK FOR ISOLATED NON-LINEAR SYSTEMS - FINE FOR CHARMM
C FOR GENERAL CASE NEED CODE INVOLVING ZT FROM EFOL
C
            NEXMODES=6
            IF (BFGSMINT.AND.(.NOT.BFGSTST)) THEN
               NEXMODES=6
            ELSEIF (BFGSTST) THEN
               NEXMODES=7
            ELSEIF (INR.EQ.2) THEN ! THIS WILL DETECT HIGHER ORDER SADDLES
               NEXMODES=7
            ENDIF
            IF (BULKT) NEXMODES=NEXMODES-3
            IF (BULKT.AND.TWOD) NEXMODES=NATOMS+2
            IF (PULLT.OR.EFIELDT) NEXMODES=4
            IF (TWOD) NEXMODES=NEXMODES+NATOMS
            IF (FREEZE) THEN
               NEXMODES=3*NFREEZE
            ENDIF
            IF (RBAAT) THEN
               IF (EFIELDT) THEN
                  NEXMODES = 4
               ELSE
                  NEXMODES = 6
               ENDIF
               IF (STOCKAAT) NEXMODES = NEXMODES + NATOMS/2
            ENDIF
            IF (RINGPOLYMERT) THEN
               IF (RPSYSTEM(1:4).EQ.'AECK') THEN
                  NEXMODES=0
               ELSE
                  NEXMODES=6
               ENDIF
               IF (BFGSTST.OR.(INR.EQ.2)) NEXMODES=NEXMODES+1
               IF (BFGSMINT) NEXMODES=NEXMODES+2
            ENDIF
            WRITE(*,'(A,I6)') ' GEOPT> NUMBER OF ZERO/IMAGINARY EIGENVALUES ASSUMED TO BE ',NEXMODES
            IF (LOWESTFRQT) THEN
C
C  CALCULATE LOWEST NON-ZERO EIGENVALUE AND DUMP TO MIN.DATA.INFO FILE
C  NO MASS-WEIGHTING HERE!
C  'U' SPECIFIES THAT THE UPPER TRIANGLE CONTAINS THE HESSIAN.
C  NEED TO SAVE HESS BEFORE THIS CALL AND RESTORE AFTERWARDS.
C
    
               ABSTOL=DLAMCH('SAFE  MINIMUM')
               IF (ALLOCATED(ZWK)) DEALLOCATE(ZWK)
!              ALLOCATE(ZWK(NOPT,NEXMODES+1))
               ALLOCATE(ZWK(1,1))
               ALLOCATE(ZSAVE(NOPT,NOPT))
               ZSAVE(1:NOPT,1:NOPT)=HESS(1:NOPT,1:NOPT)
               CALL DSYEVR('N','I','U',NOPT,HESS,NOPT,0.0D0,1.0D0,1,NEXMODES+1,ABSTOL,
     &                        NFOUND,EVALUES,
     &                        ZWK,NOPT,ISUPPZ,WORK,
     &                        LWORK, IWORK, ILWORK, INFO )
               MINCURVE=EVALUES(NEXMODES+1)
               DEALLOCATE(ZWK)
               HESS(1:NOPT,1:NOPT)=ZSAVE(1:NOPT,1:NOPT)
               DEALLOCATE(ZSAVE)
               PRINT '(A,G20.10)',' GEOPT> LOWEST NON-ZERO POSITIVE EIGENVALUE=',MINCURVE
               DO J1=1,NEXMODES+1
                  PRINT '(I8,G20.10)',J1,EVALUES(J1)
               ENDDO
            ENDIF
!           PRINT '(A,I6,A)',' GEOPT> IGNORING THE ',NEXMODES,' LOWEST HESSIAN EIGENVALUES'
!           WRITE(*,*) 'ATMASS=', ATMASS(:)
            IF (CHRMMT) THEN
               CALL MASSWT2(NATOMS,ATMASS,Q,VNEW,.TRUE.)  ! JUST DOES THE HESSIAN
            ELSEIF (RINGPOLYMERT) THEN
               CALL MASSWTRP(NOPT,RPMASSES,RPDOF) ! JUST DOES THE HESSIAN
            ELSE
               CALL MASSWT(NATOMS,ATMASS,Q,VNEW,.TRUE.)   ! DOES THE HESSIAN, COORDINATES AND GRADIENT VECTOR
            ENDIF
C
C CALLING DSEYV WITH 'N' AS WE;RE NOT INTERESTED IN THE EIGENVECTORS
C HARD-WIRED CALCULATION OF EIGENVALUES AND EIGENVECTORS FOR DIALA SYSTEM
C IN ORDER TO GET PHI AND PSI NUMERICAL DERIVATIVES.
C
C IN THE NEW SCHEME WE ONLY INCLUDE THE DERIVATIVE THAT IS LARGEST IN MAGNITUDE TO THE
C CORRESPONDING ORDER PARAMETER.
C
            IF (ORDERPARAMT) THEN
C IF AMBER OR NAB, NEED TO UNDO THE MASS WEIGHTING  
               IF(.NOT.CHRMMT) THEN
                 DO J1=1,NATOMS
                    AMASS=1/SQRT(ATMASS(J1))
                    J3=3*J1
                    Q(J3-2)=AMASS*Q(J3-2)
                    Q(J3-1)=AMASS*Q(J3-1)
                    Q(J3)=AMASS*Q(J3)
                 ENDDO
               ENDIF
               IDONE=0
               QSAVE(1:3*NATOMS)=Q(1:3*NATOMS)  !SAVE THE TS COORDINATES
               TSDISP=0.0D0
               OPEN(UNIT=9123,FILE='ORDER.INFO',STATUS='UNKNOWN')
               IF ((NEXMODES.EQ.7).AND.(PATHT)) THEN
                  IF (FILTH.EQ.0) THEN
                     ITSTRING='POINTS.PATH.XYZ'
                  ELSE
                     WRITE(ITSTRING,'(A)') 'POINTS.PATH.XYZ.'//TRIM(ADJUSTL(FILTHSTR))
                  ENDIF
                  OPEN(UNIT=9124,FILE=ITSTRING,STATUS='UNKNOWN')
               ENDIF
               IF (PATHT) ALLOCATE(ORDERSAVE(NORDER))
333            ALLOCATE(ORDERDERIV(NORDER),ORDER(NORDER))
               CALL DSYEV('V','U',3*NATOMS,HESS,3*NATOMS,EVALUES,TEMPA,9*NATOMS,INFO)
               IF (EVALUES(1).LT.EVALUES(3*NATOMS)) CALL EIGENSORT_VAL_ASC(EVALUES,HESS,3*NATOMS,3*NATOMS)
               IF (IDONE.EQ.0) THEN
                  ESAVE=ENERGY
                  EVSAVE(1:3*NATOMS)=EVALUES(1:3*NATOMS)
                  VECS(1:3*NATOMS)=HESS(1:3*NATOMS,3*NATOMS)
               ENDIF
               PRINT '(A)',' GEOPT> PROJECTED HESSIAN EIGENVALUES:'
               PRINT '(6G20.10)',EVALUES(1:3*NATOMS)
               DIFF=1.0D-3
               IF (PATHT) THEN
                  DO I1=1,NORDER
                     IF ((CHRMMT).AND.(WHICHORDER(I1).EQ.'DIHE')) THEN
                        CALL GETDIHE(Q,ORDER(I1),ORDERNUM(I1))
                     ELSEIF ((AMBERT.OR.NABT).AND.(WHICHORDER(I1).EQ.'DIHE')) THEN
                        IF (I1.EQ.1) CALL AMBERDIHEDR(Q,NATOMS,5,7,9,15,ORDER(I1))
                        IF (I1.EQ.2) CALL AMBERDIHEDR(Q,NATOMS,7,9,15,17,ORDER(I1))
                     ENDIF
                  ENDDO
                  QPATH(1:3*NATOMS)=Q(1:3*NATOMS) ! SAVE THE SD PATH CONFIGURATION
                  IF (IDONE.EQ.0) THEN
                     ORDERSAVE(1:NORDER)=ORDER(1:NORDER)
                     ITS=0
                  ELSEIF (IDONE.GT.0) THEN
                     DUMMY=0.D0
                     DO I1=1,NORDER
                        DUMMY=DUMMY+(ORDERSAVE(I1)-ORDER(I1))**2
                     ENDDO
                     IF (SQRT(DUMMY).LT.0.1D0) ITS=1 
                  ENDIF
                  PRINT '(A,6G20.10)','ORDER PARAMETERS WITH PATH CONFIGURATION:        ',ORDER(1:NORDER) 
C TSDISP CALCULATION FOR PATHT ONLY AS A CHECK FOR HOW MUCH THE CARTESIAN STEEPEST DESCENT PATH
C DIVERGES FROM THE REACTION PATH 
                  TSDISPSAVE=TSDISP
                  DO J1=1,2
                     TSDISP=TSDISPSAVE*(-1.D0)**(J1+ITS)
                     DO J2=1,NATOMS
                        Q(3*(J2-1)+1)=QSAVE(3*(J2-1)+1)+(TSDISP*VECS(3*(J2-1)+1))/SQRT(ATMASS(J2))
                        Q(3*(J2-1)+2)=QSAVE(3*(J2-1)+2)+(TSDISP*VECS(3*(J2-1)+2))/SQRT(ATMASS(J2))
                        Q(3*(J2-1)+3)=QSAVE(3*(J2-1)+3)+(TSDISP*VECS(3*(J2-1)+3))/SQRT(ATMASS(J2))
                     ENDDO
                     DO I1=1,NORDER
                        IF ((CHRMMT).AND.(WHICHORDER(I1).EQ.'DIHE')) THEN
                           CALL GETDIHE(Q,ORDER(I1),ORDERNUM(I1))
                        ELSEIF ((AMBERT.OR.NABT).AND.(WHICHORDER(I1).EQ.'DIHE')) THEN
                           IF (I1.EQ.1) CALL AMBERDIHEDR(Q,NATOMS,5,7,9,15,ORDER(I1))
                           IF (I1.EQ.2) CALL AMBERDIHEDR(Q,NATOMS,7,9,15,17,ORDER(I1))
                        ENDIF
                     ENDDO
                     PRINT '(A,7G20.10)','TSDISP AND ORDER PARAMETERS: ',TSDISP,ORDER(1:NORDER) 
                  ENDDO
C USE STEEPEST DESCENT CONFIGURATIONS FOR DERIVATIVE CALCULATIONS
                  TSDISP=0.D0
                  Q(1:3*NATOMS)=QPATH(1:3*NATOMS)
                  DO I1=1,NORDER
                     IF ((CHRMMT).AND.(WHICHORDER(I1).EQ.'DIHE')) THEN
                        CALL GETDIHE(Q,ORDER(I1),ORDERNUM(I1))
                     ELSEIF ((AMBERT.OR.NABT).AND.(WHICHORDER(I1).EQ.'DIHE')) THEN
                        IF (I1.EQ.1) CALL AMBERDIHEDR(Q,NATOMS,5,7,9,15,ORDER(I1))
                        IF (I1.EQ.2) CALL AMBERDIHEDR(Q,NATOMS,7,9,15,17,ORDER(I1))
                     ENDIF
                  ENDDO
               ELSE
                  DO J2=1,NATOMS
                     Q(3*(J2-1)+1)=QSAVE(3*(J2-1)+1)+(TSDISP*VECS(3*(J2-1)+1))/SQRT(ATMASS(J2))
                     Q(3*(J2-1)+2)=QSAVE(3*(J2-1)+2)+(TSDISP*VECS(3*(J2-1)+2))/SQRT(ATMASS(J2))
                     Q(3*(J2-1)+3)=QSAVE(3*(J2-1)+3)+(TSDISP*VECS(3*(J2-1)+3))/SQRT(ATMASS(J2))
                  ENDDO
                  DO I1=1,NORDER
                     IF ((CHRMMT).AND.(WHICHORDER(I1).EQ.'DIHE')) THEN
                        CALL GETDIHE(Q,ORDER(I1),ORDERNUM(I1))
                     ELSEIF ((AMBERT.OR.NABT).AND.(WHICHORDER(I1).EQ.'DIHE')) THEN
                        IF (I1.EQ.1) CALL AMBERDIHEDR(Q,NATOMS,5,7,9,15,ORDER(I1))
                        IF (I1.EQ.2) CALL AMBERDIHEDR(Q,NATOMS,7,9,15,17,ORDER(I1))
                     ENDIF
                  ENDDO
               ENDIF 
               ORDERDERIV(1:NORDER)=0.D0
               DO J1=1,3*NATOMS ! CYCLE OVER NORMAL MODES
                  OMAX=0.0D0
                  DO I1=1,NORDER ! CYCLE OVER ORDER PARAMETERS
                     DO J2=1,NATOMS
                        Q(3*(J2-1)+1)=QSAVE(3*(J2-1)+1)+(TSDISP*VECS(3*(J2-1)+1)+DIFF*HESS(3*(J2-1)+1,J1))/SQRT(ATMASS(J2))
                        Q(3*(J2-1)+2)=QSAVE(3*(J2-1)+2)+(TSDISP*VECS(3*(J2-1)+2)+DIFF*HESS(3*(J2-1)+2,J1))/SQRT(ATMASS(J2))
                        Q(3*(J2-1)+3)=QSAVE(3*(J2-1)+3)+(TSDISP*VECS(3*(J2-1)+3)+DIFF*HESS(3*(J2-1)+3,J1))/SQRT(ATMASS(J2))
                     ENDDO
                     IF ((CHRMMT).AND.(WHICHORDER(I1).EQ.'DIHE')) THEN
                        CALL GETDIHE(Q,ORDERPLUS,ORDERNUM(I1))
                     ELSEIF ((AMBERT.OR.NABT).AND.(WHICHORDER(I1).EQ.'DIHE')) THEN
                        IF (I1.EQ.1) CALL AMBERDIHEDR(Q,NATOMS,5,7,9,15,ORDERPLUS)
                        IF (I1.EQ.2) CALL AMBERDIHEDR(Q,NATOMS,7,9,15,17,ORDERPLUS)
                     ENDIF
                     DO J2=1,3*NATOMS
                        Q(3*(J2-1)+1)=QSAVE(3*(J2-1)+1)+(TSDISP*VECS(3*(J2-1)+1)-DIFF*HESS(3*(J2-1)+1,J1))/SQRT(ATMASS(J2))
                        Q(3*(J2-1)+2)=QSAVE(3*(J2-1)+2)+(TSDISP*VECS(3*(J2-1)+2)-DIFF*HESS(3*(J2-1)+2,J1))/SQRT(ATMASS(J2))
                        Q(3*(J2-1)+3)=QSAVE(3*(J2-1)+3)+(TSDISP*VECS(3*(J2-1)+3)-DIFF*HESS(3*(J2-1)+3,J1))/SQRT(ATMASS(J2))
                     ENDDO
                     IF ((CHRMMT).AND.(WHICHORDER(I1).EQ.'DIHE')) THEN
                        CALL GETDIHE(Q,ORDERMINUS,ORDERNUM(I1))
                     ELSEIF ((AMBERT.OR.NABT).AND.(WHICHORDER(I1).EQ.'DIHE')) THEN
                        IF (I1.EQ.1) CALL AMBERDIHEDR(Q,NATOMS,5,7,9,15,ORDERMINUS)
                        IF (I1.EQ.2) CALL AMBERDIHEDR(Q,NATOMS,7,9,15,17,ORDERMINUS)
                     ENDIF
                     IF (J1.LE.3*NATOMS-NEXMODES) THEN
                        DUMMY=((ORDERPLUS-ORDERMINUS)/(2*DIFF))**2/EVALUES(J1)
                        IF (ABS(DUMMY).GT.ABS(OMAX)) THEN
                           OMAX=DUMMY
                           IMAX=I1
                        ENDIF
                        IF (DEBUG) PRINT '(A,I6,3G20.10)',' GEOPT> MODE,EIGENVALUE,DERIV CONTRIBUTION,TOTAL: ',J1,EVALUES(J1),
     &                              ((ORDERPLUS-ORDERMINUS)/(2*DIFF))**2/EVALUES(J1),ORDERDERIV(I1)
C                        ORDERDERIV(I1)=ORDERDERIV(I1)+DUMMY
                     ENDIF
                  ENDDO
                  ORDERDERIV(IMAX)=ORDERDERIV(IMAX)+OMAX
                  IF ((J1.LE.3*NATOMS-NEXMODES).AND.(DEBUG)) PRINT '(A,I6,A,G20.10,A,I6,A,G20.10)',' GEOPT> FOR MODE ',J1,
     &                                     ' MAXIMUM CONTRIBUTION IS ',OMAX,
     &                                     ' FOR MODE ',IMAX,' TOTAL=',ORDERDERIV(IMAX)
               ENDDO
C
C  PRINT INFORMATION FOR FES CALCULATION HERE.
C
               PROD=0.0D0
               DO I1=1,NENDHESS-NEXMODES
                  IF (I1.GT.1) THEN
                     IF (EVALUES(I1-1).NE.0.0D0) THEN
                        IF (ABS(EVALUES(I1)/EVALUES(I1-1)).LT.1.0D-2) THEN
                           PRINT '(A,G20.10,A,G20.10)',' GEOPT> WARNING - DECREASE IN MAGNITUDE OF EIGENVALUES FROM ',EVALUES(I1-1),
     &                                    ' TO ',EVALUES(I1)
                           PRINT '(A)',' GEOPT> WARNING - THIS COULD INDICATE A STATIONARY POINT OF THE WRONG INDEX'
                        ENDIF
                     ENDIF
                  ENDIF
                  IF (EVALUES(I1).GT.0.0D0) THEN
                     PROD=PROD+DLOG(EVALUES(I1))
                  ELSE
                     IF (I1.LT.(NENDHESS-NEXMODES)) PRINT *,'HIGHER ORDER SADDLE DETECTED: EIGENVALUE ',EVALUES(I1)
                     ! JMC PUT IN THIS TEST MAINLY FOR PATHSAMPLE PURPOSES...
                  ENDIF
               ENDDO
               IF (CHRMMT.OR.AMBERT.OR.NABT.OR.SDT) THEN
C
C IF CHARMM NEED TO CONVERT THIS TO HZ^2, RATHER THAN CHARMM UNIT
C CONVERSION FACTOR FOR THIS IS 4.184 X 10^26
C SAME FOR AMBER AND FOR STILLINGER-DAVID.
C ACTUALLY, THIS IS TO (RADIAN/S)^2
C
                  PROD=PROD+(NENDHESS-NEXMODES)*DLOG(4.184D26)
                  WRITE (*,'(A,G20.10)') ' GEOPT> SCALING PRODUCT OF EIGENVALUES TO SI UNITS (RADIAN/S)^2 BY ',
     &                                  (3*NATOMS-NEXMODES)*DLOG(4.184D26)
               ENDIF

               IF(PATHT) TSDISP=TSDISPSAVE
               WRITE(9123,'(3G20.10)') ENERGY,PROD,ABS(TSDISP)
               DO I1=1,NORDER
                  PRINT '(A,I6,A,2G20.10)',' GEOPT> ORDER PARAMETER ',I1,' AND DERIVATIVE TERM: ',ORDER(I1),ORDERDERIV(I1)
                  WRITE(9123,'(2G20.10)') ORDER(I1),ORDERDERIV(I1)
               ENDDO
               DEALLOCATE(ORDER,ORDERDERIV)
               IDONE=IDONE+1
               IF ((NEXMODES.EQ.7).AND.(IDONE.LT.1000)) THEN
                  IF (PATHT) THEN
                     READ(9124,*,END=444) 
                     READ(9124,*,END=444) 
                     DO J2=1,NATOMS
                        READ(9124,*,END=444) ADUMMY,Q(3*(J2-1)+1),Q(3*(J2-1)+2),Q(3*(J2-1)+3)
                     ENDDO
                     CALL MINPERMDIST(Q,QSAVE,NATOMS,DEBUG,PARAM1,PARAM2,PARAM3,BULKT,TWOD,DIST,DIST2,RIGIDBODY,RMAT)
                     DUMMY=0.D0
                     DO J2=1,NATOMS
                        DUMMY=DUMMY+ATMASS(J2)*( (Q(3*(J2-1)+1)-QSAVE(3*(J2-1)+1))**2 
     &                                          +(Q(3*(J2-1)+2)-QSAVE(3*(J2-1)+2))**2
     &                                          +(Q(3*(J2-1)+3)-QSAVE(3*(J2-1)+3))**2 )
C                        DUMMY=DUMMY+( (Q(3*(J2-1)+1)-QSAVE(3*(J2-1)+1))**2
C     &                                          +(Q(3*(J2-1)+2)-QSAVE(3*(J2-1)+2))**2
C     &                                          +(Q(3*(J2-1)+3)-QSAVE(3*(J2-1)+3))**2 )
                     ENDDO
                     TSDISP=SQRT(DUMMY)
                     WRITE(9125,'(A,I5,F10.2)') 'IDONE, DIST: ',IDONE,DIST
                     DO J2=1,NATOMS
                        WRITE(9125,'(3F10.2,A,3F10.2)') Q(3*(J2-1)+1),Q(3*(J2-1)+2),Q(3*(J2-1)+3),'   ',
     &                  QSAVE(3*(J2-1)+1),QSAVE(3*(J2-1)+2),QSAVE(3*(J2-1)+3)
                     ENDDO
                     WRITE(9125,*)'TSDISP= ',TSDISP
                     WRITE(9125,*)
C                     PRINT *,'TSDISP= ',TSDISP
                  ELSE
                     TSDISP=1.0D-1*((IDONE+1)/2)
                     IF (MOD(IDONE,2).EQ.0) TSDISP=-TSDISP
                     DO J2=1,NATOMS
                        Q(3*(J2-1)+1)=QSAVE(3*(J2-1)+1)+TSDISP*VECS(3*(J2-1)+1)/SQRT(ATMASS(J2))
                        Q(3*(J2-1)+2)=QSAVE(3*(J2-1)+2)+TSDISP*VECS(3*(J2-1)+2)/SQRT(ATMASS(J2))
                        Q(3*(J2-1)+3)=QSAVE(3*(J2-1)+3)+TSDISP*VECS(3*(J2-1)+3)/SQRT(ATMASS(J2))
                     ENDDO
                  ENDIF
                  PRINT '(A,G20.10)',' GEOPT> DISPLACING TS GEOMETRY ALONG REACTION COORDINATE BY ',TSDISP
                  IF (ENDNUMHESS) THEN 
C CALL TO POTENTIAL TO GET THE NERGY, THEN NUMERICAL HESSIAN
                     CALL POTENTIAL(Q,ENERGY,VNEW,.TRUE.,.FALSE.,RMS,.FALSE.,.FALSE.)
                     WRITE (*,'(A)') ' GEOPT> CALCULATING FROM NUMERICAL HESSIAN'
                     IF (UNRST) THEN 
                        CALL MAKENUMINTHESS(NINTS,NATOMS)
                        CALL GETSTUFF(KD,NNZ,NINTB)
                        CALL INTSECDET(Q,3*NATOMS,KD,NNZ,NINTB,EVALUES)
                     ELSEIF (RINGPOLYMERT) THEN
                        CALL MAKENUMHESSRP(Q,NOPT)
                        WRITE (*,'(A)') ' GEOPT> VALUE BELOW CALCULATED FROM NUMERICAL HESSIAN'
                     ELSE
                        CALL MAKENUMHESS(Q,NATOMS)
                     ENDIF
                  ELSE
                     CALL POTENTIAL(Q,ENERGY,VNEW,.TRUE.,.TRUE.,RMS,.FALSE.,.FALSE.)
                     WRITE (*,'(A,2G20.10,A,G20.10)') ' GEOPT> CALCULATING ANALYTICAL HESSIAN, ENERGY AND RMS=',ENERGY,RMS,
     &                                       ' ENERGY CHANGE=',ENERGY-ESAVE
                  ENDIF
                  IF (CHRMMT) THEN
                     CALL MASSWT2(NATOMS,ATMASS,Q,VNEW,.TRUE.)  ! JUST DOES THE HESSIAN
                  ELSEIF (RINGPOLYMERT) THEN
                     PRINT '(A)','GEOPT> ERROR *** RING POLYMER INCOMAPTIBLE WITH ORDER PARAMETERS'
                     STOP
                  ELSE
                     CALL MASSWT(NATOMS,ATMASS,Q,VNEW,.TRUE.)   ! HESSIAN, COORDINATES AND GRADIENT VECTOR
                  ENDIF
                  PROJGRAD=.TRUE.
                  IF (RMS.LT.CONVR) PROJGRAD=.FALSE.
                  CALL PROJH(Q,NATOMS,ATMASS,VNEW,PROJGRAD)
                  IF (PATHT) THEN
                     GOTO 333
                  ELSE
                     IF (ENERGY-ESAVE.LT.0.0D0) THEN
                        GOTO 333
                     ELSE
                        GOTO 444
                     ENDIF
                  ENDIF
               ENDIF
444            CONTINUE
               CLOSE(UNIT=9123)
               CLOSE(UNIT=9124)
               ENERGY=ESAVE
               EVALUES(1:3*NATOMS)=EVSAVE(1:3*NATOMS)
            ELSE
               IF (DUMPV) THEN ! USE JOB TYPE 'V' TO GET EIGENVECTORS
                  CALL DSYEV('V','U',NOPT,HESS,NOPT,EVALUES,TEMPA,9*NATOMS,INFO)
               ELSE 
                  IF (NENDHESS.GE.3*NATOMS) THEN
C                    CALL DSYEV('N','U',NOPT,HESS,NOPT,EVALUES,TEMPA,9*NATOMS,INFO)
C  CSW34> CHANGED THE CALL USED HERE TO BE THE SAME AS IF NENDHESS < NOPT BELOW
C         AS THIS LEADS TO A 20% SPEED INCREASE!
                     ABSTOL=DLAMCH('SAFE  MINIMUM')
                     ALLOCATE(ZWK(1,1)) ! NOT REFERENCED FOR JOB TYPE 'N'
                     CALL DSYEVR('N','I','U',NOPT,HESS,NOPT,0.0D0,1.0D0,1,NOPT,ABSTOL,
     &                           NFOUND,EVALUES,ZWK,NOPT,ISUPPZ,WORK,LWORK,IWORK,ILWORK,INFO )
                     DEALLOCATE(ZWK)
                  ELSE
                     ABSTOL=DLAMCH('SAFE  MINIMUM')
                     ALLOCATE(ZWK(1,1)) ! NOT REFERENCED FOR JOB TYPE 'N'
                     CALL DSYEVR('N','I','U',NOPT,HESS,NOPT,0.0D0,1.0D0,1,NENDHESS,ABSTOL,
     &                           NFOUND,EVALUES,ZWK,NOPT,ISUPPZ,WORK,LWORK,IWORK,ILWORK,INFO )
                     DEALLOCATE(ZWK)
                  ENDIF
               ENDIF
            ENDIF
C
C  MASSWT2 AND MASSWTRP DO NOT MASS WEIGHT Q AND VNEW, BUT MASSWT DOES. NEED TO UNDO THIS
C  IF DUMPDATAT IS .TRUE. FOR COMPARISON WITH PATHSAMPLE (WHICH USES UNIT MASSES).
C  PROBABLY BEST TO ALWAYS UNDO IT, IN CASE WE NEED NON-MASS-WEIGHTED Q SOMEWHERE
C  FURTHER DOWN.
C
C           IF (DUMPDATAT.AND.(.NOT.(CHRMMT.OR.RINGPOLYMERT))) THEN
            IF (.NOT.CHRMMT) THEN
               DO J1=1,NATOMS
                  AMASS=1/SQRT(ATMASS(J1))
                  J3=3*J1
                  Q(J3-2)=AMASS*Q(J3-2)
                  Q(J3-1)=AMASS*Q(J3-1)
                  Q(J3)=AMASS*Q(J3)
               ENDDO
            ENDIF

            IF (EVALUES(1).LT.EVALUES(NENDHESS)) CALL EIGENSORT_VAL_ASC(EVALUES,HESS,NENDHESS,3*NATOMS)
            IF (INFO.NE.0) PRINT*,'WARNING - INFO=',INFO,' IN DSYEV'
         ENDIF
!
! THE TEST BELOW WILL NOT NECESSARILY SPOT A STATIONARY POINT OF THE WRONG INDEX.
! WE COULD READ A ZERO EIGENVALUE THAT IS > 0 AND NO ERROR MESSAGE WILL RESULT.
!
         IF (DEBUG.OR.AMHT.OR.CASTEP.OR.RINGPOLYMERT.OR.ONETEP) THEN
            PRINT '(A,I6,A)',' GEOPT> ',NENDHESS,' HESSIAN EIGENVALUES:'
            PRINT '(6G20.10)',EVALUES(1:NENDHESS)
            IF (CASTEP.OR.ONETEP) THEN
               PRINT '(A,I6,A)',' GEOPT> ',NENDHESS, 
     &                          ' NORMAL MODE FREQUENCIES IN HZ AND WAVENUMBERS, ASSUMING EV AND ANGSTROM UNITS FOR INPUT:'
               IF (ONETEP) THEN
                  PRINT '(A,I6,A)',' GEOPT> ',NENDHESS, 
     &             ' NORMAL MODE FREQUENCIES IN HZ AND WAVENUMBERS, ASSUMING HARTREE AND BOHR UNITS FOR INPUT:'
                  DO J1=1,NENDHESS
                     IF (EVALUES(J1).GT.0.0D0) THEN
                        PRINT '(I6,2G20.10)',J1,SQRT(EVALUES(J1)*9.3757D29)/(2*3.141592654D0), 
     &                                         SQRT(EVALUES(J1)*9.3757D29)/(2*3.141592654D0*2.998D10)
                     ELSE
                        PRINT '(I6,2(G20.10,A2))',J1,SQRT(-EVALUES(J1)*9.3757D29)/(2*3.141592654D0),' I',
     &                                      SQRT(-EVALUES(J1)*9.3757D29)/(2*3.141592654D0*2.998D10),' I'
                        ENDIF
                  ENDDO
               ELSE
                  PRINT '(A,I6,A)',' GEOPT> ',NENDHESS, 
     &             ' NORMAL MODE FREQUENCIES IN HZ AND WAVENUMBERS, ASSUMING EV AND ANGSTROM UNITS FOR INPUT:'
                  DO J1=1,NENDHESS
                     IF (EVALUES(J1).GT.0.0D0) THEN
                        PRINT '(I6,2G20.10)',J1,SQRT(EVALUES(J1)*9.75586D27)/(2*3.141592654D0), 
     &                                         SQRT(EVALUES(J1)*9.75586D27)/(2*3.141592654D0*2.998D10)
                     ELSE
                        PRINT '(I6,2(G20.10,A2))',J1,SQRT(-EVALUES(J1)*9.75586D27)/(2*3.141592654D0),' I',
     &                                      SQRT(-EVALUES(J1)*9.75586D27)/(2*3.141592654D0*2.998D10),' I'
                        ENDIF
                  ENDDO
               ENDIF
C
C  ADDED TRANSFORMATION BACK TO CARTESIAN BASIS FOR HESSIAN EIGENVECTORS,
C  AS IN "ENERGY LANDSCAPES" EQUATION (2.51). OTHERWISE THE EIGENVECTOR
C  COMPONENTS REFER TO MASS-WEIGHTED COORDINATES, NOT CARTESIANS. DJW 7/11/09
C  THE EIGENVECTORS OF THE MASS-WEIGHTED HESSIAN CORRESPOND TO THE A MATRIX
C  COMPONENTS A_{ALPHA GAMMA} FOR EIGENVECTOR GAMMA, AND THESE VECTORS
C  ARE ORTHONORMAL.
C  SECOND INDEX OF HESS LABELS THE EIGENVECTOR, FIRST INDEX RUNS OVER COMPONENTS.
C  THE TRANSFORMED EIGENVECTORS IN THE CARTESIAN BASIS ARE NOT ORTHOGONAL.
C
C  THE RELATIVE CARTESIAN DISPLACEMENTS FOR MASS-WEIGHTED HESSIAN EIGENVECTOR
C  GAMMA ARE A_(ALPHA GAMMA}/SQRT(M_ALPHA) WHERE M_ALPHA IS THE MASS OF THE
C  ATOM WITH COMPONENT ALPHA. THESE ARE ALSO THE RELATIVE DISPLACEMENTS FOR
C  ATOMS CORRESPONDING TO MOTION IN MODE GAMMA.
C  TO PUT KE OF K_GAMMA INTO MODE GAMMA CHOOSE THE CARTESIAN VELOCITY 
C  COMPONENTS AS +/- SQRT(2K_GAMMA) A_{ALPHA GAMMA}/SQRT(M_ALPHA).
C
               DO J1=1,NATOMS ! SUM OVER COMPONENTS
                  AMASS=1/SQRT(ATMASS(J1))
                  J3=3*J1
                  DO J2=1,3*NATOMS ! SUM OVER EIGENVECTORS
                     HESS(J3-2,J2)=HESS(J3-2,J2)*AMASS
                     HESS(J3-1,J2)=HESS(J3-1,J2)*AMASS
                     HESS(J3  ,J2)=HESS(J3  ,J2)*AMASS
                  ENDDO
               ENDDO
               PRINT '(A)','GEOPT> NORMALISED EIGENVECTORS OF MASS-WEIGHTED HESSIAN HAVE BEEN TRANSFORMED TO CARTESIAN COMPONENTS'

            ELSEIF (RINGPOLYMERT.AND.PATHT) THEN
C
C  FOR RING POLYMER TS CALCULATE THE QUANTUM INSTANTON IM F RATE CONSTANTS FOR THE FORWARD AND BACKWARD
C  PROCESSES. THE RP HESSIAN SHOULD HAVE BEEN MASS WEIGHTED APPROPRIATELY.
C  ASSUME MASS, LENGTH AND ENERGY IN ATOMIC UNITS, OTHERWISE WE NEED A CONVERSION FACTOR
C  FOR HBAR. PROD ALREADY CONTAINS THE LN PRODUCT OF POSITIVE HESSIAN EIGENVALUES.
C  EACH EIGENVALUE IS AN ANGULAR FREQUENCY SQUARED.
C  WE NEED THE ENERGIES OF THE + AMD - MINIMA AS WELL, SO A PATH CALCULATION IS REQUIRED.
C
               QFAC=LOG(RPIMAGES/RPBETA)
               IF (RPIMAGES.GT.1) THEN
                  DUMMY=0.0D0
                  DO J1=1,RPDOF
                     DUMMY=DUMMY+LOG(RPMASSES(J1))
                  ENDDO
                  DUMMY=DUMMY/RPDOF ! LN OF GEOMETRIC MEAN MASS FOR RPDOF DEGREES OF FREEDOM
                  RPBN=0.0D0
                  DO J2=1,RPDOF ! IMAGES 1 AND RPIMAGES
                     RPBN=RPBN+(Q(J2)-Q(RPDOF*(RPIMAGES-1)+J2))**2
                  ENDDO
                  DO J1=1,RPIMAGES-1 ! IMAGES J1 AND J1+1
                     DO J2=1,RPDOF
                        RPBN=RPBN+(Q(RPDOF*(J1-1)+J2)-Q(RPDOF*J1+J2))**2
                     ENDDO
                  ENDDO
!
!  THIS ISN'T RIGHT - THE FORMULA IN SECTION V HAS RECIPROCAL FACTORS OF G
!  IN THE FREQUENCIES AS WELL. NEED TO CHECK FURTHER.
!
                  QFAC=QFAC+(0.5D0)*DUMMY+0.5D0*LOG(RPBN*RPIMAGES/(6.283185307D0*RPBETA))
     &                              -0.5D0*PROD-(RPIMAGES-2)*LOG(RPBETA/RPIMAGES)
               ELSE
               ENDIF
               PRINT '(2(A,G20.10))',' GEOPT> LN(K_INSTANTON^+ * Q^+)=',QFAC-(ETS-EPLUS)*RPBETA/RPIMAGES,' E+=',EPLUS
               PRINT '(2(A,G20.10))',' GEOPT> LN(K_INSTANTON^- * Q^-)=',QFAC-(ETS-EMINUS)*RPBETA/RPIMAGES,' E-=',EMINUS
            ENDIF
         ENDIF
         LZT(1:NOPT)=.TRUE.
         IF (DUMPV) CALL VDUMP(EVALUES,LZT,NOPT,3*NATOMS)
         PROD=0.0D0
         IF (NENDHESS-NEXMODES.GT.0) THEN
            MINFRQ2=LOG(EVALUES(NENDHESS-NEXMODES))
         ELSE
            MINFRQ2=1.0D0
         ENDIF
         DO I1=1,NENDHESS-NEXMODES
            IF (I1.GT.1) THEN
               IF (EVALUES(I1-1).NE.0.0D0) THEN
                  IF (ABS(EVALUES(I1)/EVALUES(I1-1)).LT.1.0D-2) THEN
                     PRINT '(A,G20.10,A,G20.10)',' GEOPT> WARNING - DECREASE IN MAGNITUDE OF EIGENVALUES FROM ',EVALUES(I1-1),
     &                                    ' TO ',EVALUES(I1)
                     PRINT '(A)',' GEOPT> WARNING - THIS COULD INDICATE A STATIONARY POINT OF THE WRONG INDEX'
                  ENDIF
               ENDIF
            ENDIF
            IF (EVALUES(I1).GT.0.0D0) THEN
               PROD=PROD+DLOG(EVALUES(I1))
            ELSE
               IF (I1.LT.(NENDHESS-NEXMODES)) PRINT *,'HIGHER ORDER SADDLE DETECTED: EIGENVALUE ',EVALUES(I1)
               ! JMC PUT IN THIS TEST MAINLY FOR PATHSAMPLE PURPOSES...
            ENDIF 
         ENDDO

         IF (CHRMMT.OR.AMBERT.OR.NABT.OR.SDT) THEN
C
C IF CHARMM NEED TO CONVERT THIS TO (RADIAN/S)^2, RATHER THAN CHARMM UNITS
C CONVERSION FACTOR FOR THIS IS 4.184 X 10^26
C SAME FOR AMBER
C
            PROD=PROD+(3*NATOMS-NEXMODES)*DLOG(4.184D26)
            MINFRQ2=MINFRQ2+LOG(4.184D26)
            WRITE (*,'(A,G20.10)') ' GEOPT> LN PRODUCT SCALED TO SI UNITS (RADIAN/S)^2 BY ',(3*NATOMS-NEXMODES)*DLOG(4.184D26)
            IF (SDT) THEN
               PRINT '(A,I6,A)',' GEOPT> ',NENDHESS,
     &                          ' NORMAL MODE FREQUENCIES IN HZ AND WAVENUMBERS'
               DO J1=1,NENDHESS
                  IF (EVALUES(J1).GT.0.0D0) THEN
                     PRINT '(I6,2G20.10)',J1,SQRT(EVALUES(J1)*4.184D26)/(2*3.141592654D0),
     &                                      SQRT(EVALUES(J1)*4.184D26)/(2*3.141592654D0*2.998D10)
                  ELSE
                     PRINT '(I6,2(G20.10,A2))',J1,SQRT(-EVALUES(J1)*4.184D26)/(2*3.141592654D0),' I',
     &                                      SQRT(-EVALUES(J1)*4.184D26)/(2*3.141592654D0*2.998D10),' I'
                  ENDIF
               ENDDO
            ENDIF
         ENDIF

        IF (NENDHESS-NEXMODES.GT.0) WRITE(*,'(A,I8,A,F20.10)') ' GEOPT> LOG PRODUCT OF ',NENDHESS-NEXMODES,
     &                             ' POSITIVE HESSIAN EIGENVALUES=',PROD
      ENDIF

      IF (CHRMMT.AND.CALCDIHE) THEN
         STOP 'NECESSARY CHARMM ROUTINES NOT IMPLEMENTED YET FOR NSEG>1'
C         LSELECT=.FALSE.
C         CALL CHCALCRGYR(RGYR,Q,LSELECT)
C         LNATIVE=.FALSE.
C         CALL CHCALCNUMHB(NUMHB,Q,LNATIVE)
C         CALL CHCALCRMSD(RMSD,Q)
C         WRITE(*,'(A,4X,F20.10)') 'FINAL RMSD FROM REFERENCE STRUCTURE=',RMSD
C         WRITE(*,'(A,4X,F20.10)') 'FINAL RADIUS OF GYRATION=',RGYR
C         IF (LNATIVE) THEN
C            WRITE(*,'(A,4X,I6)') 'FINAL NUMBER OF NATIVE HYDROGEN BONDS=',NUMHB
C         ELSE
C            WRITE(*,'(A,4X,I6)') 'FINAL NUMBER OF CROSS-CHAIN HYDROGEN BONDS=',NUMHB
C         ENDIF
      ELSEIF (UNRST.AND.CALCDIHE) THEN
         CALL UNRESCALCDIHEREF(DIHE,ALLANG,Q)
         CALL UNRESCALCRGYR(RGYR,Q)
         WRITE(*,'(A,4X,F20.10)') ' DIHEDRAL ANGLE ORDER PARAMETER=',DIHE
         WRITE(*,'(A,4X,F20.10)') ' ALL ANGLE ORDER PARAMETER=',ALLANG
         WRITE(*,'(A,4X,F20.10)') ' RADIUS OF GYRATION=',RGYR
      ENDIF

      INERTIAT=.TRUE.
C     IF ((UNRST.OR.CHRMMT).AND.INERTIAT) THEN
      IF ((DUMPDATAT).AND.INERTIAT) THEN
         DO I1=1,3*NATOMS
            DUMQ(I1)=Q(I1)
         ENDDO
C
C  PATHSAMPLE USES UNIT MASSES, SO WE NEED TO CHANGE TO UNIT MASS TEMPORARILY HERE,
C  AND THEN PUT THE RIGHT VALUES BACK, OTHERWISE THE FREQUENCIES WILL BE WRONG
C  WHEN WE CALL GEOPT AGAIN FROM NEWCONNECT IN A BHINTERP RUN!!!!
C
         DO J1=1,NATOMS
            ATMASSSAVE(J1)=ATMASS(J1)
            ATMASS(J1)=1.0D0 
         ENDDO

         CALL INERTIA2(DUMQ,ITX,ITY,ITZ)
         WRITE(*,'(A,4X,F20.10)') ' GEOPT> X COMPONENT OF INERTIA TENSOR=',ITX
         WRITE(*,'(A,4X,F20.10)') ' GEOPT> Y COMPONENT OF INERTIA TENSOR=',ITY
         WRITE(*,'(A,4X,F20.10)') ' GEOPT> Z COMPONENT OF INERTIA TENSOR=',ITZ
         HORDER=1
         DO J1=1,NATOMS
            ATMASS(J1)=ATMASSSAVE(J1)
         ENDDO
      ENDIF

C     IF (AMBER) THEN
C        CALL AMBERDUMP(Q,FNAMEF)
C     ELSE
      IF (CHRMMT) THEN
         CALL CHARMMDUMP(Q,FNAMEF,MACHINE)
      ELSE IF (UNRST) THEN
C
C JMC MYUNRESDUMP JUST OUTPUTS CALPHA AND SIDE CHAIN COORDS IN PLAIN XYZ FORMAT, SO THEY CAN BE
C READ IN AGAIN IN A FILTHY RUN, WHEREAS UNRESDUMP3 ADDS DUMMY O AND N ATOMS FOR VISUALIZATION PURPOSES.
C
         CALL MYUNRESDUMP(Q,FNAMEF)
         CALL UNRESDUMP3(Q,'UNR.'//TRIM(ADJUSTL(FNAMEF)))
      ELSE
!
! CALL SYMMETRY BEFORE DUMPING THE FILE, OTHERWISE THE WRONG POINT GROUP IS REPORTED IN ODATA.NEW AND PICKED UP BY FILTHY_PHYLLIS
!
         IF (.NOT.(VARIABLES.OR.RINGPOLYMERT)) CALL SYMMETRY(HORDER,.TRUE.,Q,IT)
         IF (MACHINE) THEN
             CALL WRITEOUTFILE(Q,FNAMEF)
         ELSE
             CALL DUMPIT(Q,FNAMEF)
         ENDIF
      ENDIF
11    CONTINUE
      IF ((BHINTERPT.OR.BISECTT).AND.(.NOT.NEWCONNECTT).AND.(.NOT.REOPTIMISEENDPOINTS)) THEN ! DO NOTHING
      ELSE IF (MFLAG) THEN
! CSW34> MASS WEIGHTED NORMAL MODE DUMPING 
         IF (ENDHESS .AND. (.NOT. (REOPTIMISEENDPOINTS.AND.(BHINTERPT.OR.BISECTT)))) THEN
! IN THIS CASE WE HAVE ALREADY CALLED VDUMP. WE DON;T WANT TO DO IT AGAIN!
         ELSEIF (DUMPV.AND.ALLVECTORS) THEN
                DO J1=1,3*NATOMS
                   ZT(J1)=.TRUE.
                ENDDO
! SET THE FIRST SIX NORMAL MODES TO NOT BE PRINTED. FOR A NON-LINEAR
! MOLECULE, THESE CORRESPOND TO THE PURE ROTATIONS AND TRANSLATIONS
                DO J1=1,MIN(6,NOPT)
                   ZT(J1)=.FALSE.
                ENDDO
                                                               
! CAN'T MASS WEIGHT AN ALREADY DIAGONALISED HESSIAN SO CALL POTENTIAL AGAIN
                CALL POTENTIAL(Q,ENERGY,VNEW,.TRUE.,.TRUE.,RMS,.FALSE.,.FALSE.)
! MASS WEIGHT HESSIAN - USING MASSWT WOULD ALSO CHANGE THE COORDINATES
                IF (MWVECTORS) THEN
                   IF (RINGPOLYMERT) THEN
                      CALL MASSWTRP(NOPT,RPMASSES,RPDOF)
                   ELSE
                      CALL MASSWT2(NATOMS,ATMASS,Q,VNEW,.TRUE.)
                   ENDIF
                ENDIF
! DIAGONALISE
                CALL DSYEV('V','U',NOPT,HESS,SIZE(HESS,1),DIAG,TEMPA,9*NATOMS,INFO)
! IF WE'RE FREEZING ATOMS, SOME ZERO EIGANVALUE MODES CAN CREEP IN THAT
! ARE NOT REAL I.E. ONE ATOMS MOVING AND ALL OTHERS STATIONARY. HERE, WE
! CHECK AND REMOVE THESE USING ZT
                IF (FREEZE) THEN
                   DO J1=1,3*NATOMS
                      IF (ABS(DIAG(J1)).LT.0.000001) ZT(J1)=.FALSE.
                   ENDDO
                ENDIF
! DUMP VECTORS
                CALL VDUMP(DIAG,ZT,NOPT,3*NATOMS)
! IF USING CHARMM, CALL THE CHARMMDUMPMODES SUBROUTINE TO OUTPUT A PDB
! CONTAINING ONE FRAME PER MODE AND SCALED ATOMIC AND RESIDUE
! DISPLACEMENTS - COORDS ARE IN Q HERE!
                IF (CHRMMT.AND.MWVECTORS) CALL CHARMMDUMPMODES(Q,DIAG,ZT,NOPT,3*NATOMS)
! AMBER CALL TO ROUTINE IN AMBERINTERFACE.F
                IF ((AMBERT.OR.NABT).AND.MWVECTORS) THEN
                        CALL A9DUMPMODES(DIAG,ZT,NOPT,3*NATOMS)
                ENDIF
         ENDIF

         PRINT*
         WRITE(*,'(A)') ' GEOPT>                          **** CONVERGED ****'
         PRINT*
         CALL FLUSH(6,ISTAT)
!
! PRINT TIP FREQUENCIES IN CM-1 FOR COM/EULER ANGLE REPRESENTATION FOR DEBUGGING ANGLE-AXIS.
!
         IF (DEBUG.AND.(ZSYM(1)(1:1).EQ.'W')) THEN
            IF (ZSYM(1)(1:2).EQ.'W4') IPOT=4
            IF (ZSYM(1)(1:2).EQ.'W3') IPOT=3
            IF (ZSYM(1)(1:2).EQ.'W2') IPOT=2
            IF (ZSYM(1)(1:2).EQ.'W1') IPOT=1
            CALL H2OMODES(NATOMS/2,IPOT,Q,DIAG)
            PRINT '(A,I6,A)',' GEOPT> TIP NORMAL MODE FREQUENCIES IN WAVENUMBERS'
            DO J1=1,3*NATOMS
               IF (DIAG(J1).GT.0.0D0) THEN
                  PRINT '(I6,2G20.10)',J1,DIAG(J1)
               ELSE
                  PRINT '(I6,2(G20.10,A2))',J1,-DIAG(J1),' I'
               ENDIF
            ENDDO
         ENDIF
      ELSE 
         IF (GRADSQ) WRITE(*,'(A,4F20.10)') ' G^2, RMS FORCE AND REAL ENERGY AND RMS=',ENERGY,RMS2,EREAL,RMS
         PRINT*
         IF (BFGSMINT.OR.(BFGSTST.AND.(HINDEX.EQ.0))) THEN
              PRINT*,ITDONE,' STEPS COMPLETED WITHOUT CONVERGENCE TO REQUIRED TOLERANCE'
         ELSE
              PRINT*,NSTEPS,' STEPS COMPLETED WITHOUT CONVERGENCE TO REQUIRED TOLERANCE'
         ENDIF
         PRINT*
         CALL FLUSH(6,ISTAT)
         STOP
      ENDIF
      CALL FLUSH(6,ISTAT)
      IF (DUMPDATAT) THEN 
         IF (MFLAG) THEN
!
! MIN.DATA.INFO FILE IS NOW OPENED ON UNIT 881 IN KEYWORD.F
!
!           OPEN(UNIT=100,FILE='MIN.DATA.INFO',STATUS='UNKNOWN')
            IF (BHINTERPT.AND.(.NOT.REOPTIMISEENDPOINTS)) ENERGY=BHENERGY
            IF (BISECTT.AND.(.NOT.REOPTIMISEENDPOINTS)) ENERGY=BISECTENERGY
            IF (LOWESTFRQT) THEN
               IF (CHRMMT.OR.UNRST.OR.AMBERT.OR.NABT) THEN
                  WRITE(881,'(2F20.10,I6,5F20.10)') ENERGY,PROD,HORDER,ITX,ITY,ITZ,MINCURVE,MINFRQ2
               ELSE
                  CALL INERTIA2(Q,ITX,ITY,ITZ)
                  WRITE(881,'(2F20.10,I6,5F20.10)') ENERGY,PROD,HORDER,ITX,ITY,ITZ,MINCURVE,MINFRQ2
               ENDIF
            ELSE   
               IF (CHRMMT.OR.UNRST.OR.AMBERT.OR.NABT) THEN 
                  WRITE(881,'(2F20.10,I6,4F20.10)') ENERGY,PROD,HORDER,ITX,ITY,ITZ
               ELSE
                  CALL INERTIA2(Q,ITX,ITY,ITZ)
                  WRITE(881,'(2F20.10,I6,4F20.10)') ENERGY,PROD,HORDER,ITX,ITY,ITZ
               ENDIF
            ENDIF
         
            NRES=NMRES

          IF (AMHT) THEN
            GLY_COUNT = 0
            SDUMMY='AM'
            DO J2=1,NRES
              IF (SEQ(J2).EQ.8) THEN
76                FORMAT(A2,3(F20.10))
          WRITE(881,*)Q(9*(J2-1)+1-GLY_COUNT*3),Q(9*(J2-1)+2-GLY_COUNT*3),Q(9*(J2-1)+3-GLY_COUNT*3)
          WRITE(881,*)Q(9*(J2-1)+1-GLY_COUNT*3),Q(9*(J2-1)+2-GLY_COUNT*3),Q(9*(J2-1)+3-GLY_COUNT*3)
          WRITE(881,*)Q(9*(J2-1)+4-GLY_COUNT*3),Q(9*(J2-1)+5-GLY_COUNT*3),Q(9*(J2-1)+6-GLY_COUNT*3)
                GLY_COUNT = GLY_COUNT +1
              ELSE
          WRITE(881,*)Q(9*(J2-1)+1-GLY_COUNT*3),Q(9*(J2-1)+2-GLY_COUNT*3),Q(9*(J2-1)+3-GLY_COUNT*3)
          WRITE(881,*)Q(9*(J2-1)+4-GLY_COUNT*3),Q(9*(J2-1)+5-GLY_COUNT*3),Q(9*(J2-1)+6-GLY_COUNT*3)
          WRITE(881,*)Q(9*(J2-1)+7-GLY_COUNT*3),Q(9*(J2-1)+8-GLY_COUNT*3),Q(9*(J2-1)+9-GLY_COUNT*3)
              ENDIF

            ENDDO
            CALL FLUSH(881,ISTAT)
            ELSE
            WRITE(881,'(3F25.15)') Q(1:3*NATOMS)
            CALL FLUSH(881,ISTAT)
            ENDIF
         ELSE
            PRINT '(A)',' GEOPT> WARNING - DUMPDATA IS SET, BUT MFLAG IS FALSE; NOT CREATING ENTRY IN MIN.DATA.INFO'
         ENDIF
      ENDIF

      RETURN

      END

      SUBROUTINE MASSWT(NATOMS,ATMASS,Q,VNEW,STEST)
      USE MODHESS
      IMPLICIT NONE
      INTEGER NATOMS, J1, J2, J3, J4
      LOGICAL STEST
      DOUBLE PRECISION ATMASS(NATOMS),Q(3*NATOMS),VNEW(3*NATOMS),AMASS,BMASS,PMASS

      IF (.NOT.ALLOCATED(HESS)) THEN
         PRINT '(A)','MASSWT2> ERROR - HESS HAS NOT BEEN ALLOCATED. DO YOU NEED NOFRQS, ENDHESS, OR ENDNUMHESS IN ODATA?'
         STOP
      ENDIF
      DO J1=1,NATOMS
!        PRINT *,'J1,ATMASS=',J1,ATMASS(J1)
         AMASS=1.0D0/SQRT(ATMASS(J1))
         BMASS=SQRT(ATMASS(J1))
         J3=3*J1
         Q(J3-2)=BMASS*Q(J3-2)
         Q(J3-1)=BMASS*Q(J3-1)
         Q(J3)=BMASS*Q(J3)
         VNEW(J3-2)=VNEW(J3-2)*AMASS
         VNEW(J3-1)=VNEW(J3-1)*AMASS
         VNEW(J3)=VNEW(J3)*AMASS
         IF (STEST) THEN
            DO J2=J1,NATOMS
               BMASS=1.0D0/SQRT(ATMASS(J2))
               PMASS=AMASS*BMASS
               J4=3*J2
               IF (J1.EQ.J2) THEN
                  HESS(J3-2,J4-2)=PMASS*HESS(J3-2,J4-2)
                  HESS(J3-2,J4-1)=PMASS*HESS(J3-2,J4-1)
                  HESS(J3-2,J4)  =PMASS*HESS(J3-2,J4)
                  HESS(J3-1,J4-2)=PMASS*HESS(J3-1,J4-2)
                  HESS(J3-1,J4-1)=PMASS*HESS(J3-1,J4-1)
                  HESS(J3-1,J4)  =PMASS*HESS(J3-1,J4)
                  HESS(J3,  J4-2)=PMASS*HESS(J3,  J4-2)
                  HESS(J3,  J4-1)=PMASS*HESS(J3,  J4-1)
                  HESS(J3,  J4)  =PMASS*HESS(J3,  J4)
               ELSE
                  HESS(J3-2,J4-2)=PMASS*HESS(J3-2,J4-2)
                  HESS(J4-2,J3-2)=HESS(J3-2,J4-2)
                  HESS(J3-2,J4-1)=PMASS*HESS(J3-2,J4-1)
                  HESS(J4-1,J3-2)=HESS(J3-2,J4-1)
                  HESS(J3-2,J4)=PMASS*HESS(J3-2,J4)
                  HESS(J4,J3-2)=HESS(J3-2,J4)
                  HESS(J3-1,J4-2)=PMASS*HESS(J3-1,J4-2)
                  HESS(J4-2,J3-1)=HESS(J3-1,J4-2)
                  HESS(J3-1,J4-1)=PMASS*HESS(J3-1,J4-1)
                  HESS(J4-1,J3-1)=HESS(J3-1,J4-1)
                  HESS(J3-1,J4)=PMASS*HESS(J3-1,J4)
                  HESS(J4,J3-1)=HESS(J3-1,J4)
                  HESS(J3,J4-2)=PMASS*HESS(J3,J4-2)
                  HESS(J4-2,J3)=HESS(J3,  J4-2)
                  HESS(J3,J4-1)=PMASS*HESS(J3,J4-1)
                  HESS(J4-1,J3)=HESS(J3,  J4-1)
                  HESS(J3,J4)=PMASS*HESS(J3,J4)
                  HESS(J4,J3)=HESS(J3,J4)
               ENDIF
            ENDDO
         ENDIF
      ENDDO

      RETURN
      END

      SUBROUTINE MASSWT2(NATOMS,ATMASS,Q,VNEW,STEST)
      USE MODHESS
      IMPLICIT NONE
      INTEGER NATOMS, J1, J2, J3, J4
      LOGICAL STEST
      DOUBLE PRECISION ATMASS(NATOMS),Q(3*NATOMS),VNEW(3*NATOMS),AMASS,BMASS,PMASS

      IF (.NOT.ALLOCATED(HESS)) THEN
         PRINT '(A)','MASSWT2> ERROR - HESS HAS NOT BEEN ALLOCATED. DO YOU NEED NOFRQS, ENDHESS, OR ENDNUMHESS IN ODATA?'
         STOP
      ENDIF
      DO J1=1,NATOMS
         AMASS=1/SQRT(ATMASS(J1))
         BMASS=SQRT(ATMASS(J1))
         J3=3*J1
C DAE DON'T MASS WEIGHT THE COORDINATES OR GRADIENTS
         IF (STEST) THEN
            DO J2=J1,NATOMS
               BMASS=1/SQRT(ATMASS(J2))
               PMASS=AMASS*BMASS
               J4=3*J2
               IF (J1.EQ.J2) THEN
                  HESS(J3-2,J4-2)=PMASS*HESS(J3-2,J4-2)
                  HESS(J3-2,J4-1)=PMASS*HESS(J3-2,J4-1)
                  HESS(J3-2,J4)  =PMASS*HESS(J3-2,J4)
                  HESS(J3-1,J4-2)=PMASS*HESS(J3-1,J4-2)
                  HESS(J3-1,J4-1)=PMASS*HESS(J3-1,J4-1)
                  HESS(J3-1,J4)  =PMASS*HESS(J3-1,J4)
                  HESS(J3,  J4-2)=PMASS*HESS(J3,  J4-2)
                  HESS(J3,  J4-1)=PMASS*HESS(J3,  J4-1)
                  HESS(J3,  J4)  =PMASS*HESS(J3,  J4)
               ELSE
                  HESS(J3-2,J4-2)=PMASS*HESS(J3-2,J4-2)
                  HESS(J4-2,J3-2)=HESS(J3-2,J4-2)
                  HESS(J3-2,J4-1)=PMASS*HESS(J3-2,J4-1)
                  HESS(J4-1,J3-2)=HESS(J3-2,J4-1)
                  HESS(J3-2,J4)=PMASS*HESS(J3-2,J4)
                  HESS(J4,J3-2)=HESS(J3-2,J4)
                  HESS(J3-1,J4-2)=PMASS*HESS(J3-1,J4-2)
                  HESS(J4-2,J3-1)=HESS(J3-1,J4-2)
                  HESS(J3-1,J4-1)=PMASS*HESS(J3-1,J4-1)
                  HESS(J4-1,J3-1)=HESS(J3-1,J4-1)
                  HESS(J3-1,J4)=PMASS*HESS(J3-1,J4)
                  HESS(J4,J3-1)=HESS(J3-1,J4)
                  HESS(J3,J4-2)=PMASS*HESS(J3,J4-2)
                  HESS(J4-2,J3)=HESS(J3,  J4-2)
                  HESS(J3,J4-1)=PMASS*HESS(J3,J4-1)
                  HESS(J4-1,J3)=HESS(J3,  J4-1)
                  HESS(J3,J4)=PMASS*HESS(J3,J4)
                  HESS(J4,J3)=HESS(J3,J4)
               ENDIF
            ENDDO
         ENDIF
      ENDDO

      RETURN
      END

      SUBROUTINE MASSWTRP(NOPT,RPMASSES,RPDOF) ! MASS-WEIGHT UPPER-TRIANGULAR PART OF HESS
      USE MODHESS
      IMPLICIT NONE
      INTEGER J1, J2, RPDOF, NOPT, MINDEX
      DOUBLE PRECISION RPMASSES(RPDOF),AMASS,BMASS,PMASS

      IF (.NOT.ALLOCATED(HESS)) THEN
         PRINT '(A)','MASSWT2> ERROR - HESS HAS NOT BEEN ALLOCATED. DO YOU NEED NOFRQS, ENDHESS, OR ENDNUMHESS IN ODATA?'
         STOP
      ENDIF
      DO J1=1,NOPT
         MINDEX=MOD(J1-1,RPDOF)+1 ! MASSES ARE THE SAME FOR THE RPDOF DEGREES OF FREEDOM IN EACH BEAD
         AMASS=1.0D0/SQRT(RPMASSES(MINDEX))
         DO J2=1,J1
            MINDEX=MOD(J2-1,RPDOF)+1
            BMASS=1/SQRT(RPMASSES(MINDEX))
            PMASS=AMASS*BMASS
            HESS(J2,J1)=PMASS*HESS(J2,J1)
         ENDDO
      ENDDO

      RETURN
      END

      SUBROUTINE MAKENUMHESS(X,NATOMS)
C
C DAE
C
      USE MODHESS
      USE MODCHARMM
      USE KEY,ONLY : DEBUG, FROZEN, CASTEP, AMHT, SDT, ONETEP
      USE PORFUNCS
      IMPLICIT NONE
      LOGICAL KNOWE, KNOWG, KNOWH
      COMMON /KNOWN/ KNOWE, KNOWG, KNOWH

      INTEGER I1,J1,NATOMS,ISTAT
      DOUBLE PRECISION X(3*NATOMS)
      DOUBLE PRECISION DUM(3*NATOMS),GRAD1(3*NATOMS),GRAD2(3*NATOMS),DELTA,RMS,ENERGY

      IF (DEBUG) WRITE(*,'(A)') ' MAKENUMHESS> MAKING NUMERICAL HESSIAN'
      DO I1=1,3*NATOMS
         DUM(I1)=X(I1)
      ENDDO

      DELTA=1.0D-6
      IF (CASTEP) DELTA=0.001D0
      IF (ONETEP) DELTA=0.0001D0
      IF (AMHT) DELTA=1.0D-6
C
      IF(CHRMMT.AND.ACESOLV) NCHENCALLS=ACEUPSTEP-1
 
C
C DAE HAVING TWO POTENTIAL CALLS FOR EACH HESSIAN EVALUATION INCREASES THE ACCURACY
C COMPARED TO THE ANALYTICAL SOLUTION SIGNIFICANTLY (AROUND 4SF), RELATIVE TO THE ALTERNATIVE
C OF EVALUATING THE GRADIENT ONCE AT THE BEGINNING THEN ONCE FOR EACH ELEMENT. BUT OBVIOUSLY IT ALSO
C DOUBLES THE NUMBER OF POTENTIAL EVALUATIONS ((3N)^2/2 FOR N ATOMS), SO MAY BE NOT WORTH IT FOR
C A LONG RUN ON A BIG SYSTEM.
C
      IF (.NOT.ALLOCATED(HESS)) ALLOCATE(HESS(3*NATOMS,3*NATOMS))
      DO I1=1,3*NATOMS
         CALL FLUSH(6,ISTAT)
         IF (FROZEN((I1-1)/3+1)) THEN
            DO J1=I1,3*NATOMS
               HESS(I1,J1)=0.0D0
               HESS(J1,I1)=0.0D0
            ENDDO
         ELSE
            DUM(I1)=X(I1)-DELTA
            CALL POTENTIAL(DUM,ENERGY,GRAD1,.TRUE.,.FALSE.,RMS,.FALSE.,.FALSE.)
            DUM(I1)=X(I1)+DELTA
            CALL POTENTIAL(DUM,ENERGY,GRAD2,.TRUE.,.FALSE.,RMS,.FALSE.,.FALSE.)
            DUM(I1)=X(I1)
            DO J1=I1,3*NATOMS
               HESS(I1,J1)=(GRAD2(J1)-GRAD1(J1))/(2.0D0*DELTA)
               HESS(J1,I1)=HESS(I1,J1)
            ENDDO
         ENDIF
      ENDDO

      IF (DEBUG) WRITE(*,'(A)') ' MAKENUMHESS> HESSIAN MADE'
      KNOWH=.TRUE.
 
      RETURN
      END

      SUBROUTINE MAKENUMHESSRP(X,NOPT)
C
C DAE
C
      USE MODHESS
      USE MODCHARMM
      USE KEY,ONLY : DEBUG, FROZEN, CASTEP, AMHT
      USE PORFUNCS
      IMPLICIT NONE
      LOGICAL KNOWE, KNOWG, KNOWH
      COMMON /KNOWN/ KNOWE, KNOWG, KNOWH

      INTEGER I1,J1,NOPT,ISTAT
      DOUBLE PRECISION X(NOPT)
      DOUBLE PRECISION DUM(NOPT),GRAD1(NOPT),GRAD2(NOPT),DELTA,RMS,ENERGY

      IF (DEBUG) WRITE(*,'(A)') ' MAKENUMHESS> MAKING NUMERICAL HESSIAN'
      DO I1=1,NOPT
         DUM(I1)=X(I1)
      ENDDO

      DELTA=1.0D-5
      IF (.NOT.ALLOCATED(HESS)) ALLOCATE(HESS(NOPT,NOPT))
      DO I1=1,NOPT
         CALL FLUSH(6,ISTAT)
         IF (FROZEN((I1-1)/3+1)) THEN
            DO J1=I1,NOPT
               HESS(I1,J1)=0.0D0
               HESS(J1,I1)=0.0D0
            ENDDO
         ELSE
            DUM(I1)=X(I1)-DELTA
            CALL POTENTIAL(DUM,ENERGY,GRAD1,.TRUE.,.FALSE.,RMS,.FALSE.,.FALSE.)
            DUM(I1)=X(I1)+DELTA
            CALL POTENTIAL(DUM,ENERGY,GRAD2,.TRUE.,.FALSE.,RMS,.FALSE.,.FALSE.)
            DUM(I1)=X(I1)
            DO J1=I1,NOPT
               HESS(I1,J1)=(GRAD2(J1)-GRAD1(J1))/(2.0D0*DELTA)
               HESS(J1,I1)=HESS(I1,J1)
            ENDDO
         ENDIF
      ENDDO

      IF (DEBUG) WRITE(*,'(A)') ' MAKENUMHESS> HESSIAN MADE'
      KNOWH=.TRUE.
 
      RETURN
      END

      SUBROUTINE MAKENUMINTHESS(NOPT,NATOMS)
      USE MODHESS
      USE KEY,ONLY : DEBUG
C
C JMC ASSUMING THAT UNRES INTERNAL COORDINATES HAVE ALREADY BEEN UPDATED.
C THIS SUBROUTINE WILL NOT AFFECT THE STORED INTERNAL OR CARTESIAN COORDINATES.
C
C DAE
C
      IMPLICIT NONE

      INTEGER I1,J1,NATOMS,NOPT
      DOUBLE PRECISION X(NOPT)
      DOUBLE PRECISION DUM2(3*NATOMS),GRAD1(3*NATOMS),GRAD2(3*NATOMS),DELTA,RMS,ENERGY
      DOUBLE PRECISION DUM(NOPT)

      IF (DEBUG) WRITE(*,*) 'MAKING NUMERICAL HESSIAN .=.'
      CALL GEOM_TO_VAR(NOPT,X)

      DUM=X

      DUM2=1.0D0

      DELTA=1.0D-6
C
C DAE HAVING TWO POTENTIAL CALLS FOR EACH HESSIAN EVALUATION INCREASES THE ACCURACY
C COMPARED TO THE ANALYTICAL SOLUTION SIGNIFICANTLY (AROUND 4SF), RELATIVE TO THE ALTERNATIVE
C OF EVALUATING THE GRADIENT ONCE AT THE BEGINNING THEN ONCE FOR EACH ELEMENT. BUT OBVIOUSLY IT ALSO
C DOUBLES THE NUMBER OF POTENTIAL EVALUATIONS ((3N)^2/2 FOR N ATOMS), SO MAY BE NOT WORTH IT FOR
C A LONG RUN ON A BIG SYSTEM.
C
      IF (.NOT.ALLOCATED(HESS)) ALLOCATE(HESS(3*NATOMS,3*NATOMS))
      DO I1=1,NOPT
         DUM(I1)=X(I1)-DELTA
         CALL VAR_TO_GEOM(NOPT,DUM)
         CALL CHAINBUILD
         CALL POTENTIAL(DUM2,ENERGY,GRAD1,.TRUE.,.FALSE.,RMS,.FALSE.,.FALSE.)
         DUM(I1)=X(I1)+DELTA
         CALL VAR_TO_GEOM(NOPT,DUM)
         CALL CHAINBUILD
         CALL POTENTIAL(DUM2,ENERGY,GRAD2,.TRUE.,.FALSE.,RMS,.FALSE.,.FALSE.)
         DUM(I1)=X(I1)
         DO J1=I1,NOPT
            HESS(I1,J1)=(GRAD2(J1)-GRAD1(J1))/(2.0D0*DELTA)
            HESS(J1,I1)=HESS(I1,J1)
         ENDDO
      ENDDO

      CALL VAR_TO_GEOM(NOPT,X)
      CALL CHAINBUILD

      IF (DEBUG) WRITE(*,*) 'HESSIAN MADE'

      RETURN
      END

C ********************************************************************************************
C ********************************************************************************************
C ********************************************************************************************

