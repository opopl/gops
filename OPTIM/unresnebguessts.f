C   OPTIM: A PROGRAM FOR OPTIMIZING GEOMETRIES AND CALCULATING REACTION PATHWAYS
C   COPYRIGHT (C) 1999-2006 DAVID J. WALES
C   THIS FILE IS PART OF OPTIM.
C
C   OPTIM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C   IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C   THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C   (AT YOUR OPTION) ANY LATER VERSION.
C
C   OPTIM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
C   BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
C   GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C   YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C   ALONG WITH THIS PROGRAM; IF NOT, WRITE TO THE FREE SOFTWARE
C   FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330, BOSTON, MA  02111-1307  USA
C
C
C ROUTINE TO GENERATE NEB IMAGES FOR UNRES BY INTERPOLATING
C BETWEEN DIFFERENT INTERNAL COORDINATES 
C CHANGED TO BE CALLED FROM SAT'S NEWNEB -- MAKE FINISH PASSED ARRAY
C
      SUBROUTINE UNRESDIHENEB(Q,FINISH,POINTS)
      USE COMMONS
      USE KEY
C     USE MODNEB
      USE MODUNRES
      USE KEYNEB,ONLY: NIMAGE
      IMPLICIT NONE
C
      DOUBLE PRECISION ANGLE,TWISTFRAC,POINTS(3*NATOMS*NIMAGE),PI
      INTEGER I1,J1,J2,NM
      REAL*8 DUMMY(3*NATOMS),Q(3*NATOMS),FINISH(3*NATOMS),DIFFPP,DIST,FINPPSANGLE(NINTS),QPPSANGLE(NINTS)
      PARAMETER (PI=3.141592653589793D0)

      DO I1=1,NRES
         C(1,I1)=Q(6*(I1-1)+1)
         C(2,I1)=Q(6*(I1-1)+2)
         C(3,I1)=Q(6*(I1-1)+3)
         C(1,I1+NRES)=Q(6*(I1-1)+4)
         C(2,I1+NRES)=Q(6*(I1-1)+5)
         C(3,I1+NRES)=Q(6*(I1-1)+6)
      END DO
      CALL UPDATEDC
      CALL INT_FROM_CART(.TRUE.,.FALSE.)
      CALL GEOM_TO_VAR(NVARU,QPPSANGLE)

      DO I1=1,NRES
         C(1,I1)=FINISH(6*(I1-1)+1)
         C(2,I1)=FINISH(6*(I1-1)+2)
         C(3,I1)=FINISH(6*(I1-1)+3)
         C(1,I1+NRES)=FINISH(6*(I1-1)+4)
         C(2,I1+NRES)=FINISH(6*(I1-1)+5)
         C(3,I1+NRES)=FINISH(6*(I1-1)+6)
      END DO
      CALL UPDATEDC
      CALL INT_FROM_CART(.TRUE.,.FALSE.)
      CALL GEOM_TO_VAR(NVARU,FINPPSANGLE)

C DAE'S COMMENT...NOT RELEVANT FOR UNRES ALL-INTERNAL IMPLEMENTATION.
C WE NEED TO KEEP OUR IMAGES ALONG THE PATH BETWEEN Q AND FIN. THEIR ALIGNMENT WILL
C BE MESSED UP BY REBUILDING. THEREFORE REBUILD STARTING POINT Q (BEFORE ANY DIHES HAVE
C BEEN CHANGED), AND PUT THESE REBUILT COORDINATES IN MAXIMAL ALIGNMENT WITH THE PROPER Q.
C USING MIND. THIS WILL STORE THE ROTATION MATRIX REQUIRED, WHICH WE THEN APPLY TO ALL THE 
C REBUILT IMAGES

      TWISTFRAC=1.D0/(NIMAGE+1)   ! INCREMENTAL, SO TWISTFRAC IS ALWAYS THE SAME

      DO J1=1,NIMAGE

         DO I1=1,NVARU
            DIFFPP = FINPPSANGLE(I1) - QPPSANGLE(I1)
C
C NEXT TWO LINES ARE MEANT TO ENSURE THAT YOU ALWAYS INTERPOLATE
C ALONG THE SHORTEST DISTANCE BETWEEN THE DIHEDRAL ANGLES.
C
            IF (DIFFPP.LT.-PI) DIFFPP = DIFFPP+2.0D0*PI
            IF (DIFFPP.GT.PI) DIFFPP = DIFFPP-2.0D0*PI
            ANGLE=TWISTFRAC*DIFFPP
            QPPSANGLE(I1)=QPPSANGLE(I1)+ANGLE 
         ENDDO
 
         CALL VAR_TO_GEOM(NVARU,QPPSANGLE)
         CALL CHAINBUILD
         DO I1=1,NRES
            DUMMY(6*(I1-1)+1)=C(1,I1)
            DUMMY(6*(I1-1)+2)=C(2,I1)
            DUMMY(6*(I1-1)+3)=C(3,I1)
            DUMMY(6*(I1-1)+4)=C(1,I1+NRES)
            DUMMY(6*(I1-1)+5)=C(2,I1+NRES)
            DUMMY(6*(I1-1)+6)=C(3,I1+NRES)
         ENDDO

         DO I1=1,3*NATOMS
            POINTS(I1+NOPT*(J1-1))=DUMMY(I1)
         END DO
         
      ENDDO

      RETURN
      END

C
C ROUTINE TO CALCULATE DISTANCE IN SPRING FORCE FOR NEB, WHEN USING THE DISTANCE IN DIHEDRAL ANGLE SPACE
C DISTDIHE = |QC - QB| - |QB - QA|
C
      SUBROUTINE UNRESGETDIHEDIST(DIHEDIST,QA,QB,QC)
      USE COMMONS
      USE MODUNRES
      IMPLICIT NONE

      INTEGER I1
      REAL*8 QA(3*NATOMS),QB(3*NATOMS),QC(3*NATOMS)
      REAL*8 DIFFPP,DIHEDIST,DISTCB,DISTBA
      REAL*8 QAPPSANGLE(NINTS),QBPPSANGLE(NINTS),QCPPSANGLE(NINTS)
      DOUBLE PRECISION PI
      PARAMETER (PI=3.141592653589793D0)

      DO I1=1,NRES
         C(1,I1)=QA(6*(I1-1)+1)
         C(2,I1)=QA(6*(I1-1)+2)
         C(3,I1)=QA(6*(I1-1)+3)
         C(1,I1+NRES)=QA(6*(I1-1)+4)
         C(2,I1+NRES)=QA(6*(I1-1)+5)
         C(3,I1+NRES)=QA(6*(I1-1)+6)
      END DO
      CALL UPDATEDC
      CALL INT_FROM_CART(.TRUE.,.FALSE.)
C     CALL CHAINBUILD
      CALL GEOM_TO_VAR(NVARU,QAPPSANGLE)

      DO I1=1,NRES
         C(1,I1)=QB(6*(I1-1)+1)
         C(2,I1)=QB(6*(I1-1)+2)
         C(3,I1)=QB(6*(I1-1)+3)
         C(1,I1+NRES)=QB(6*(I1-1)+4)
         C(2,I1+NRES)=QB(6*(I1-1)+5)
         C(3,I1+NRES)=QB(6*(I1-1)+6)
      END DO
      CALL UPDATEDC
      CALL INT_FROM_CART(.TRUE.,.FALSE.)
C     CALL CHAINBUILD
      CALL GEOM_TO_VAR(NVARU,QBPPSANGLE)

      DO I1=1,NRES
         C(1,I1)=QC(6*(I1-1)+1)
         C(2,I1)=QC(6*(I1-1)+2)
         C(3,I1)=QC(6*(I1-1)+3)
         C(1,I1+NRES)=QC(6*(I1-1)+4)
         C(2,I1+NRES)=QC(6*(I1-1)+5)
         C(3,I1+NRES)=QC(6*(I1-1)+6)
      END DO
      CALL UPDATEDC
      CALL INT_FROM_CART(.TRUE.,.FALSE.)
C     CALL CHAINBUILD
      CALL GEOM_TO_VAR(NVARU,QCPPSANGLE)

      DISTCB=0.D0
      DISTBA=0.D0
      DO I1=1,NVARU
C JMC WHY NOT ADJUST IF > PI ETC?
         DIFFPP=QCPPSANGLE(I1)-QBPPSANGLE(I1)
         IF (DIFFPP.LT.-PI) DIFFPP = DIFFPP+2.0D0*PI
         IF (DIFFPP.GT.PI) DIFFPP = DIFFPP-2.0D0*PI

         DISTCB=DISTCB+ABS(DIFFPP)

         DIFFPP=QBPPSANGLE(I1)-QAPPSANGLE(I1)
         IF (DIFFPP.LT.-PI) DIFFPP = DIFFPP+2.0D0*PI
         IF (DIFFPP.GT.PI) DIFFPP = DIFFPP-2.0D0*PI
         DISTBA=DISTBA+ABS(DIFFPP)
      ENDDO

      DISTCB=DISTCB/NVARU
      DISTBA=DISTBA/NVARU

      DIHEDIST=DISTCB-DISTBA

      RETURN
      END

