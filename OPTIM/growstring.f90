MODULE GROWSTRINGUTILS
  USE COMMONS
  USE KEY, ONLY : DEBUG, DESMDEBUG, PERMDIST, TWOD, RIGIDBODY, BULKT, &
       & FREEZENODEST, FREEZETOL,INTEPSILON, DESMAXEJUMP, DESMAXAVGE
  USE CUBSPLSTRING
  USE GSDATA
  USE SPFUNCTS, ONLY : SHIFTZERO, ROTATEZERO
  USE INTCOMMONS, ONLY : NINTC, NINTIM, INTINTERPT, NATINT, DESMINT, NNZ, KD, NDIH, ALIGNDIR, &
       & DIHINFO, PREVDIH, BACKTCUTOFF, INTERPBACKTCUT, MINBACKTCUT
!
! MOVED THIS LINE TO PREVENT A SEGMENTATION FAULT IN GFORTRAN
!
! USE INTCUTILS, ONLY : CART2INT, INTINTERPOLATE
  IMPLICIT NONE
  
CONTAINS
    
  SUBROUTINE GROWSTRING(RS, RF, INPUTIM, FINALX, FINALE, FINALTAN,RMS,MFLAG)
    ! RS AND RF ARE START AND END COORDINATES, RESPECTIVELY
    ! IMPLEMENT GROWING STRING METHOD USING EVOLVESTRING SUBROUTINE
    ! FINALTAN IS A 2D ARRAY POINTER WITH COORDINATES AS FIRST DIM, IMAGE AS SECOND

    USE INTCUTILS, ONLY : CART2INT, INTINTERPOLATE
    IMPLICIT NONE

    DOUBLE PRECISION, INTENT(INOUT) :: RS(3*NATOMS), RF(3*NATOMS)
    DOUBLE PRECISION, INTENT(OUT) :: RMS
    INTEGER, INTENT(IN) :: INPUTIM
    DOUBLE PRECISION, POINTER :: FINALX(:), FINALE(:), FINALTAN(:,:)
    LOGICAL, INTENT(OUT) :: MFLAG

    TYPE(IMGNODE), POINTER :: DUMMYP    

    DOUBLE PRECISION :: PREVBACKTCUTOFF

    LOGICAL :: GROWLEFT
    ! MAKE SURE DIFF IS BIG ENOUGH TO HOLD EITHER CARTESIANS OR INTERNALS
    DOUBLE PRECISION :: TMPRMS, PARAM, DIFF(3*NATOMS+NINTC), TOL, DIST
    DOUBLE PRECISION :: TMPXYZ(1:3*NATOMS*INPUTIM)
    INTEGER :: IM, CRD

    DOUBLE PRECISION :: STPINT(NINTC), STPCART(3*NATOMS)
    LOGICAL :: FAILED

    INTEGER :: ISTAT

    ! ALIGNMENT STUFF
    DOUBLE PRECISION :: DISTF, DIST2, RMAT(3,3)
    CHARACTER(LEN=5) :: ZSYMSAVE
    COMMON /SYS/ ZSYMSAVE

    ! TESTING ONLY
    DOUBLE PRECISION :: TESTINT(NINTC)

    ! --------------------------------------------    

    IF (.NOT.EVOLVESTRINGT.AND.INTINTERPT) THEN
       PRINT*, 'ERROR! GROWING STRINGS NOT IMPLEMENTED WITH INTINTERP'
       STOP
    ENDIF

    PTEST = DESMDEBUG.OR.DEBUG
    INTPTEST = .FALSE.

    IF (PTEST) THEN
       CALL DUMPCOORDS(RS, 'START.XYZ')
       CALL DUMPCOORDS(RF, 'FIN.XYZ')
    ENDIF

    ! INITIALIZE SOME STUFF; TIM & NC ARE DECLARED IN GSDATA
    TIM = INPUTIM ! TOTAL NUMBER OF IMAGES
    IF (DESMINT) THEN ! NUMBER OF COORDINATES
       NC = NINTC 
    ELSE
       NC = 3*NATOMS
    ENDIF
    NLIM = 0; NRIM = 0; NIM = 0
    M = GSUPDATE
    MAXLEN = MAXLENPERIM*TIM
    IF (GSMAXTOTITD.GE.0) MAXTOTSTEPS = GSMAXTOTITD*TIM
    TOTSTEPS = 0

    ! ZERO COORDINATES 1:4 AND 7:8 OF BOTH START AND END STRUCTURES      
    IF (FIXATMS.AND.PREROTATE.AND..NOT.DESMINT) THEN
       ! SHIFT MOLECULE SO 1ST ATM IS AT ORIGIN
       CALL SHIFTZERO(RS, NATOMS, 1)
       CALL SHIFTZERO(RF, NATOMS, 1)

       ! ROTATE AROUNT Y AXIS TO ZERO X COMPONENT OF 3RD ATOM       
       CALL ROTATEZERO(RS, NATOMS, 3, 2, 1)
       CALL ROTATEZERO(RF, NATOMS, 3, 2, 1)

       ! ROTATE AROUNT X AXIS TO ZERO Y COMPONENT OF 3RD ATOM
       CALL ROTATEZERO(RS, NATOMS, 3, 1, 2)
       CALL ROTATEZERO(RF, NATOMS, 3, 1, 2)

       ! NOW 3RD ATOM IS ON Z AXIS
       ! ROTATE AROUND Z AXIS TO ZERO X COMPONENT OF 2ND ATOM
       CALL ROTATEZERO(RS, NATOMS, 2, 3, 1)
       CALL ROTATEZERO(RF, NATOMS, 2, 3, 1)
    ENDIF

    ! MAKE THE ENDPOINTS
    NULLIFY(FIRST,LAST, LEFTFRONT, RIGHTFRONT)
    CALL NEWNODE(FIRST); CALL NEWNODE(LAST)        
    LEFTFRONT => FIRST; RIGHTFRONT => LAST

    IF (DESMINT) THEN
       DIHINFO(:,:) = 0.0D0
       
       FIRST%XYZCART(1:3*NATOMS) = RS(:)
       LAST%XYZCART(1:3*NATOMS) = RF(:)

       PREVDIH => DIHINFO(1,:)
       CALL CART2INT(FIRST%XYZCART(1:3*NATOMS),FIRST%XYZ(1:NC))
       
       !ALIGN TO FIRST IMAGE
       ALIGNDIR = .TRUE.
       DIHINFO(TIM+2,:) = DIHINFO(1,:)
       PREVDIH => DIHINFO(TIM+2,:)
       
       CALL CART2INT(LAST%XYZCART(1:3*NATOMS),LAST%XYZ(1:NC))                                          

       ALIGNDIR = .FALSE.
       
       FIRST%PREVXYZ(:) = FIRST%XYZ(:); FIRST%PREVXCART(:) = FIRST%XYZCART(:)
       LAST%PREVXYZ(:) = LAST%XYZ(:); LAST%PREVXCART(:) = LAST%XYZCART(:)
    ELSE
       FIRST%XYZ(1:NC) = RS(1:NC); FIRST%PREVXYZ(1:NC) = RS(1:NC)    
       LAST%XYZ(1:NC) = RF(1:NC); LAST%PREVXYZ(1:NC) = RF(1:NC)
    ENDIF

    DIFF(1:NC) = LAST%XYZ(1:NC) - FIRST%XYZ(1:NC)

    STRINGLEN = SQRT(DOT_PRODUCT(DIFF(1:NC),DIFF(1:NC)))
    IF(PTEST) PRINT*, 'STARTING STRING LEN: ', STRINGLEN

    FIRST%ARC = 0.0D0; FIRST%CHORD = 0.0D0; FIRST%IND = 0          

    ! GET INITIAL ENERGIES
    IF (DESMINT) THEN
       CALL POTENTIAL(RS(:), FIRST%E, FIRST%GCART, .FALSE., .FALSE., &
            & TMPRMS, .FALSE., .FALSE.)    
       CALL POTENTIAL(RF(:), LAST%E, LAST%GCART, .FALSE., .FALSE., &
            & TMPRMS, .FALSE., .FALSE.)            
    ELSE
       CALL POTENTIAL(RS(:), FIRST%E, FIRST%GRAD, .FALSE., .FALSE., &
            & TMPRMS, .FALSE., .FALSE.)    
       CALL POTENTIAL(RF(:), LAST%E, LAST%GRAD, .FALSE., .FALSE., &
            & TMPRMS, .FALSE., .FALSE.)
    ENDIF

    IF (CUBSPLT.OR.TANTYPE.EQ.3) THEN
       IF (DESMINT) THEN
          PRINT*, 'ERROR! DESMINT NOT IMPLEMENTED WITH CUBIC SPLINES YET!'
          STOP
       ENDIF

       ALLOCATE(COEFF(4,TIM+2,NC), ABSC(TIM+2))
       ABSC(1) = 0.0D0; COEFF(1,1,:) = FIRST%XYZ(:)
    ENDIF

    IF (EVOLVESTRINGT) THEN       

       ! FOR JUST EVOLVING A LINEAR INTERPOLATION       
       NIM = TIM
       NLIM = TIM/2; NRIM = TIM-TIM/2
       JOINED = .TRUE.
       DO IM = 1,NLIM
          CALL EXTENDLEFT
       ENDDO
       DO IM = 1,NRIM
          CALL EXTENDRIGHT
       ENDDO

       ! MOVE FIRST AND LAST TO IMAGES RATHER THAN ENDPOINTS
       FIRST => FIRST%NEXT; LAST => LAST%PREV 

       IF (INTINTERPT) THEN
          CALL INTINTERPOLATE(RS,RF,NINTIM,NIM,TMPXYZ(:),PTEST, FAILED)
          DUMMYP => FIRST
          DO IM = 1,NIM
             DUMMYP%XYZ(:) = TMPXYZ(NC*(IM-1)+1:NC*IM)
             DUMMYP => DUMMYP%NEXT
          ENDDO      
       ELSE
          BACKTCUTOFF = INTERPBACKTCUT
          DUMMYP => FIRST
          DO IM = 1,NIM
             DUMMYP%XYZ = DUMMYP%PREV%XYZ + DIFF(1:NC)*1.0D0/(TIM+1)
             IF (DESMINT) THEN
                DIHINFO(IM+1,:) = DIHINFO(IM,:)
                PREVDIH => DIHINFO(IM+1,:)

                STPINT(:) = DIFF(1:NC)*1.0D0/(TIM+1)
                CALL TRANSBACKDELTA(STPINT,STPCART,DUMMYP%PREV%XYZCART,NINTC,3*NATOMS,NNZ,KD,FAILED,INTPTEST,INTEPSILON)
                DUMMYP%XYZCART(:) = DUMMYP%PREV%XYZCART(:) + STPCART(:)
                
                ! ALIGN TO START STRUCT
                CALL NEWMINDIST(RF(:),DUMMYP%XYZCART,NATOMS,DIST,.FALSE.,.FALSE.,ZSYM(1),.FALSE.,.FALSE.,.FALSE.,RMAT)
             ENDIF             

             DUMMYP => DUMMYP%NEXT
          ENDDO
          BACKTCUTOFF = MINBACKTCUT
       ENDIF

       CALL CHECKENERGIES ! CHECK ENERGIES AREN'T INFINITE

       IF (PTEST) CALL TSUMMARY

       CALL EVOLVESTRING(GROWLEFT, RMS, MFLAG)      

    ELSE

       JOINED = .FALSE.

       DO WHILE(.NOT.JOINED)
          IF (NIM.EQ.0) THEN

             ! MAKE FIRST IMAGES          
             CALL EXTENDLEFT; CALL EXTENDRIGHT

             FIRST => LEFTFRONT; LAST => RIGHTFRONT 
             
             FIRST%XYZ(1:NC) = FIRST%PREV%XYZ(:) + 1.0D0/(TIM+1)*DIFF(1:NC)
             LAST%XYZ(1:NC) = LAST%NEXT%XYZ(:) - 1.0D0/(TIM+1)*DIFF(1:NC)

             IF (DESMINT) THEN
                STPINT(:) = DIFF(1:NC)*1.0D0/(TIM+1)

                DIHINFO(2,:) = DIHINFO(1,:)
                PREVDIH => DIHINFO(2,:)
                
                CALL TRANSBACKDELTA(STPINT,STPCART,FIRST%PREV%XYZCART,NINTC,3*NATOMS,NNZ,KD,FAILED,INTPTEST,INTEPSILON)
                FIRST%XYZCART(:) = FIRST%PREV%XYZCART(:) + STPCART(:)

                DIHINFO(TIM+1,:) = DIHINFO(TIM+2,:)
                PREVDIH => DIHINFO(2,:)
                
                CALL TRANSBACKDELTA(-STPINT,STPCART,FIRST%PREV%XYZCART,NINTC,3*NATOMS,NNZ,KD,FAILED,INTPTEST,INTEPSILON)
                LAST%XYZCART(:) = LAST%NEXT%XYZCART(:) + STPCART(:)
             ENDIF             
             NLIM = 1; NRIM = 1; NIM = 2

             LEFTFRONT%LF = .TRUE.; RIGHTFRONT%RF = .TRUE.             
             
             DUMMYP => FIRST
             DO IM = 1,2
                CALL GETIMGPOT(DUMMYP, TMPRMS)
                DUMMYP => DUMMYP%NEXT
             ENDDO
          ELSE
             ! ASSUME STRING INTERPOLATED, SO DIFFS, CHORDS, ARCS ARE SET
             IF (GROWLEFT) THEN ! GROW FROM THE LEFT

                IF (PTEST) PRINT*, 'GROWING LEFT'             
                CALL EXTENDLEFT

                IF(CUBSPLT) THEN
                   PARAM = FOLLOWARCNEWT((RIGHTFRONT%ARC-LEFTFRONT%PREV%ARC)*1.0/(TIM-NIM+1), NLIM, 0)
                   CALL GETSPLVAL(PARAM, NLIM, 0, LEFTFRONT%XYZ)                
                ELSE
                   LEFTFRONT%XYZ = LEFTFRONT%PREV%XYZ + RIGHTFRONT%DIFF * 1.0/(TIM-NIM+1)
                   IF (DESMINT) THEN
                      DIHINFO(NLIM+2,:) = DIHINFO(NLIM+1,:)
                      PREVDIH => DIHINFO(NLIM+2,:)

                      STPINT(:) = RIGHTFRONT%DIFF * 1.0/(TIM-NIM+1)
                      CALL TRANSBACKDELTA(STPINT,STPCART,LEFTFRONT%PREV%XYZCART,NINTC, &
                           & 3*NATOMS,NNZ,KD,FAILED,INTPTEST,INTEPSILON)
                      LEFTFRONT%XYZCART(:) = LEFTFRONT%PREV%XYZCART(:) + STPCART(:)
                   ENDIF
                ENDIF
                NLIM = NLIM + 1; NIM = NIM+1
                
                CALL GETIMGPOT(LEFTFRONT, TMPRMS)

             ELSE
                IF (PTEST) PRINT*, 'GROWING RIGHT'

                CALL EXTENDRIGHT

                IF(CUBSPLT) THEN
                   PARAM = FOLLOWARCNEWT((RIGHTFRONT%NEXT%ARC-LEFTFRONT%ARC)*DBLE(TIM-NIM)/(TIM-NIM+1), NLIM+1, 1)
                   CALL GETSPLVAL(PARAM, NLIM, 0, RIGHTFRONT%XYZ)
                ELSE                   
                   RIGHTFRONT%XYZ = RIGHTFRONT%NEXT%XYZ - RIGHTFRONT%NEXT%DIFF*1.0/(TIM-NIM+1)
                   IF (DESMINT) THEN
                      DIHINFO(TIM-NRIM+1,:) = DIHINFO(TIM-NRIM+2,:)
                      PREVDIH => DIHINFO(TIM-NRIM+1,:)
                      
                      STPINT(:) = - RIGHTFRONT%NEXT%DIFF*1.0/(TIM-NIM+1)
                      CALL TRANSBACKDELTA(STPINT,STPCART,RIGHTFRONT%NEXT%XYZCART,NINTC, &
                           & 3*NATOMS,NNZ,KD,FAILED,INTPTEST,INTEPSILON)
                      RIGHTFRONT%XYZCART(:) = RIGHTFRONT%NEXT%XYZCART(:) + STPCART(:)
                   ENDIF
                ENDIF
                NRIM = NRIM +1; NIM = NIM+1
                
                CALL GETIMGPOT(RIGHTFRONT, TMPRMS)
                
             ENDIF
          ENDIF

          IF (NIM.EQ.TIM) THEN
             IF (PTEST) PRINT*, 'GS> STRING HAS JOINED!'
             JOINED = .TRUE.
          ENDIF

          CALL EVOLVESTRING(GROWLEFT, RMS, MFLAG)
          
          IF (GSMAXTOTITD.GE.0.AND.TOTSTEPS.GT.MAXTOTSTEPS) EXIT
       ENDDO
    ENDIF

    IF(PTEST) PRINT '(A,I6,2G20.10)', 'FINAL STRING LENGTH, LEN PER IMAGE: ', NIM, STRINGLEN, STRINGLEN/(NIM+1)

    ! OUTPUT RESULTS

    CALL OUTPUT(FINALX, FINALE, FINALTAN)

    ! IF FOR SOME REASON OUTPUTTING BEFORE FULL STRING GROWN:
    IF (NIM.LT.TIM) THEN 
       DO IM = NIM+1, TIM
          FINALE(IM) = LAST%NEXT%E
          IF (DESMINT) THEN
             FINALX(NC*(IM-1)+1:NC*IM) = LAST%NEXT%XYZCART
          ELSE
             FINALX(NC*(IM-1)+1:NC*IM) = LAST%NEXT%XYZ
          ENDIF
       ENDDO
    ENDIF

    CALL DELETESTRING
    
    IF (CUBSPLT.OR.TANTYPE.EQ.3) DEALLOCATE(COEFF, ABSC)
  END SUBROUTINE GROWSTRING

  SUBROUTINE EVOLVESTRING(GROWLEFT, FNRMS, MFLAG)
    ! EVOLVE STRING UNTIL EITHER ONE OF THE FRONTIER RMS OR THE ENTIRE RMS FPERP IS BELOW A GIVEN TOLERANCE
    ! LOTS OF THE VARIABLES ARE DEFINED IN GSDATA
    ! RETURNS GROWLEFT TRUE IF LEFT SIDE CONVERGED BEFORE RIGHT
    ! RETURNS MFLAG TRUE IF SUCCESSFULLY CONVERGED

    IMPLICIT NONE

    TYPE(IMGNODE), POINTER :: START, DUMMYP
    DOUBLE PRECISION, INTENT(OUT) :: FNRMS
    LOGICAL, INTENT(OUT) :: MFLAG, GROWLEFT
    INTEGER :: I, IM, IMCOUNT
    LOGICAL :: REPARAM

    INTEGER :: BOUND, EVOLIT, P, K, POINT
    DOUBLE PRECISION :: SLENGTH, GAMMA, YY, SY, BETA, FNORM2, RMS
    DOUBLE PRECISION, DIMENSION(0:GSUPDATE-1,NC*NIM):: Y, S
    DOUBLE PRECISION, DIMENSION(0:GSUPDATE-1) :: RO, ALPHA
    DOUBLE PRECISION, DIMENSION(NC*NIM) :: FPERP, NRDIR, HF, DIAG, Q, STP, PREVFPERP

    DOUBLE PRECISION :: FNRMSL, FNRMSR
    DOUBLE PRECISION, DIMENSION(NC*NIM) :: FULLGRAD, PREVFULLGRAD

    DOUBLE PRECISION :: AVGE, MAXE, PREVE
    INTEGER :: ISTAT
    
    ! BENCHMARKS ONLY
    DOUBLE PRECISION :: TOTE

    ! FOR INTERNALS
    LOGICAL :: FAILED
    DOUBLE PRECISION :: STPINT(NC), STPCART(3*NATOMS)

    ! TESTING ONLY
    INTEGER :: CRD

    ! -------------------------------------------    

    ! DO SOME INITIALIZING STUFF
    MFLAG = .FALSE.

    !---------
    ! EVOLUTION STEP, USING LBFGS METHOD AS DESCRIBED IN NOCEDAL & WRIGHT, 2000, CH.9
    !---------
    EVOLIT = 0 ! CURRENT STRING EVOLUTION ITERATION (THE INDEX K IN PETERS, ET AL)
    K = 0

    IF (HESSGRAD) THEN
       DUMMYP => FIRST
       DO IM = 1,NIM
          FULLGRAD(NC*(IM-1)+1:NC*IM) = DUMMYP%GRAD(:)
          DUMMYP=>DUMMYP%NEXT
       ENDDO
    ENDIF

    DO         
       EVOLIT = EVOLIT + 1
       TOTSTEPS = TOTSTEPS + 1

       CALL INTERPOLATE          ! INTERPOLATE STRING, RESET DIFFS, ARCS, CHORDS       

       CALL DECIDEREPARAM(REPARAM) ! DECIDE WHETHER TO REPARAMETERIZE       

       IF (REPARAM) CALL REPARAMETRIZE          

       IMCOUNT = NIM ! IMCOUNT IS THE NUMBER OF MOVABLE IMAGES
       START => FIRST ! START OF MOVABLE IMAGES
       
       ! GET ENERGIES AND GRAD VECTORS
       ! IF NOT REPARAMETRIZING, CAN JUST USE ENERGIES AND GRADS FROM END OF LAST CYCLE
       ! ASSUMES ENERGIES WERE PRECALCULATED BEFORE ENTERING EVOLVESTRING ROUTINE
       IF (REPARAM) THEN
          DUMMYP => START
          DO IM = 1,IMCOUNT
             CALL GETIMGPOT(DUMMYP,RMS)
             IF (HESSGRAD) FULLGRAD(NC*(IM-1)+1:NC*IM) = DUMMYP%GRAD(:)
             DUMMYP => DUMMYP%NEXT
          ENDDO
          ! RESET HESSIAN APPROXIMATION
          K = 0
       ENDIF

       CALL GETTANGENTS

       FNRMSL = 0.0D0; FNRMSR = 0.0D0
       FNORM2 = 0.0D0       

       DUMMYP => START
       DO IM = 1,NIM
          ! RECALCULATE FPERP AND FNORMS
          FPERP(NC*(IM-1)+1:NC*IM) = - DUMMYP%GRAD(:) + &
               & DOT_PRODUCT(DUMMYP%GRAD, DUMMYP%TGT)*DUMMYP%TGT(:)       

          IF (FIXATMS) THEN
             FPERP(NC*(IM-1)+1:NC*(IM-1)+4) = 0.0D0
             FPERP(NC*(IM-1)+7:NC*(IM-1)+8) = 0.0D0
          ENDIF

          DUMMYP%FNORM2 = DOT_PRODUCT(FPERP(NC*(IM-1)+1:NC*IM),FPERP(NC*(IM-1)+1:NC*IM))

          FNORM2 = FNORM2+DUMMYP%FNORM2
          IF (JOINED.OR.DUMMYP%LF) THEN 
             FNRMSL = FNRMSL+DUMMYP%FNORM2                         
          ELSE IF (DUMMYP%RF) THEN
             FNRMSR = FNRMSR + DUMMYP%FNORM2
          ENDIF
          DUMMYP => DUMMYP%NEXT
       ENDDO

       FNRMS = SQRT(FNORM2/IMCOUNT)

       ! DECIDE WHETHER TO FREEZE SOME NODES B/C NOT CONTRIBUTING SIGNIFICANTLY TO FNRMS
       IF (FREEZENODEST) THEN
          DUMMYP => START
          DO IM = 1,IMCOUNT
             DUMMYP%FREEZE = (SQRT(DUMMYP%FNORM2)/FNRMS.LT.FREEZETOL)
             IF (DUMMYP%FREEZE.AND.PTEST) &
                  & PRINT '(A,I4,L2,2F15.5)', 'FREEZING IMAGE: ', IM, DUMMYP%FREEZE,SQRT(DUMMYP%FNORM2),FNRMS
             DUMMYP => DUMMYP%NEXT
          ENDDO
       ENDIF

       FNRMS = FNRMS / SQRT(DBLE(NC))

       IF (JOINED) THEN
          FNRMSL = SQRT(FNRMSL/NIM/NC)
       ELSE
          FNRMSL = SQRT(FNRMSL/NC)
          FNRMSR = SQRT(FNRMSR/NC)
       ENDIF
       
       IF (PTEST) THEN
          ! GET AVERAGE AND MAXIMUM ENERGY
          AVGE = 0.0D0
          MAXE = -1.0D10
          DUMMYP => FIRST
          DO IM = 1,NIM
             AVGE = AVGE + DUMMYP%E
             IF (DUMMYP%E.GT.MAXE) MAXE = DUMMYP%E
             DUMMYP => DUMMYP%NEXT
          ENDDO
          AVGE = AVGE/NIM

          IF (DUMPGSALL) THEN
             CALL DUMPGSPATH(EVOLIT)
          ELSE IF (PTEST) THEN
             CALL DUMPGSPATH(-1)
          ENDIF

          IF (JOINED) THEN
             PRINT '(A,1X,3G20.10,1X,2I6)', '>>> FNRMS, MAXE, AVGE, NIM, EVOLIT: ', FNRMS, MAXE, AVGE, NIM, EVOLIT
          ELSE
             PRINT '(A,1X,3G20.10,1X,2I6)', '>>> FNRMSL, FNRMSR, FNRMS, NIM, EVOLIT: ', FNRMSL, FNRMSR, FNRMS, NIM, EVOLIT
          ENDIF

!         CALL FLUSH(6,ISTAT)
       ENDIF

       ! CHECK FOR CONVERGENCE
       IF (JOINED.AND.FNRMSL.LT.GSCONV) THEN
          IF (PTEST) PRINT*, 'SUCCESS! - WHOLE STRING CONVERGED!'
          MFLAG = .TRUE.
          EXIT 
       ELSE IF (.NOT.JOINED.AND.FNRMSL.LT.GSGROWTOL) THEN
          IF (PTEST) PRINT*, 'SUCCESS! - LEFT END CONVERGED!'
          GROWLEFT = .TRUE.
          MFLAG = .TRUE.
          EXIT 
       ELSE IF (.NOT.JOINED.AND.FNRMSR.LT.GSGROWTOL) THEN
          IF (PTEST) PRINT*, 'SUCCESS! - RIGHT END CONVERGED!'
          MFLAG = .TRUE.
          GROWLEFT = .FALSE.
          EXIT  
       ENDIF

       IF (GSMAXTOTITD.GE.0.AND.TOTSTEPS.GT.MAXTOTSTEPS) THEN
          PRINT*, 'TOTAL NUMBER OF STEPS FOR ENTIRE STRING EXCEEDED MAXIMUM.', NIM, TOTSTEPS, MAXTOTSTEPS
          IF(PTEST) PRINT*, 'STRING LENGTH: ', STRINGLEN
          EXIT
       ELSE IF(JOINED.AND.EVOLIT.GT.ITERD*NIM.AND.AVGE.LT.DESMAXAVGE) THEN
          IF (PTEST) THEN 
             PRINT*, 'NUMBER OF FINAL EVOLUTION STEPS EXCEEDED MAXIMUM; AVERAGE ENERGY BELOW MAXAVGE.'
             IF (PTEST) PRINT*, 'STRING LENGTH: ', STRINGLEN
          ENDIF
          GROWLEFT = (FNRMSL <= FNRMSR)
          EXIT
       ELSE IF (.NOT.JOINED.AND.EVOLIT.GT.MAXGROWSTEPS) THEN
          PRINT*, 'NUMBER OF GROWING EVOLUTION STEPS EXCEEDED MAXIMUM.'
          IF (PTEST) PRINT*, 'STRING LENGTH: ', STRINGLEN
          GROWLEFT = (FNRMSL <= FNRMSR)
          EXIT
       ENDIF


       ! GET THE NR STEPS AND MOVE IMAGES       
       LBFGS: IF (.NOT.NOLBFGS) THEN
       MAIN: IF(K.EQ.0) THEN
          ! USE DGUESS AS THE INITIAL GUESS FOR THE INVERSE HESSIAN DIAGONAL
          HF(:) = GSDGUESS*FPERP(:)
             
          ! MAKE THE FIRST GUESS FOR THE STEP LENGTH CAUTIOUS
          IF (FNORM2.EQ.0.0D0) THEN
             FNORM2=1.0D0 ! EXACT ZERO IS PRESUMABLY WRONG!
             PRINT '(A)','WARNING - FNORM WAS ZERO IN LBFGS,&
                  & RESETTING TO ONE'
          ENDIF
          STP(:) = MIN(1.0D0/SQRT(FNORM2), SQRT(FNORM2))
          
          POINT = 0
       
       ELSE MAIN
          P = MODULO(POINT-1,M) ! POSITION IN LBFGS LISTS
          BOUND = MIN(K,M) ! HOW FAR BACKWARDS TO LOOK FOR HESSIAN  
          
          IF (HESSGRAD) THEN
             Y(P,:) = FULLGRAD(:) - PREVFULLGRAD(:)
          ELSE
             Y(P,:) = PREVFPERP(:) - FPERP(:)
          ENDIF
        
          ! GET INITIAL DIAGONAL HESSIAN ESTIMATE; EQ. 9.6 IN NOCEDAL, ET AL.
          SY = DOT_PRODUCT(S(P,:),Y(P,:))               
          YY = DOT_PRODUCT(Y(P,:), Y(P,:))               
          IF (SY.EQ.0.0D0) SY = 1.0D0
          IF (YY.EQ.0.0D0) YY = 1.0D0
          GAMMA = SY / YY
          DIAG(:) = GAMMA

          ! UPDATE RO
          RO(P) = 1.0D0/SY
             
          ! GET HF = HK*FPERP (TWO-LOOP ALGORITHM 9.1 IN NOCEDAL ET AL)
          Q(:) = FPERP(:)             
                    
          DO I = 1,BOUND                             
             ALPHA(P) = RO(P)*DOT_PRODUCT(S(P,:),Q(:))
             Q(:) = Q(:) - ALPHA(P)*Y(P,:)
             P = MODULO(P-1,M)
          ENDDO          

          HF(:) = DIAG(:)*Q(:)

          DO I = 1, BOUND
             P = MODULO(P+1,M)
             BETA = RO(P)*DOT_PRODUCT(Y(P,:), HF(:))
             HF(:) = HF(:) + (ALPHA(P) - BETA)*S(P,:)                
          ENDDO
          STP(:) = 1.0
       ENDIF MAIN
       ENDIF LBFGS

       IF (HESSGRAD) THEN
          DUMMYP => START
          DO IM = 1,NIM
             NRDIR(NC*(IM-1)+1:NC*IM) = HF(NC*(IM-1)+1:NC*IM) - &
                  & DOT_PRODUCT(HF(NC*(IM-1)+1:NC*IM), DUMMYP%TGT)*DUMMYP%TGT(:)
             DUMMYP => DUMMYP%NEXT
          ENDDO         
       ELSE IF (NOLBFGS) THEN
          NRDIR(:) = FPERP(:)
          STP(:) = 1.0D0
       ELSE
          NRDIR(:) = HF(:)
       ENDIF

       IF (FIXATMS) THEN
          DO IM = 1,NIM
             NRDIR(NC*(IM-1)+1:NC*(IM-1)+4) = 0.0D0
             NRDIR(NC*(IM-1)+7:NC*(IM-1)+8) = 0.0D0
          ENDDO
       ENDIF
       
       IF (DOT_PRODUCT(NRDIR,FPERP).LT.0) THEN 
          IF(PTEST) PRINT*, 'NRDIR HAS NEGATIVE PROJECTION ONTO FPERP. REVERSING STEP.'
          NRDIR(:) = -NRDIR(:)
       ENDIF

       ! TAKE NO MORE THAN MAX STEP FOR EACH INDIVIDUAL IMAGE
       IF (HESSGRAD) PREVFULLGRAD(:) = FULLGRAD(:)

       DUMMYP => START
       DO IM = 1,NIM
          IF (DUMMYP%FREEZE) THEN
             STP(NC*(IM-1)+1:NC*IM) = 0.0D0
             S(POINT,NC*(IM-1)+1:NC*IM) = 0.0D0
          ELSE
             DUMMYP%PREVXYZ(1:NC) = DUMMYP%XYZ(1:NC)
             IF (DESMINT) DUMMYP%PREVXCART(1:3*NATOMS) = DUMMYP%XYZCART(1:3*NATOMS)

             SLENGTH = SQRT(DOT_PRODUCT(NRDIR(NC*(IM-1)+1:NC*IM), NRDIR(NC*(IM-1)+1:NC*IM)))
             STP(NC*(IM-1)+1:NC*IM) = MIN(GSMXSTP/SLENGTH, STP(NC*(IM-1)+1))
             
             S(POINT,NC*(IM-1)+1:NC*IM) = STP(NC*(IM-1)+1:NC*IM)*NRDIR(NC*(IM-1)+1:NC*IM)
             DUMMYP%XYZ(:) = DUMMYP%XYZ(:) + S(POINT,NC*(IM-1)+1:NC*IM)   

             IF (DESMINT) THEN
                PREVDIH => DIHINFO(IM+1,:)
                CALL TRANSBACKDELTA(S(POINT,NC*(IM-1)+1:NC*IM),STPCART,DUMMYP%XYZCART,NINTC, &
                     & 3*NATOMS,NNZ,KD,FAILED,INTPTEST,INTEPSILON)                
                DUMMYP%XYZCART = DUMMYP%XYZCART + STPCART
             ENDIF

             PREVE = DUMMYP%E
             CALL GETIMGPOT(DUMMYP,RMS)

             IF ((PREVE.LT.0.AND.DUMMYP%E-PREVE.GT.DESMAXEJUMP).OR.(DESMINT.AND.FAILED)) THEN
                IF (PTEST) PRINT*, 'ENERGY JUMP TOO BIG FOR IMAGE OR FAILED TRANSBACKDELTA. SKIPPING THIS IMAGE.', &
                     & IM, PREVE, DUMMYP%E
                DUMMYP%XYZ(:) = DUMMYP%PREVXYZ(:)
                IF (DESMINT) DUMMYP%XYZCART(:) = DUMMYP%PREVXCART(:)
                STP(NC*(IM-1)+1:NC*IM) = 0.0D0
                S(POINT,NC*(IM-1)+1:NC*IM) = 0.0D0
                CALL GETIMGPOT(DUMMYP,RMS)
             ENDIF

             IF (HESSGRAD) FULLGRAD(NC*(IM-1)+1:NC*IM) = DUMMYP%GRAD
          ENDIF
          DUMMYP => DUMMYP%NEXT
       ENDDO

       IF (.NOT.HESSGRAD) PREVFPERP(:) = FPERP(:)       

       ! UPDATE ITERATION NUMBER AND POINT IN LBFGS LISTS
       K = K + 1
       POINT = MODULO(POINT+1,M)          

!       DUMMYP => DUMMYP%NEXT
       
    ENDDO

    IF (PTEST) CALL DUMPGSPATH(-1)

  END SUBROUTINE EVOLVESTRING

  SUBROUTINE DECIDEREPARAM(REPARAM)
    ! DECIDE WHETHER OR NOT TO REPARAMETRIZE STRING
    
    IMPLICIT NONE
    
    LOGICAL, INTENT(OUT) :: REPARAM
    INTEGER :: IM
    DOUBLE PRECISION :: OFFSET, GOODLEN, ACTLEN, NEWOFFSET, MINOFFSET, MAXOFFSET
    TYPE(IMGNODE), POINTER :: DUMMYP
    
    REPARAM = .FALSE.
    
    MINOFFSET = DBLE(NIM)
    MAXOFFSET = 0.0D0
    
    DUMMYP => FIRST%PREV
    DO IM = 1,NIM+1
       DUMMYP => DUMMYP%NEXT

       ! GET DESIRED LENGTH
       IF (.NOT.JOINED.AND.DUMMYP%RF) THEN 
          GOODLEN = STRINGLEN*(1.0-DBLE(NIM)/(TIM+1))
       ELSE
          GOODLEN = STRINGLEN*1.0D0/(TIM+1)
       ENDIF
       
       ! GET ACTUAL LENGTH
       IF (CUBSPLT) THEN 
          ACTLEN = DUMMYP%ARC-DUMMYP%PREV%ARC
       ELSE
          ACTLEN = DUMMYP%CHORD
       ENDIF
       
       NEWOFFSET  = ACTLEN/GOODLEN
       IF (NEWOFFSET.LT.MINOFFSET) THEN
          MINOFFSET = NEWOFFSET
       ELSE IF (NEWOFFSET.GT.MAXOFFSET) THEN
          MAXOFFSET = NEWOFFSET
       ENDIF

    ENDDO       
    
    IF (MINOFFSET/MAXOFFSET.LT.REPARAMTOL) THEN
       IF(PTEST) PRINT '(A,5F20.10)', ' MINOFFSET, MAXOFFSET, RATIO, REPARAMTOL, TOTAL LENGTH: ', &
  &              MINOFFSET, MAXOFFSET, MINOFFSET/MAXOFFSET, REPARAMTOL, STRINGLEN
       REPARAM = .TRUE.
    ENDIF    
  END SUBROUTINE DECIDEREPARAM

  SUBROUTINE REPARAMETRIZE
    ! REPARAMETRIZE STRING
    ! ASSUME CHORDS, ARCS, DIFFS, STRINGLEN HAVE ALL BEEN SET ALREADY

    IMPLICIT NONE

    INTEGER :: IM
    TYPE(IMGNODE), POINTER :: CURN1, CURN2
    DOUBLE PRECISION :: PARAM, STPINT(NINTC), STPCART(3*NATOMS)
    LOGICAL :: FAILED

    ! ALIGNMENT STUFF
    DOUBLE PRECISION :: DISTF, DIST, DIST2, RMAT(3,3)
    CHARACTER(LEN=5) :: ZSYMSAVE
    COMMON /SYS/ ZSYMSAVE

    DOUBLE PRECISION :: STPDIST1, STPDIST2, STEP(NC)

    IF(PTEST) PRINT*, 'REPARAMETRIZING STRING...'

    ! SAVE CURRENT COORDINATES IN PREVXYZ
    CURN1 => FIRST
    DO IM = 1, NIM       
       CURN1%PREVXYZ(1:NC) = CURN1%XYZ(1:NC)
       IF (DESMINT) CURN1%PREVXCART(1:3*NATOMS) = CURN1%XYZCART(1:3*NATOMS)
       CURN1%IND = IM
       CURN1 => CURN1%NEXT
    ENDDO
    LAST%NEXT%IND = NIM+1

    CURN1 => FIRST; CURN2 => FIRST

    DO IM = 1,NLIM
       CURN2 => CURN2%PREV

       DO WHILE (CURN2%ARC.LE.STRINGLEN*DBLE(IM)/(TIM+1))
          CURN2 => CURN2%NEXT          
       ENDDO
       
       IF (CUBSPLT) THEN
          PARAM = FOLLOWARCNEWT(STRINGLEN*DBLE(IM)/(TIM+1)-CURN2%PREV%ARC,CURN2%PREV%IND,0)
          CALL GETSPLVAL(PARAM,CURN2%PREV%IND,0,CURN1%XYZ)
       ELSE
          STEP(:) = CURN2%DIFF(:)/CURN2%CHORD *(STRINGLEN*DBLE(IM)/(TIM+1)-CURN2%PREV%ARC)
          CURN1%XYZ(:) = CURN2%PREV%PREVXYZ(:) + STEP(:)
          IF (DESMINT) THEN
             STPDIST1 = SQRT(DOT_PRODUCT(STEP,STEP))
             STPINT(:) = CURN1%XYZ - CURN1%PREVXYZ
             STPDIST2 = SQRT(DOT_PRODUCT(STPINT,STPINT))

             IF (NATINT) THEN
                PREVDIH => DIHINFO(IM+1,:)
                PREVDIH(:) = 0.0D0
             ENDIF

             IF (STPDIST1.LT.STPDIST2) THEN 
                ! TAKE STEP FROM PREVIOUS IMAGE POSITION
                CALL TRANSBACKDELTA(STEP,STPCART,CURN2%PREV%PREVXCART,NINTC,3*NATOMS,NNZ,KD,FAILED,INTPTEST,INTEPSILON)
                IF (FAILED) THEN
                   PRINT*, 'TRANSBACKDELTA FAILED IN REPARAMETRIZE W/ STPDIST1', STPDIST1, STPDIST2
                   STOP
                ENDIF
                CURN1%XYZCART = CURN2%PREV%PREVXCART + STPCART
             ELSE
                ! TAKE STEP FROM THIS IMAGE POSITION
                CALL TRANSBACKDELTA(STPINT,STPCART,CURN1%PREVXCART,NINTC,3*NATOMS,NNZ,KD,FAILED,INTPTEST,INTEPSILON)
                IF (FAILED) THEN
                   PRINT*, 'TRANSBACKDELTA FAILED IN REPARAMETRIZE W/ STPDIST2', STPDIST1, STPDIST2
                   STOP
                ENDIF
                CURN1%XYZCART = CURN1%PREVXCART + STPCART
             ENDIF
          ENDIF
       ENDIF       

       CURN1 => CURN1%NEXT
    ENDDO

    CURN1 => LAST; CURN2 => LAST%NEXT
    DO IM = 1,NRIM
       DO WHILE (CURN2%ARC.GE.STRINGLEN*(1.0-DBLE(IM)/(TIM+1)))
          CURN2 => CURN2%PREV
       ENDDO
       CURN2 => CURN2%NEXT       
       IF (CUBSPLT) THEN
          PARAM = FOLLOWARCNEWT(STRINGLEN*(1.0D0-DBLE(IM)/(TIM+1))-CURN2%PREV%ARC,CURN2%IND,1)
          CALL GETSPLVAL(PARAM,CURN2%PREV%IND,0,CURN1%XYZ)
       ELSE          
          STEP(:) = - CURN2%DIFF(:)/CURN2%CHORD*(CURN2%ARC - STRINGLEN*(1.0-DBLE(IM)/(TIM+1)))
          CURN1%XYZ(:) = CURN2%PREVXYZ(:) + STEP(:)
          IF (DESMINT) THEN
             STPDIST1 = SQRT(DOT_PRODUCT(STEP,STEP))
             STPINT(:) = CURN1%XYZ - CURN1%PREVXYZ
             STPDIST2 = SQRT(DOT_PRODUCT(STPINT,STPINT))
                          
             IF (NATINT) THEN
                PREVDIH => DIHINFO(TIM-IM+2,:)
                PREVDIH(:) = 0.0D0
             ENDIF

             IF (STPDIST1.LT.STPDIST2) THEN
                CALL TRANSBACKDELTA(STEP,STPCART,CURN2%PREVXCART,NINTC,3*NATOMS,NNZ,KD,FAILED,INTPTEST,INTEPSILON)
                IF (FAILED) THEN
                   PRINT*, 'TRANSBACKDELTA FAILED IN REPARAMETRIZE W/ STPDIST1', STPDIST1, STPDIST2
                   STOP
                ENDIF
                CURN1%XYZCART = CURN2%PREVXCART + STPCART
             ELSE                
                CALL TRANSBACKDELTA(STPINT,STPCART,CURN1%PREVXCART,NINTC,3*NATOMS,NNZ,KD,FAILED,INTPTEST,INTEPSILON)
                IF (FAILED) THEN
                   PRINT*, 'TRANSBACKDELTA FAILED IN REPARAMETRIZE W/ STPDIST2', STPDIST1, STPDIST2
                   STOP
                ENDIF
                CURN1%XYZCART = CURN1%PREVXCART + STPCART
             ENDIF
          ENDIF
       ENDIF

       CURN1 => CURN1%PREV         
    ENDDO

    ! ALIGN CARTESIAN STRUCTURES ALONG STRING
    IF (DESMINT) THEN
       CURN1 => FIRST%PREV
       DO IM = 1,NIM+1
          CURN1 => CURN1%NEXT
          CALL NEWMINDIST(FIRST%PREV%XYZCART,CURN1%XYZCART,NATOMS,DIST,.FALSE.,.FALSE.,ZSYM(1),.FALSE.,.FALSE.,.FALSE.,RMAT)
       ENDDO
    ENDIF

    CALL INTERPOLATE

    IF (PTEST) PRINT*, 'STRING LENGTH, NIM AFTER REPARAM: ', STRINGLEN, NIM
    
    RETURN
  END SUBROUTINE REPARAMETRIZE

  SUBROUTINE INTERPOLATE
    ! INTERPOLATE STRING
    !RECALCULATE DIFFS, CHORDS, ARCS, STRINGLEN
    ! IF USING INTERNAL COORDS, THESE ARE ALL IN INTERNALS

    IMPLICIT NONE

    TYPE(IMGNODE), POINTER :: DUMMYP
    INTEGER :: IM  

    IF (CUBSPLT.OR.TANTYPE.EQ.3) THEN
       CALL INTERPCUBSPL
       RETURN
    ENDIF

    DUMMYP => FIRST%PREV
    DO IM = 1, NIM+1    
       DUMMYP => DUMMYP%NEXT

       DUMMYP%DIFF(:) = DUMMYP%XYZ(:) - DUMMYP%PREV%XYZ(:)       
       DUMMYP%CHORD = SQRT(DOT_PRODUCT(DUMMYP%DIFF, DUMMYP%DIFF))
       DUMMYP%ARC = DUMMYP%PREV%ARC + DUMMYP%CHORD

    ENDDO

    STRINGLEN = DUMMYP%ARC

    IF (STRINGLEN.GT.MAXLEN) THEN
       PRINT*, 'STRINGLEN EXCEEDS MAXLEN', STRINGLEN, MAXLEN
       STOP
    ENDIF

  END SUBROUTINE INTERPOLATE

  SUBROUTINE GETTANGENTS
    IMPLICIT NONE
    ! GET TANGENT VECTORS; ENTIRE TANGENT VECTOR FOR ALL IMAGES IS NORMALIZED
    ! ASSUMES IMAGES, DIFFS, CHORDS, ARCS ARE ALL PROPERLY ALLOCATED AND CALCULATED

    INTEGER :: IM
    DOUBLE PRECISION :: WP, WM
    TYPE(IMGNODE), POINTER :: CURN

    CURN => FIRST
    DO IM = 1,NIM
       IF (CUBSPLT.OR.TANTYPE.EQ.3) THEN

          CALL GETSPLVAL(0.0D0, IM, 1, CURN%TGT)
          
       ELSE IF (TANTYPE.EQ.1) THEN
          IF (CURN%E > CURN%PREV%E .AND. CURN%NEXT%E > CURN%E) THEN
             WP = 1.0; WM = 0.0
          ELSE IF (CURN%E < CURN%PREV%E .AND. CURN%NEXT%E < CURN%E) THEN
             WP = 0.0; WM = 1.0
          ELSE
             WP = MAX(ABS(CURN%NEXT%E-CURN%E), ABS(CURN%PREV%E-CURN%E))
             WM = MIN(ABS(CURN%NEXT%E-CURN%E), ABS(CURN%PREV%E-CURN%E))
          ENDIF
          IF (WP.EQ.0.0D0.AND.WM.EQ.0.0D0) WP = 1.0D0
          CURN%TGT = WP*CURN%NEXT%DIFF(:) + WM*CURN%DIFF(:)
          
       ELSE IF (TANTYPE.EQ.2) THEN
          CURN%TGT = CURN%DIFF(:)/SQRT(DOT_PRODUCT(CURN%DIFF(:),CURN%DIFF(:))) + &
               & CURN%NEXT%DIFF(:)/SQRT(DOT_PRODUCT(CURN%NEXT%DIFF(:),CURN%NEXT%DIFF(:)))
       ELSE IF (TANTYPE.EQ.4) THEN
          CURN%TGT = CURN%NEXT%DIFF + CURN%DIFF
       ELSE
          PRINT*, 'TANTYPE MUST BE 1,2,3,OR 4 IF USING LINEAR INTERPOLATION: ', TANTYPE
          STOP
       ENDIF

       CURN%TNORM = SQRT(DOT_PRODUCT(CURN%TGT,CURN%TGT))
       
       IF (CURN%TNORM.EQ.0.0D0) THEN
          PRINT*, 'ERROR: TNORM IS ZERO. IMAGES TOO CLOSE TOGETHER. THIS IS IMAGE: ', IM
          STOP
       ENDIF

       CURN%TGT = CURN%TGT/CURN%TNORM

       CURN => CURN%NEXT
    ENDDO
    
  END SUBROUTINE GETTANGENTS

  SUBROUTINE DUMPGSPATH(N)

    IMPLICIT NONE
    INTEGER, INTENT(IN) :: N
    INTEGER :: I,J
    TYPE(IMGNODE), POINTER :: DUMMYP
    CHARACTER*30 :: FNAME

    IF (N.LT.0) THEN
       FNAME = 'GSPATHWAY.XYZ'
    ELSE
       WRITE(FNAME,'(A,I0.3,A)') 'GSPATHWAY.', N, '.XYZ'
    ENDIF

    ! OUTPUT PATHWAY
    OPEN(UNIT=45,FILE=FNAME,STATUS='UNKNOWN')

    DUMMYP => FIRST%PREV
    DO I = 0,NIM+1
       WRITE(45,'(I6)') NATOMS
       WRITE(45,'(A,G25.15)') ' ENERGY= ', DUMMYP%E
       IF (DESMINT) THEN
          WRITE(45,'(A3,3G20.10)') ('LA ',DUMMYP%XYZCART(3*(J-1)+1:3*(J-1)+3),J=1,NATOMS)
       ELSE
          WRITE(45,'(A3,3G20.10)') ('LA ',DUMMYP%XYZ(3*(J-1)+1:3*(J-1)+3),J=1,NATOMS)
       ENDIF
       IF (I.EQ.NIM+1) EXIT
       DUMMYP => DUMMYP%NEXT
    ENDDO
    CLOSE(45)

    OPEN(UNIT=45,FILE='IMGENERGIES.OUT', STATUS='UNKNOWN')
    DUMMYP => FIRST%PREV
    DO I=0,NIM+1
       WRITE(45,'(I6,G20.10)') I+1, DUMMYP%E
       IF (I.EQ.NIM+1) EXIT
       DUMMYP => DUMMYP%NEXT
    ENDDO
    CLOSE(45)

  END SUBROUTINE DUMPGSPATH    

  SUBROUTINE OUTPUT(FINALX, FINALE, FINALTAN)
    ! OUTPUT THE FINAL COORDINATES AND ENERGY

    IMPLICIT NONE

    DOUBLE PRECISION, POINTER :: FINALX(:), FINALE(:), FINALTAN(:,:)
    INTEGER :: IM
    TYPE(IMGNODE), POINTER :: DUMMYP
    DOUBLE PRECISION :: TNORM

    DUMMYP => FIRST
    DO IM = 1,NIM
       FINALE(IM) = DUMMYP%E
       IF (DESMINT) THEN
          FINALX(3*NATOMS*(IM-1)+1:3*NATOMS*IM) = DUMMYP%XYZCART(:)
       ELSE
          FINALX(3*NATOMS*(IM-1)+1:3*NATOMS*IM) = DUMMYP%XYZ(:)
       ENDIF
       FINALTAN(1:NC, IM) = DUMMYP%TGT(:)
       DUMMYP => DUMMYP%NEXT
    ENDDO           
    RETURN
  END SUBROUTINE OUTPUT

  SUBROUTINE DUMPCOORDS(X, FNAME)
    IMPLICIT NONE
    CHARACTER (*) :: FNAME
    LOGICAL :: APPEND
    DOUBLE PRECISION :: X(3*NATOMS)
    INTEGER :: A

    ! GIVEN COORDINATE ARRAY X FOR A SINGLE MOLECULE, DUMP INTO FILE FNAME
    OPEN (UNIT = 55, FILE = FNAME, STATUS = 'UNKNOWN')
    WRITE(55,'(I6)') NATOMS
    WRITE(55,'(A)') ' '
    WRITE(55,'(A3,3F24.15)') ('AX ',X(3*(A-1)+1:3*(A-1)+3),A=1,NATOMS)
    CLOSE(55)
  END SUBROUTINE DUMPCOORDS

  SUBROUTINE CHECKENERGIES
    ! CALCULATE ENERGIES FOR POINTS ON THE CURRENT STRING
    ! IF ANY ARE TOO LARGE, RANDOMLY PERTURB THE IMAGES

    TYPE (IMGNODE), POINTER :: DUMMYP
    INTEGER :: IM, J
    DOUBLE PRECISION :: RMS, HARVEST, DPRAND

    DUMMYP => FIRST
    DO IM = 1,NIM
       IF (DESMINT) PREVDIH => DIHINFO(IM+1,:)
       CALL GETIMGPOT(DUMMYP,RMS)
       IF (-DUMMYP%E.LT.-HUGE(DUMMYP%E)) THEN
          IF (DESMINT) THEN
             PRINT*, 'ERROR: SHOULDNT HAVE INFINITE ENERGIES WHEN WORKING IN INTERNALS'
             STOP
          ENDIF

          ! ENERGY IS NAN OR INFINITE
          PRINT *, "IMAGE",IM," IS BAD! - TRYING TO LOWER IT'S ENERGY..."
          DO J=1,3*NATOMS ! CHANGING GEOMETRY RANDOMLY
             HARVEST=DPRAND()
             DUMMYP%XYZ(J) = DUMMYP%XYZ(J) + HARVEST*0.01
          ENDDO

          CALL GETIMGPOT(DUMMYP, RMS)

          IF (-DUMMYP%E.LT.-HUGE(DUMMYP%E)) THEN
             PRINT*, 'FAILED!'
             CALL TSUMMARY
             STOP
          ENDIF
       ENDIF

       DUMMYP => DUMMYP%NEXT
    ENDDO    
  END SUBROUTINE CHECKENERGIES

  SUBROUTINE GETIMGPOT(IMGP, RMS)
    ! RUN POTENTIAL FOR THE GIVEN STRING IMAGE, GIVEN XYZCART
    ! SET IMGP%GRAD, IMGP%GCART, IMGP%E
    ! RETURNS RMS

    IMPLICIT NONE

    TYPE(IMGNODE), POINTER :: IMGP
    DOUBLE PRECISION, INTENT(OUT) :: RMS
    DOUBLE PRECISION :: DUMINT(NINTC)
    LOGICAL :: NOCOOR, NODERV

    IF (DESMINT) THEN
       CALL POTENTIAL(IMGP%XYZCART, IMGP%E, IMGP%GCART, .TRUE., .FALSE., RMS, .FALSE., .FALSE.)

       NOCOOR = .TRUE.; NODERV = .FALSE.
       CALL TRANSFORM(IMGP%XYZCART,IMGP%GCART,DUMINT,IMGP%GRAD, &
                        & NINTC,3*NATOMS,NNZ,NOCOOR,NODERV,KD,INTEPSILON)
    ELSE
       CALL POTENTIAL(IMGP%XYZ, IMGP%E, IMGP%GRAD, .TRUE., .FALSE., RMS, .FALSE., .FALSE.)
    ENDIF

    RETURN
  END SUBROUTINE GETIMGPOT

END MODULE GROWSTRINGUTILS
