MODULE GSDATA
  
  USE COMMONS
  USE INTCOMMONS, ONLY : NINTC, DESMINT

  IMPLICIT NONE
  SAVE

  TYPE IMGNODE
     DOUBLE PRECISION, POINTER :: XYZ(:), GRAD(:), TGT(:), XINT(:)
     DOUBLE PRECISION, POINTER :: PREVGRAD(:), DIFF(:), PREVXYZ(:)
     DOUBLE PRECISION, POINTER :: XYZCART(:), GCART(:), PREVXCART(:)
     DOUBLE PRECISION :: TNORM, FNORM2, E !ENERGY
     DOUBLE PRECISION :: CHORD, ARC, ARCDIFF
     LOGICAL :: LF, RF ! IS THIS LEFT OR RIGHT FRONT?
     LOGICAL :: FREEZE
     INTEGER :: IND ! INDEX

     TYPE(IMGNODE), POINTER :: NEXT
     TYPE(IMGNODE), POINTER :: PREV
  ENDTYPE IMGNODE  

  DOUBLE PRECISION, PARAMETER :: TINY=1.0D-8

  ! KEYWORDS
  INTEGER :: GSUPDATE, MAXGROWSTEPS
  LOGICAL :: EVOLVESTRINGT
  LOGICAL :: CUBSPLT,FIXATMS, PREROTATE, DUMPGSALL = .FALSE.
  INTEGER :: TANTYPE
  DOUBLE PRECISION :: GSMXSTP, GSMAXTOTITD
  DOUBLE PRECISION :: GSGROWTOL, GSCONV, REPARAMTOL
  DOUBLE PRECISION :: GSIMGDENSITY, GSITERDENSITY, GSDGUESS
  DOUBLE PRECISION :: MAXLENPERIM
  LOGICAL :: NOLBFGS

  INTEGER :: NC ! NUMBER OF COORDINATES
  LOGICAL :: PTEST, JOINED, HESSGRAD, INTPTEST
  DOUBLE PRECISION :: STRINGLEN ! TOTAL STRING LENGTH
  DOUBLE PRECISION :: MAXLEN
  INTEGER :: NIM, NLIM, NRIM ! NUMBER OF IMAGES ON LEFT AND RIGHT SIDES
  INTEGER :: TIM ! TOTAL NUMBER OF IMAGES
  INTEGER :: MAXTOTSTEPS, TOTSTEPS ! TOTAL STEPS TAKEN SO FAR

  ! POINTERS TO THE FIRST NODE, LAST NODE, LEFT AND RIGHT FRONTIERS
  ! FIRST AND LAST POINT TO ACTUAL IMAGES NOT TERMINAL CONFIGURATIONS
  ! (IE: THERE'S ACTUALLY ONE NODE BEFORE FIRST AND ONE AFTER LAST)
  TYPE(IMGNODE), POINTER :: FIRST, LAST, LEFTFRONT, RIGHTFRONT

  DOUBLE PRECISION :: IMGD, ITERD ! CURRENT IMAGE AND ITERATION DENSITIES
  INTEGER :: MAXDROPS, M ! M IS THE LBFGS MEMORY
  DOUBLE PRECISION :: MAXERISE  

  INTEGER :: DUMPIND

CONTAINS
  SUBROUTINE KEYGSPRINT(VARIABLE)
    USE KEY, ONLY : DESMAXAVGE, DESMAXEJUMP
    IMPLICIT NONE
    LOGICAL :: VARIABLE ! IS THE NUMBER OF IMAGES VARIABLE?

    IF(VARIABLE) THEN
       WRITE(*,'(1X,A)') 'KEYGS> NUMBER OF IMAGES WILL VARY DEPENDING ON THE SEPARATION OF THE ENDPOINTS'
       WRITE(*,'(1X,A,F10.5)') 'KEYGS> STARTING ITERATION DENSITY PER IMAGE: ', GSITERDENSITY
    ELSE
       WRITE(*,'(1X,A,F10.5)') 'KEYGS> ITERATION DENSITY PER IMAGE: ', ITERD
       WRITE(*,'(1X,A,I4,A)') 'KEYGS> USING ', TIM, ' IMAGES'
    ENDIF

    IF (NOLBFGS) WRITE(*,'(1X,A)') 'KEYGS> NO LBFGS OPTIMIZATION. MOVE IMAGES ACCORDING TO FPERP'
    IF (EVOLVESTRINGT) WRITE(*,'(1X,A)') 'KEYGS> USING EVOLVING STRING METHOD.&
         & STRING WILL START OUT POPULATED WITH IMAGES'
    IF (CUBSPLT) WRITE(*,'(1X,A)') 'KEYGS> USING CUBIC SPLINE INTERPOLATION BETWEEN IMAGES'
    IF (FIXATMS) WRITE(*,'(1X,A)') 'KEYGS> PROJECTING OUT OVERALL TRANSLATION AND ROTATIONS &
         & BY FIXING COORDINATES 1-4 AND 7-8'
    IF(HESSGRAD) WRITE(*,'(1X,A)') 'KEYGS> USING METHOD DESCRIBED IN APPENDIX OF &
         & PETERS ET AL TO GENERATE THE NEWTON-RAPHSTON STEP; HESSIAN DETERMINED BY &
         & CHANGING GRADIENT RATHER THAN CHANGING PERPENDICULAR FORCE; TANGENTIAL &
         & COMPONENT PROJECTED AFTER MULTIPLYING BY HESSIAN'
    WRITE(*,'(1X,A,I2)') 'KEYGS> TANGENT TYPE: ', TANTYPE
    WRITE(*,'(1X,A,2F10.5)') 'KEYGS> REPARAMETRIZATION TOLERANCE, GROWTH TOLERANCE: ', &
         & REPARAMTOL, GSGROWTOL
    WRITE(*,'(1X,A,F10.5)') 'KEYGS> CONVERGENCE TOLERANCE: ', GSCONV
    WRITE(*,'(1X,A,F10.5,I4)') 'KEYGS> MAX STEP SIZE, LBFGS MEMORY: ', GSMXSTP, GSUPDATE
    WRITE(*,'(1X,A,I6)') 'KEYGS> MAX GROWTH STEPS: ', MAXGROWSTEPS 
    IF (DESMAXAVGE.LT.0.99*HUGE(1.0D0)) WRITE(*,'(1X,A,G20.10)') 'KEYGS> MAX AVERAGE ENERGY: ', DESMAXAVGE
    IF (DESMAXEJUMP.LT.0.99*HUGE(1.0D0)) WRITE(*,'(1X,A,G20.10)') 'KEYGS> MAX ENERGY JUMP PER IMAGE: ', DESMAXEJUMP
    IF(GSMAXTOTITD.GE.0) WRITE(*,'(1X,A,F10.1)') 'KEYGS> MAX TOTAL ITERATION DENSITY: ', GSMAXTOTITD    
  END SUBROUTINE KEYGSPRINT

  SUBROUTINE NEWNODE(P)
    
    IMPLICIT NONE    
    TYPE(IMGNODE), POINTER :: P
    
    ! MAKE A NEW IMGNODE AND RETURN A POINTER TO THAT NODE
    ! ASSUMES PREVIOUS ASSOCIATION OF P IS CHECKED ELSEWHERE AND IT'S OK TO ALLOCATE IT
    
    ALLOCATE(P)
    NULLIFY(P%NEXT, P%PREV, P%XYZ, P%GRAD, P%TGT, P%PREVGRAD, P%DIFF)
    
    ALLOCATE(P%XYZ(NC), P%GRAD(NC), P%TGT(NC), &
            & P%PREVGRAD(NC), P%DIFF(NC), P%PREVXYZ(NC))
    IF (DESMINT) ALLOCATE(P%XYZCART(3*NATOMS), P%GCART(3*NATOMS), P%PREVXCART(3*NATOMS))
       
    P%ARC = -1; P%CHORD = -1
    P%RF = .FALSE.; P%LF = .FALSE.
    P%FREEZE = .FALSE.

  END SUBROUTINE NEWNODE
  
  SUBROUTINE DELETENODE(P)
    IMPLICIT NONE
    
    TYPE(IMGNODE), POINTER :: P
    
    ! DEALLOCATE THE IMAGENODE TO WHICH P IS POINTING AND NULLIFY P
    
    DEALLOCATE(P%XYZ, P%GRAD, P%TGT, P%PREVGRAD, P%DIFF, P%PREVXYZ)
    IF (DESMINT) DEALLOCATE(P%XYZCART, P%GCART, P%PREVXCART)
    DEALLOCATE(P)
    NULLIFY(P)
    
  END SUBROUTINE DELETENODE
  
  SUBROUTINE EXTENDLEFT
    
    ! EXTEND LEFT SIDE OF STRING    

    LEFTFRONT%LF = .FALSE.

    CALL NEWNODE(LEFTFRONT%NEXT)    
    LEFTFRONT%NEXT%PREV => LEFTFRONT
    LEFTFRONT => LEFTFRONT%NEXT
    LEFTFRONT%NEXT => RIGHTFRONT
    RIGHTFRONT%PREV => LEFTFRONT

    LEFTFRONT%LF = .TRUE.
  END SUBROUTINE EXTENDLEFT
  
  SUBROUTINE EXTENDRIGHT   
    ! EXTEND RIGHT SIDE OF STRING    

    RIGHTFRONT%RF = .FALSE.

    CALL NEWNODE(RIGHTFRONT%PREV)
    RIGHTFRONT%PREV%NEXT => RIGHTFRONT
    RIGHTFRONT => RIGHTFRONT%PREV
    RIGHTFRONT%PREV => LEFTFRONT
    LEFTFRONT%NEXT => RIGHTFRONT

    RIGHTFRONT%RF = .TRUE.
  END SUBROUTINE EXTENDRIGHT

  SUBROUTINE DELETESTRING
    ! DELETE ENTIRE STRING, FROM FIRST%PREV TO LAST%NEXT

    IMPLICIT NONE
    TYPE(IMGNODE), POINTER :: DUMMYP

    DUMMYP => FIRST%PREV
    DO WHILE (ASSOCIATED(DUMMYP%NEXT))
       DUMMYP => DUMMYP%NEXT
       CALL DELETENODE(DUMMYP%PREV)
    ENDDO
    CALL DELETENODE(DUMMYP)

    NULLIFY(FIRST, LAST, RIGHTFRONT, LEFTFRONT)
  END SUBROUTINE DELETESTRING
END MODULE GSDATA

