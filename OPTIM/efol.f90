!   OPTIM: A PROGRAM FOR OPTIMIZING GEOMETRIES AND CALCULATING REACTION PATHWAYS
!   COPYRIGHT (C) 1999-2006 DAVID J. WALES
!   THIS FILE IS PART OF OPTIM.
!
!   OPTIM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
!   IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
!   THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
!   (AT YOUR OPTION) ANY LATER VERSION.
!
!   OPTIM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
!   BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
!   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
!   GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
!
!   YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
!   ALONG WITH THIS PROGRAM; IF NOT, WRITE TO THE FREE SOFTWARE
!   FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330, BOSTON, MA  02111-1307  USA
!
!   EIGENVECTOR-FOLLOWING OPTIMIZATION ALGORITHM.
!
MODULE MODEFOL
      IMPLICIT NONE
      CONTAINS
      SUBROUTINE EFOL(QTS,MFLAG,ITMAX,ENERGY,ITER,SMALL,PTEST,DIAG,INRIN)
      USE COMMONS
      USE KEY
      USE SYMINF
      USE MODHESS
      USE ZWK
      USE PORFUNCS
      USE MODCHARMM, ONLY: CHRMMT
      IMPLICIT NONE

!     INTEGER,INTENT(IN),OPTIONAL :: INRIN
      INTEGER,INTENT(IN) :: INRIN
      LOGICAL DONE, TSTEST, MINTEST, NRTEST, ZT(3*NATOMS),& 
     &        PZT(3*NATOMS), SDTEST, AWAY, MFLAG, TEST1, TEST2, PTEST
      INTEGER OMODE, K1, IMODE, I, J, INEG, IASSIGN, IM, ICOUNT, NATOMSSAVE, ISTAT,&
     &        J1, J2, INFO, ITMAX, ITER, FRAME, HORDER, INRSAVE, NEV
      DOUBLE PRECISION TEMPA(9*NATOMS), SSTPMAG, STPMAG, TPAR, &
     &   FOB(3*NATOMS), CSTEP(3*NATOMS), STEP(3*NATOMS), TEMP,&
     &   RMS, PROD, SUM, RAT1, RAT2, DELTASP, EOLD, EPER, ENERGY, AMASS,&
     &   VEC(3*NATOMS), AV(6), SMALL, Z0, QTS(3*NATOMS), OVEC(3), H1VEC(3), H2VEC(3),&
     &   DELE, SVH, DELTAT, RAT(3*NATOMS), AVG, DUMMY, INERTIA(3,3), &
     &   DIAGEXP(3*NATOMS), VNEW(3*NATOMS), E1, E2, SCALE, DELTAS, DOTOPT
!    &   VECX(3*NATOMS), VECY(3*NATOMS), VECZ(3*NATOMS), DUMMYX, DUMMYY, DUMMYZ
      DOUBLE PRECISION DIAG(3*NATOMS), PSTEP(3*NATOMS), PFOB(3*NATOMS)
      DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) :: QW
      LOGICAL KNOWE, KNOWG, KNOWH
      COMMON /KNOWN/ KNOWE, KNOWG, KNOWH
      CHARACTER(LEN=5) ZSYMSAVE
      COMMON /SYS/ ZSYMSAVE
!
!  ASSIGN ENOUGH MEMORY TO WORK FOR A BLOCKSIZE OF 32 TO BE POSSIBLE. 
!  THIS IS FOR DSYEVR.
!
      INTEGER ILWORK, LWORK, NFOUND, ISUPPZ(2*3*NATOMS)
      INTEGER IWORK(33*3*NATOMS)
      DOUBLE PRECISION WORK(33*3*NATOMS), ABSTOL

!     COMMON /VN/ VNEW(3*NATOMS)
      DOUBLE PRECISION LP,LP1,LP2
      CHARACTER ESTRING*87, GPSTRING*80, NSTRING*80, FSTRING*80
      COMMON /STRINGS/ ESTRING, GPSTRING, NSTRING, FSTRING
      LOGICAL PVFLAG
      COMMON /PVF/ PVFLAG
!
!  IVEC TELLS WHICH EIGENMODE TO FOLLOW (0,1- LOWEST EIGENVALUE,
!          2- NEXT LOWEST EIGENVALUE NOPT- HIGHEST EIGENVALUE)
!  INR=0 - MINIMISE
!  INR=1 - NEWTON-RAPHSON
!  INR=2 - TRANSITION STATE
!  INR=3 - MINIMISE BUT DON T DO ANY REORIENTATIONS (REACTION PATHS)
!          AND USE PSEUDO-THIRD DERIVATIVE CORRECTION.
!  INR=4 - TS SEARCH BUT AND USE PSEUDO-THIRD DERIVATIVE CORRECTION.
!  INR=5 - AS FOR INR=0 BUT MOVE TO PRINCIPAL AXES FIRST
!  INR=6 - STEEPEST DESCENT - MINIMISATION. 
!  INR=7 - STEEPEST DESCENT - CAN STOP AT A SADDLE POINT.
!  INR=8 - STEEPEST DESCENT/ASCENT SEARCH FOR A TRANSITION STATE
!  STPMAX IS THE MAXIMUM STEP SIZE 
!  ISTCRT = 0 USES DOT PRODUCT STEP LENGTH (IN CARTESIAN BASIS)
!           1 USES MAXIMUM CARTESIAN DISPLACEMENT AS CRITERION
!           2 USES MAXIMUM E/VECTOR DISPLACEMENT AS CRITERION
!           3 (SD) - TOTAL ARC LENGTH IS STPMAX(1)
!           THE ABOVE ALL USE A SINGLE TRUST RADIUS FOR DYNAMIC SCALING.  
!     10 SCALES IN THE EV BASIS USING A TRUST RADIUS FOR EACH DIRECTION. 
!
      LWORK=33*3*NATOMS
      ILWORK=33*3*NATOMS
      INRSAVE=INR
      INR=INRIN
!
! FOR CHARMM: UPDATE NONBONDED LIST AT THE START OF EACH OPTIMIZATION
!
      IF(CHRMMT) CALL UPDATENBONDS(QTS)
!
!  RESET MAXIMUM STEP SIZES IN CASE THIS ISN'T THE FIRST CALL TO EFOL.
!
      IF (DEBUG) PRINT '(A,G20.10)',' EFOL> RESETTING MAXIMUM STEP SIZES TO ',MXSTP
      DO J1=1,NOPT
         STPMAX(J1)=MXSTP
      ENDDO
!
!
!  THIS CALL TO GMETRY IS NEEDED FOR REDO RUNS WITH TIP POTENTIALS, OTHERWISE IF
!  AN EULER ANGLE GOES BAD THE STEP IS F*CKED.
!
      VEC(1:NOPT)=0.0D0
      CALL GMETRY(0,VEC,QTS)
      MFLAG=.FALSE.
      MINTEST=.FALSE.
      TSTEST=.FALSE.
      SDTEST=.FALSE.
      NRTEST=.FALSE.
      FRAME=1
      IF (ZSYMSAVE(1:1).EQ.'W') ALLOCATE(QW(9*(NATOMS/2)))
      IF (INR.EQ.0) THEN
         IF (PTEST) WRITE(*,10) 
         MINTEST=.TRUE.
      ELSE IF (INR.EQ.1) THEN
         IF (PTEST) WRITE(*,20) 
         NRTEST=.TRUE.
      ELSE IF (INR.EQ.2) THEN
         IF (PTEST) WRITE(*,10) 
         TSTEST=.TRUE.
      ELSE IF (INR.EQ.3) THEN
         IF (PTEST) WRITE(*,10)
         MINTEST=.TRUE.
      ELSE IF (INR.EQ.4) THEN
         IF (PTEST) WRITE(*,10)
         TSTEST=.TRUE.
      ELSE IF (INR.EQ.6) THEN
         IF (PTEST) WRITE(*,30)
         SDTEST=.TRUE.
         MINTEST=.TRUE.
         CONVU=0.0D0
      ELSE IF (INR.EQ.7) THEN
         IF (PTEST) WRITE(*,30)
         SDTEST=.TRUE.
         NRTEST=.TRUE.
         CONVU=0.0D0
      ELSE IF (INR.EQ.8) THEN
         IF (PTEST) WRITE(*,30)
         SDTEST=.TRUE.
         TSTEST=.TRUE.
         CONVU=0.0D0
      ELSE
         PRINT '(A,I8)','EFOL> INR VALUE NOT RECOGNISED,  SET TO 0 FROM ',INR
         INR=0
         MINTEST=.TRUE.
         IF (PTEST) WRITE(*,10) 
      ENDIF
10    FORMAT(' UPDATING STRUCTURE WITH EIGENVECTOR-FOLLOWING STEPS.')
20    FORMAT(' UPDATING STRUCTURE WITH PSEUDO-NEWTON-RAPHSON STEPS.')
30    FORMAT(' UPDATING STRUCTURE WITH QUADRATIC STEEPEST-DESCENT STEPS.')
      IF (MASST.AND.PTEST) PRINT*,'MASS WEIGHTING IS ACTIVE'
      ITER=1

40    IF (PTEST) PRINT*
      IF (PTEST) WRITE(*,60) ITER
60    FORMAT (' BEGINNING OF OPTIMIZATION CYCLE ', I4,'.',/&
     &' -------------------------------------')
      IF (PV.AND.(.NOT.BFGSSTEP)) THEN
         CALL POTENTIAL(QTS,ENERGY,VNEW,.FALSE.,.FALSE.,RMS,PTEST,.FALSE.)
         PVFLAG=.FALSE.
         CALL PVOPT(QTS,ENERGY,VNEW)
      ENDIF
      CALL POTENTIAL(QTS,ENERGY,VNEW,.TRUE.,.TRUE.,RMS,PTEST,.FALSE.)
      CALL DUMPP(QTS,ENERGY)
!
!  GDIIS STEP IF REQUIRED. THIS REALLY JUST DOESN'T WORK!
!
!     IF (DTEST) THEN
!        CALL  DIIS(NOPT,SVEC,ITER-1,QSAVE,VNEW,QTS,RMS,ENERGY,DONE)
!        IF (PTEST) WRITE(*,'(A,F20.10)') ' ENERGY BEFORE DIIS=',ENERGY
!        CALL POTENTIAL(Q,ENERGY,VNEW,.TRUE.,.TRUE.,RMS,PTEST,.FALSE.)
!        IF (PTEST) WRITE(*,'(A,F20.10)') ' ENERGY AFTER DIIS=',ENERGY
!     ENDIF
!
!  TRANSFORMATION TO MASS WEIGHTED COORDINATES IF REQUIRED.
!
      IF (MASST) CALL MASSWT(NATOMS,ATMASS,QTS,VNEW,.TRUE.)

      IF ((.NOT.VARIABLES).AND.(.NOT.(RINGPOLYMERT.AND.(RPSYSTEM(1:4).EQ.'AECK')))) THEN
         IF (ZSYM(NATOMS).EQ.'SY') THEN
            CALL SHIFTSTOCK(QTS,NATOMS)
         ELSEIF (RBAAT) THEN
            CALL SHIFTRIGID(QTS,NATOMS)
         ELSEIF (ZSYM(NATOMS).EQ.'TH') THEN
            CALL SHIFTHTH(QTS,NATOMS)
         ELSE
            CALL SHIFTH(QTS,.TRUE.,NOPT,NATOMS,ATMASS)
         ENDIF
      ENDIF
      IF (ISTCRT.NE.10) THEN
!        IF (PTEST) WRITE(*,'(A,4F20.10)') 'ENERGY,EOLD,ENERGY-EOLD,DELE=',ENERGY,EOLD,ENERGY-EOLD,DELE
         IF ((ENERGY-EOLD.NE.0.0D0).AND.(EOLD.NE.0.0D0)) THEN
            EPER=DABS((ENERGY-EOLD-DELE)/(ENERGY-EOLD))
            IF (EPER.GT.TRAD) THEN
               STPMAX(1)=MAX(STPMAX(1)/1.1D0,MINMAX)
            ELSE
               STPMAX(1)=MIN(STPMAX(1)*1.1D0,MAXMAX)
            ENDIF
            IF (PTEST) WRITE(*,'(3(A,F12.6))') ' MAXIMUM STEP SIZE=',STPMAX(1),' TRUST RADIUS=',TRAD,' CALCULATED RATIO=', EPER
         ENDIF
      ENDIF
!
!  DIAGONALIZE THE RELEVANT HESSIAN AND DETERMINE THE NUMBER OF
!  NEGATIVE EIGENVALUES.
!
!  DSYEV AND DSYEVR ARE SUPPOSED TO ORDER THE EIGENVALUES AND CORRESPONDING 
!  EIGENVECTORS IN ASCENDING ORDER, BUT WE NEED THE EIGENVALUES
!  IN DESCENDING ORDER. 
!

!     IF (LANCZOST) THEN
!        IF (PTEST) WRITE(*,55) ACCLAN, SHIFTLAN
!55      FORMAT(' MATRIX DIAGONALISATION BY THE LANCZOS METHOD, ACCURACY=',E12.5,' SHIFT=',E12.5)
!C       CALL LANCZOS(NOPT,HESS,DIAG,1.0D0,-1.0D0,NFOUND)
!        IF (NFOUND.NE.NOPT) THEN
!           IF (PTEST) WRITE(*,56) NFOUND
!56         FORMAT(' *** WARNING *** ONLY ',I4,' EIGENVALUES FOUND BY LANCZOS')
!           IF (ISTCRT.EQ.10) PRINT*,' SCALE 2 IS RECOMMENDED!'
!        ENDIF
!     ELSE
!        NFOUND=NOPT

      IF ((NUSEEV.GT.0).AND.(NUSEEV.LT.NOPT)) THEN
         CALL DSYEVR('V','I','U',NOPT,HESS,SIZE(HESS,1),0.0D0,1.0D0,1,NUSEEV,ABSTOL,NFOUND,DIAG, &
     &                        ZWORK,3*NATOMS,ISUPPZ,WORK, &
     &                        LWORK, IWORK, ILWORK, INFO )
              IF (INFO.NE.0) PRINT*,'WARNING - INFO=',INFO,' IN DSYEVR'
!             PRINT '(A,F15.5,I10)','OPTIMAL AND ACTUAL VALUE OF LWORK=',WORK(1),LWORK
!             PRINT '(A,I10,I10)','OPTIMAL AND ACTUAL VALUE OF ILWORK=',IWORK(1),ILWORK
!
!  PUT THE NUSEEV EIGENVALUES AND EIGENVECTORS INTO THE SAME PLACES AS THEY ARE EXPECTED TO
!  BE FOR FULL DIGAGONALISATION.
!  NOTE THE DIFFERENT ORDERING! WE HAVE VALUES FOR THE LOWEST NUSEEV EIGENVALUES
!  IN ELEMENTS 1:NUSEEV, BUT WE WANT TO PUT THEM IN NOPT-NUSEEV+1:NOPT
!  DO THIS USING DUMMY DIAG VALUES AND SORTING.
!
         HESS=0.0D0 
         DO I=1,NUSEEV
            DO J=1,NOPT
               HESS(J,I)=ZWORK(J,I)
            ENDDO
         ENDDO
         NEV=NUSEEV
         DIAG(NEV+1:NOPT)=1.0D100 ! PUT NON-EXISTENT DUMMY EIGENVALUES IN DUMMY ELEMENTS, THEN SORT
!        CALL EIGENSORT_VAL_ASC(DIAG,HESS,NOPT,3*NATOMS)
      ELSE
         CALL DSYEV('V','U',NOPT,HESS,SIZE(HESS,1),DIAG,TEMPA,9*NATOMS,INFO)
         IF (INFO.NE.0) PRINT*,'WARNING - INFO=',INFO,' IN DSYEV'
!
!  THE SORT ORDER GIVEN BY DSYEV SEEMS TO VARY WITH PLATFORM!
! 
         IF (DIAG(1).LT.DIAG(NOPT)) CALL EIGENSORT_VAL_ASC(DIAG,HESS,NOPT,3*NATOMS)
         NEV=NOPT
      ENDIF
!
!  FIND EIGENVALUE DEMANDED BY VALUE OF IVEC (FIRST PASS ONLY)
!  AND COUNT NUMBER OF NEGATIVE EIGENVALUES IN HESSIAN (ALL PASSES).
!
      DO J=1,NOPT
         ZT(J)=.TRUE.
      ENDDO
!
!  DETERMINE THE ZERO EIGENVALUES. ASSUME THE ZEROS HAVE BEEN
!  SHIFTED TO THE TOP OF THE RANGE.
!  HOWEVER, SOME SYSTEMS SHOULD HAVE THREE ZEROS, SOME NONE
!  AT ALL, AND LINEAR SYSTEMS ONE LESS THEN USUAL.
!  ROTATING SYSTEMS HAVE ONE!
!
      IF (ZSYM(1).EQ.'TH') THEN
         NZERO=3
         ZT(1)=.FALSE.
         ZT(2)=.FALSE.
         ZT(3)=.FALSE.
      ELSEIF (ZSYM(1).EQ.'SY') THEN
         NZERO=(NATOMS/2)+6
         DO J1=1,NZERO
            ZT(J1)=.FALSE.
         ENDDO
      ELSE IF (PULLT.OR.EFIELDT) THEN
         NZERO=4
         ZT(1)=.FALSE.
         ZT(2)=.FALSE.
         ZT(3)=.FALSE.
         ZT(4)=.FALSE.
      ELSE IF ((EYTRAPT.OR.(ZSYM(1).EQ.'BE')).AND.(.NOT.TWOD)) THEN
         NZERO=3
         ZT(1)=.FALSE.
         ZT(2)=.FALSE.
         ZT(3)=.FALSE.
      ELSE IF (ZSYM(1).EQ.'CK') THEN
         DO J1=1,NATOMS+1
            ZT(J1)=.FALSE.
         ENDDO
         NZERO=NATOMS+1
      ELSE IF (RTEST) THEN
         ZT(1)=.FALSE.
         ZT(2)=.FALSE.
         NZERO=2
         IF (JZ.NE.0.0D0) THEN
            ZT(3)=.FALSE.
            ZT(4)=.FALSE.
            NZERO=4
         ENDIF
      ELSE IF (BULKT) THEN
         ZT(1)=.FALSE.
         ZT(2)=.FALSE.
         ZT(3)=.FALSE.
         NZERO=3
         IF (TWOD) THEN
            DO J1=1,NATOMS+2
               ZT(J1)=.FALSE.
            ENDDO
            NZERO=NATOMS+2
         ENDIF
      ELSE IF ((FPGRP.EQ.'DXH'.OR.FPGRP.EQ.'CXV').AND.(ZSYM(NATOMS)(1:1).NE.'W')) THEN
         ZT(1)=.FALSE.
         ZT(2)=.FALSE.
         ZT(3)=.FALSE.
         ZT(4)=.FALSE.
         ZT(5)=.FALSE.
         NZERO=5
      ELSE IF (VARIABLES) THEN
         DO J1=1,NZERO
            ZT(J1)=.FALSE.
         ENDDO
      ELSE IF (RINGPOLYMERT) THEN
         DO J1=1,NZERO
            ZT(J1)=.FALSE.
         ENDDO
      ELSE IF (FIELDT) THEN
         ZT(1)=.FALSE.
         ZT(2)=.FALSE.
         ZT(3)=.FALSE.
         NZERO=3
      ELSE IF (TWOD) THEN
         IF (EYTRAPT.OR.(ZSYM(1).EQ.'BE')) THEN
            DO J1=1,NATOMS+1
               ZT(J1)=.FALSE.
            ENDDO
            NZERO=NATOMS+1
         ELSE
            DO J1=1,NATOMS+3
               ZT(J1)=.FALSE.
            ENDDO
            NZERO=NATOMS+3
         ENDIF
      ELSE IF (FREEZE) THEN
         NZERO=3*NFREEZE
         DO J1=1,NZERO
            ZT(J1)=.FALSE.
         ENDDO
      ELSEIF (GBT .OR. GBDT .OR. (PYGT .AND. UNIAXT).OR.((PYGPERIODICT.OR.PYBINARYT).AND.UNIAXT).OR.STOCKAAT) THEN

         IF (EFIELDT) THEN
            NZERO = NATOMS/2 + 4
         ELSE
            NZERO = NATOMS/2 + 6 
         ENDIF
         DO J1=1,NZERO
            ZT(J1)=.FALSE.
         ENDDO
      
      ELSE
         ZT(1)=.FALSE.
         ZT(2)=.FALSE.
         ZT(3)=.FALSE.
         ZT(4)=.FALSE.
         ZT(5)=.FALSE.
         ZT(6)=.FALSE.
         NZERO=6
      ENDIF
      DO J1=1,NOPT-NEV
         ZT(J1)=.FALSE.
      ENDDO

      IF (VALUEST.AND.(MOD(ITER-1,NVALUES).EQ.0)) THEN
         IF (PTEST) WRITE(*,'(A)') ' EIGENVALUES OF THE HESSIAN MATRIX:'
         IF (PTEST) WRITE (*,'(6(F12.5,1X))') (DIAG(I),I=MAX(NZERO+1,NOPT-NEV+1),NOPT)
      ENDIF
      IF (VECTORST.AND.(MOD(ITER-1,NVECTORS).EQ.0)) THEN
         IF (PTEST) WRITE(*,'(A)') ' EIGENVECTORS OF THE HESSIAN MATRIX:'
         CALL HESSOUT(NOPT,NOPT,3*NATOMS,1)
      ENDIF
!     PRINT '(A)','PREDICTED ZERO EIGENVECTORS FOR THOMSON'
!     VECX(1:3*NATOMS)=0.0D0; VECY(1:3*NATOMS)=0.0D0; VECZ(1:3*NATOMS)=0.0D0
!     DO J1=1,3*NATOMS,2
!        VECX(J1)=SIN(QTS(J1+1))
!        VECY(J1)=COS(QTS(J1+1))
!     ENDDO
!     DO J1=2,3*NATOMS,2
!        IF (SIN(QTS(J1)).NE.0.0D0) THEN
!           VECX(J1)= COS(QTS(J1-1))*COS(QTS(J1))/SIN(QTS(J1-1))
!           VECY(J1)=-COS(QTS(J1-1))*SIN(QTS(J1))/SIN(QTS(J1-1))
!        ENDIF
!        VECZ(J1)=1.0D0   
!     ENDDO
!     CALL VECNORM(VECX,3*NATOMS)
!     CALL VECNORM(VECY,3*NATOMS)
!     CALL VECNORM(VECZ,3*NATOMS)
!     PRINT '(3F15.6)',(VECX(J1),VECY(J1),VECZ(J1),J1=1,3*NATOMS)
!     DO J1=1,3*NATOMS
!        DUMMYX=0.0D0
!        DUMMYY=0.0D0
!        DUMMYZ=0.0D0
!        DO J2=1,3*NATOMS
!           DUMMYX=DUMMYX+HESS(J2,J1)*VECX(J2)
!           DUMMYY=DUMMYY+HESS(J2,J1)*VECY(J2)
!           DUMMYZ=DUMMYZ+HESS(J2,J1)*VECZ(J2)
!        ENDDO
!        PRINT '(A,I6,A,3F20.10)','X,Y,Z DOT PRODUCTS FOR EIGENVECTOR ',J1,' ARE ',DUMMYX,DUMMYY,DUMMYZ
!     ENDDO

      IF (EVCUT.NE.0.0D0) THEN
         DO J1=1,NOPT
            IF (DABS(DIAG(J1)).LT.EVCUT) THEN
               IF (PTEST) PRINT*,'EIGENVALUE CUTOFF - NO STEP WILL BE TAKEN FOR MODE ',J1
               ZT(J1)=.FALSE.
            ENDIF
         ENDDO
      ENDIF
!
!  COUNT NEGATIVE EIGENVALUES AND FIND THE SMALLEST.
!
      INEG=0
      SMALL=1.0D20
      DO J=NOPT,NOPT-NEV+1,-1
         IF (ZT(J)) THEN
            IF (DIAG(J).LT.0.0D0) INEG=INEG+1
            IF (DIAG(J).LT.SMALL) THEN
               SMALL=DIAG(J)
            ELSE
               IF (DIAG(J).GT.0.0D0) GOTO 70
            ENDIF
         ENDIF
      ENDDO
70    CONTINUE

      IF (KEEPINDEX.AND.(ITER.EQ.1)) THEN
         HINDEX=INEG
         IF (PTEST) WRITE(*,'(A,I4)') ' SEARCHING FOR A SADDLE WITH HESSIAN INDEX=',HINDEX
      ENDIF
!
!  FOR TRANSITION STATE SEARCHES SET IMODE TO THE APPROPRIATE MODE TO BE
!  FOLLOWED. IF IVEC=0 THIS IS THE SOFTEST MODE FOR EACH STEP. 
!  IMODE NEEDS TO BE SET HERE FOR:
!  (A) TSTEST AND ITER=1,
!  (B) TSTEST AND ITER>1 IF IVEC=0.
!  (C) MINTEST OR SDTEST AND IVEC NOT 0.
!
      IMODE=0
      IASSIGN=0
      DONE=.FALSE.
      DO J=NOPT,1,-1
         IF (ZT(J)) THEN
            IASSIGN=IASSIGN+1
            IF ((IASSIGN.GE.ABS(IVEC)).AND.(.NOT.(DONE))) THEN
               IMODE=J
               DONE=.TRUE.
            ENDIF
         ENDIF
      ENDDO
!
!  ON LATER PASSES, DETERMINE OVERLAP BETWEEN HESSIAN EIGENVECTORS
!  AND VEC (SAVED FROM PREVIOUS STEP) FOR TRANSITION STATE SEARCHES.
!
      IF (ITER.GT.1.AND.TSTEST.AND.(IVEC.NE.0)) THEN
         Z0=0.0D0
         DO I=1,NOPT
            SVH=DOTOPT(VEC,HESS(1,I),NOPT)
            IF ((DABS(SVH).GT.Z0).AND.(ZT(I))) THEN
               Z0=DABS(SVH)
               IM=I
            ENDIF
         ENDDO

         IF (PTEST) WRITE(*,100) Z0,IM,DIAG(IM),SMALL
100      FORMAT(' LARGEST OVERLAP=',F8.5,' FOR VECTOR ',I4,' EIGENVALUE=',F14.7,' SMALLEST EIGENVALUE=',F14.7)
         IF (Z0.LT.0.8D0) THEN
            IF (IM.EQ.OMODE) THEN
               IF (PTEST) PRINT*,'SMALL OVERLAP, BUT WITH SAME EIGENVECTOR'
            ELSE IF (IM.GT.OMODE) THEN
               IF (PTEST) WRITE(*,'(A)') ' SMALL OVERLAP WITH SOFTER EIGENVECTOR ACCEPTED'
            ELSE
               IF (ZT(OMODE)) THEN
                  IF (PTEST) PRINT*,'SMALL OVERLAP, FOLLOW PREVIOUS MODE'
                  IM=OMODE

!                 IF (PTEST) PRINT*,'SMALL OVERLAP - BACKTRACKING'
!                 DO J1=1,NOPT
!                    CSTEP(J1)=CSTEP(J1)/2.0D0
!                    PSTEP(J1)=PSTEP(J1)/2.0D0
!                    STPMAX(J1)=MAX(MINMAX,STPMAX(J1)/2.0D0)
!                    FOB(J1)=PFOB(J1)
!                    ZT(J1)=PZT(J1)
!                    QTS(J1)=QTS(J1)-CSTEP(J1)
!                 ENDDO
!                 IF (ALLOCATED(QW)) DEALLOCATE(QW)
!                 RETURN

               ENDIF
            ENDIF
!CC          IF (PTEST) PRINT*,'SMALL OVERLAP - SWITCH TO SOFTSET MODE'
!CC          IVEC=0
!CC          IM=IMODE
         ENDIF

         IF (IM.LT.OMODE-8) THEN
            IF (PTEST) PRINT*,'RESETTING MODE FOLLOWED TO ',OMODE
            IM=OMODE
         ENDIF
!
!  THIS SHOULD SAVE US FROM FOLLOWING A VECTOR WITH A ZERO EIGENVALUE.
!  IMODE IS SET TO A MODE WITH NON-ZERO EIGENVALUE BEFORE WE ENTER THIS BLOCK.
!
         IF (ZT(IM)) THEN
            IMODE=IM
         ELSE IF (ZT(OMODE)) THEN
            IMODE=OMODE
         ENDIF
         OMODE=IMODE
         IF (PTEST) PRINT*,'MODE TO BE FOLLOWED=',IMODE
      ELSE
         OMODE=IMODE
      ENDIF

      DO I=1,NOPT
         FOB(I)=0.0D0
         DO J = 1, NOPT
            FOB(I)=FOB(I)+VNEW(J)*HESS(J,I)
         ENDDO
      ENDDO
!
!  CALCULATE THE LOCALISATION INDEX FOR EACH PAIR OF NORMAL MODES AND GET THE MEAN AND
!  STANDARD DEVIATION. THE SUM IS ONLY OVER EIGENVECTORS WITH NEGATIVE (NONZERO) EIGENVALUES.
!
!     DUMMY1=0.0D0
!     DUMMY2=0.0D0
!     DUMMY5=0.0D0
!     DUMMY6=0.0D0
!     NCONTRIB=0
!     NPCONTRIB=0
!     PDUMMY1=0.0D0
!     NPLUS=0
!     NMINUS=0
!     DO J1=1,NOPT
!        DUMMY3=0.0D0
!        DUMMY4=0.0D0
!        DO J3=1,NOPT
!           DUMMY3=DUMMY3+HESS(J3,J1)**2
!           DUMMY4=DUMMY4+HESS(J3,J1)**4
!        ENDDO
!        IF ((DIAG(J1).LT.0.0D0).AND.ZT(J1)) THEN
!           DUMMY5=DUMMY5+DUMMY3**2/DUMMY4
!           NMINUS=NMINUS+1
!           DO J2=J1+1,NOPT
!              IF ((DIAG(J2).LT.0.0D0).AND.ZT(J2)) THEN
!                 DUMMY3=0.0D0
!                 DO J3=1,NOPT
!                    DUMMY3=DUMMY3+ABS(HESS(J3,J1)*HESS(J3,J2))
!                 ENDDO
!                 DUMMY1=DUMMY1+DUMMY3
!                 DUMMY2=DUMMY2+DUMMY3**2
!                 NCONTRIB=NCONTRIB+1
!              ENDIF
!           ENDDO
!        ELSE IF (ZT(J1)) THEN
!           NPLUS=NPLUS+1
!           DUMMY6=DUMMY6+DUMMY3**2/DUMMY4
!           DO J2=J1+1,NOPT
!              IF ((DIAG(J2).GT.0.0D0).AND.ZT(J2)) THEN
!                 DUMMY3=0.0D0
!                 DO J3=1,NOPT
!                    DUMMY3=DUMMY3+ABS(HESS(J3,J1)*HESS(J3,J2))
!                 ENDDO
!                 PDUMMY1=PDUMMY1+DUMMY3
!                 NPCONTRIB=NPCONTRIB+1
!              ENDIF
!           ENDDO
!        ENDIF
!     ENDDO
!     PRINT*,'INEG*(INEG-1)/2,NCONTRIB=',INEG*(INEG-1)/2,NCONTRIB
!     IF (NCONTRIB.GT.1) THEN
!        WRITE(*,'(A,I9,5G20.10)') 'LOCALISATION ',
!    1              INEG,DUMMY1/NCONTRIB,SQRT((DUMMY2-DUMMY1**2/NCONTRIB)/(NCONTRIB-1)),
!    2              DUMMY5/MAX(1,NMINUS),DUMMY6/NPLUS,PDUMMY1/NPCONTRIB
!     ELSE IF (NCONTRIB.GT.0) THEN
!        WRITE(*,'(A,I9,5G20.10)') 'LOCALISATION ',
!    1              INEG,DUMMY1/NCONTRIB,0.0D0,DUMMY5/MAX(1,NMINUS),DUMMY6/NPLUS,PDUMMY1/NPCONTRIB
!     ELSE
!        WRITE(*,'(A,I9,5G20.10)') 'LOCALISATION ',
!    1              INEG,0.0D0,0.0D0,DUMMY5/MAX(1,NMINUS),DUMMY6/NPLUS,PDUMMY1/NPCONTRIB
!     ENDIF
!
!  FIND THE VECTOR OF STPMAX VALUES BY COMPARING PREDICTED AND
!  ACTUAL SECOND DERIVATIVES FOR EACH EIGENVECTOR.
!
      IF (ITER.EQ.1) THEN
         DO J1=1,NOPT
            RAT(J1)=0.0D0  !  INITIALISE RAT - OTHERWISE WE CAN;T PRINT IT.
         ENDDO
      ENDIF
      IF ((ITER.GT.1).AND.(ISTCRT.EQ.10)) THEN
!         K1=-1
!         DO J1=1,10
!90          K1=K1+1
!            IF (.NOT.ZT(NOPT-K1)) GOTO 90
!            K2=-1
!            DO J2=1,10
!91             K2=K2+1
!               IF (.NOT.PZT(NOPT-K2)) GOTO 91
!C              TMAT(J2,J1)=ABS(( FOB(NOPT-K1)-PFOB(NOPT-K2))/(PSTEP(NOPT-K2)*DIAG(NOPT-K1))-1.0D0)
!               TMAT(J2,J1)=MIN( ABS(( FOB(NOPT-K1)-PFOB(NOPT-K2))/(PSTEP(NOPT-K2)*DIAG(NOPT-K1))-1.0D0),
!     1                          ABS((-FOB(NOPT-K1)-PFOB(NOPT-K2))/(PSTEP(NOPT-K2)*DIAG(NOPT-K1))-1.0D0) )
!            ENDDO
!         ENDDO
!         IF (PTEST) WRITE(*,'(A)') 'MATRIX OF TRUST RATIOS FOR FIVE SOFTEST NON-ZERO MODES:'
!         IF (PTEST) WRITE(*,'(10G12.4)') ((TMAT(K2,K1),K2=1,10),K1=1,10)
            
         DO J1=1,NOPT
            TEMPA(J1)=STPMAX(J1)
         ENDDO
         K1=0
         DO J1=1,NOPT
            RAT(J1)=0.0D0
            IF (ZT(J1)) THEN
150            K1=K1+1
!              IF (PTEST) PRINT*,'K1,PZT,PFOB,PSTEP=',K1,PZT(K1),PFOB(K1),PSTEP(K1)
               IF ((.NOT.PZT(K1)).AND.(K1.LT.NOPT)) GOTO 150
               IF (DABS(PSTEP(K1)).GT.1.0D-40) THEN
!
!  ALLOW FOR POSSIBLE PHASE CHANGE IN THE EIGENVECTOR. JUST TAKE THE SMALLER VALUE.
!  BUG FIX 5/2/08 - FACTOR OF 2 IN THE RATIOS ! DJW
!
                  RAT1=DABS(( FOB(J1)-PFOB(K1))/(2*DIAG(J1)*PSTEP(K1))-1.0D0)
                  RAT2=DABS((-FOB(J1)-PFOB(K1))/(2*DIAG(J1)*PSTEP(K1))-1.0D0)
                  RAT(J1)=MIN(RAT1,RAT2)
!                 IF (PTEST) WRITE(*,'(A,2I4,5E15.7)') 'J1,K1,FOB,PFOB,PSTEP,RAT1,DIAG=', 
!     &                                                 J1,K1,FOB(J1),PFOB(K1),PSTEP(K1),RAT1,DIAG(J1)
!                 IF (RAT(J1).GT.1.0D0) WRITE(*,'(A,2I4,5E15.7)') 'J1,K1,FOB,PFOB,PSTEP,RAT1,DIAG=',
!     &                                                            J1,K1,FOB(J1),PFOB(K1),PSTEP(K1),RAT1,DIAG(J1)
                  IF (RAT(J1).GT.TRAD) THEN
                     STPMAX(J1)=MAX(TEMPA(K1)/1.11D0,MINMAX)
                  ELSE
                     IF (MASST) THEN
                        SUM=0
                        DO J2=1,NATOMS
                           SUM=SUM+ATMASS(J2)
                        ENDDO
                        AVG=SQRT(SUM/NATOMS)
!                       IF (PTEST) PRINT *,'THE AVERAGE IS',AVG
                        STPMAX(J1)=MIN(MAX(TEMPA(K1)*1.09D0,MINMAX),AVG*MAXMAX)
                     ELSE
                        STPMAX(J1)=MIN(MAX(TEMPA(K1)*1.09D0,MINMAX),MAXMAX)
                     ENDIF
                  ENDIF
               ELSE
                  STPMAX(J1)=MAX(TEMPA(K1),MINMAX)
               ENDIF
            ELSE
            ENDIF
         ENDDO
      ENDIF

      IF (PGRAD.AND.(MOD(ITER-1,NGRADIENTS).EQ.0)) THEN
         IF (PTEST) WRITE(*,160)
160      FORMAT(' GRADIENTS ALONG HESSIAN EIGENVECTORS: ')
         IF (PTEST) WRITE(*,'(6(F12.5,1X))')(FOB(I),I=MAX(NZERO+1,NOPT-NEV+1),NOPT)
      ENDIF
      IF (PTEST) WRITE(*,170)INEG
170   FORMAT(' NUMBER OF NEGATIVE EIGENVALUES=',I3)
      IF (PTEST) WRITE(NSTRING,170)INEG
      IF (DUMPV) CALL VDUMP(DIAG,ZT,NOPT,3*NATOMS)
!
! CALCULATE STEP:
!
      SUM=0.0D0
      PROD=0.0D0
      DO J1=1,NOPT
         IF (ZT(J1)) THEN
            SUM=SUM+DABS(DIAG(J1))
            IF (DIAG(J1).GT.0.0D0) PROD=PROD+DLOG(DIAG(J1))
         ENDIF
      ENDDO
      IF ((FPGRP.EQ.'DXH'.OR.FPGRP.EQ.'CXV').AND.(ZSYM(NATOMS)(1:1).NE.'W')) THEN
         SUM=SUM/MAX(NOPT-5,1)
      ELSE
         SUM=SUM/MAX(NOPT-6,1)
      ENDIF
      IF (PTEST) WRITE(*,235) SUM,PROD
235   FORMAT(' MEAN MODULUS OF POSITIVE HESSIAN EIGENVALUES=',4X,F20.10,/,&
     &       ' LOG PRODUCT OF POSITIVE HESSIAN EIGENVALUES =',4X,F20.10)
      IF (TSTEST) THEN
         IF (HINDEX.GT.1) THEN
            IF (PTEST) PRINT '(A,I8,A)',' EFOL> ',HINDEX,' MODES WILL BE SEARCHED UPHILL'
         ELSE
            IF (PTEST) WRITE(*,210) IMODE,DIAG(IMODE)
210         FORMAT(' MODE ',I4,' WILL BE SEARCHED UPHILL. EIGENVALUE=',4X,F19.10)
         ENDIF
!
! SAVE EIGENVECTOR BEING FOLLOWED FOR USE ON NEXT STEP
!
         DO I=1,NOPT
            VEC(I)=HESS(I,IMODE)
         ENDDO
!
!  IF THE CONVERGENCE CRITERIA ARE MET THEN RETURN NOW.
!
      ENDIF
      TEMP=-1.0D0
      RMS=0.0D0
      DO J1=1,NOPT
         RMS=RMS+VNEW(J1)**2
      ENDDO
      RMS=DSQRT(RMS/NOPT)
!
!  TAKE A STEP AWAY FROM A STATIONARY POINT ALONG THE APPROPRIATE
!  HESSIAN EIGENVECTOR. THIS ENABLES US TO START FROM CONVERGED MINIMA.
!  DISTINGUISH THE CASE WHERE WE WANT TO TAKE A VERY SMALL STEP AWAY
!  FROM A TRANSITION STATE FROM OTHERS WHERE WE WANT A BIG DISPLACEMENT
!  TO GET UNSTUCK. 
!
      AWAY=.FALSE.
      IF (RMS.LT.PUSHCUT) THEN
         IF (TSTEST.AND.(INEG.NE.HINDEX)) THEN
            IF (MOD(ITER-1,4).EQ.0) AWAY=.TRUE.
         ELSE IF (MINTEST.AND.(INEG.NE.0)) THEN
            IF (MOD(ITER-1,4).EQ.0) AWAY=.TRUE.
         ENDIF
      ENDIF
      IF ((.NOT.SDTEST).OR.AWAY) THEN
!
!  EF DETERMINATION OF STEPS
!
         ICOUNT=0
         DO I=NOPT,1,-1
            STEP(I)=0.0D0
            IF (ZT(I)) THEN
               IF (DABS(DIAG(NZERO+1)/MAX(DABS(DIAG(I)),1.0D-10)).GT.TEMP) TEMP=DABS(DIAG(NZERO+1)/MAX(DABS(DIAG(I)),1.0D-10)) 
               LP1=DABS(DIAG(I))/2.0D0
               IF (MASST) THEN
                  SUM=0
                  DO J2=1,NATOMS
                     SUM=SUM+ATMASS(J2)
                  ENDDO
                  AVG=SUM/NATOMS
                  LP2=1.0D0 + 4.0D0*((FOB(I)/DIAG(I))**2)/AVG
               ELSE
                  LP2=1.0D0 + 4.0D0*(FOB(I)/DIAG(I))**2
               ENDIF
               LP=LP1*(1.0D0+DSQRT(LP2))
               IF ((I.EQ.IMODE).AND.(TSTEST)) THEN
                  LP=-LP
               ELSE IF (TSTEST.AND.(ICOUNT.LT.HINDEX).AND.(HINDEX.GT.1)) THEN
                  IF (PTEST) WRITE(*,'(A,I4,A,4X,F19.10)') ' MODE ',I,' WILL BE SEARCHED UPHILL. EIGENVALUE=',DIAG(I)
                  LP=-LP
               ENDIF
!
!  PSEUDO-NEWTON-RAPHSON
!
               IF (NRTEST) LP=LP*DIAG(I)/DABS(DIAG(I))
               STEP(I)=-FOB(I)/LP
!
!  MINIMISE TO REMOVE ZERO EIGENVALUES ! DJW
!
!              IF (ABS(DIAG(I)).LT.1.0D-1) THEN
!                 STEP(I)=-FOB(I)*STPMAX(I)/ABS(FOB(I))
!                 PRINT '(A,I8,A,G20.10)',' EFOL> MINIMISING FOR MODE ',I,' STEP=',STEP(I)
!              ENDIF
               ICOUNT=ICOUNT+1
            ENDIF
         ENDDO
!
!  TAKE ACTION IF WE ARE HEADING FOR A STATIONARY POINT OF THE WRONG INDEX.
!
         IF (AWAY) THEN
            IF (TSTEST) THEN
               IF (INEG.EQ.0) THEN
                  IF ((IVEC.GE.0).AND.PTEST) PRINT*,'STEPPING AWAY FROM MINIMUM ALONG MODE ',IMODE,' + DIRECTION'
                  IF ((IVEC.LT.0).AND.PTEST) PRINT*,'STEPPING AWAY FROM MINIMUM ALONG MODE ',IMODE,' - DIRECTION'
                  IF (PUSHOFF.NE.0.0D0) THEN
                     STEP(IMODE)=PUSHOFF
                  ELSE
                     STEP(IMODE)=STPMAX(IMODE)/10.0D0
                  ENDIF
                  IF (IVEC.LT.0) STEP(IMODE)=-STEP(IMODE)
               ELSE 
!
!  STEP OFF ALONG ALL THE MODES WITH NEGATIVE EIGENVALUE EXCEPT THE SMALLEST.
!
                  IF (IVEC.EQ.0) THEN
                     DO J1=1,NOPT-1
                        IF (ZT(J1).AND.(DIAG(J1).LT.0.0D0)) THEN
                           IF (PTEST) PRINT*,'STEPPING AWAY FROM HIGHER ORDER SADDLE ALONG MODE ',J1
                           IF (PUSHOFF.NE.0.0D0) THEN
                              STEP(J1)=PUSHOFF
                           ELSE
                              STEP(J1)=STPMAX(J1)/10.0D0
                           ENDIF
                        ENDIF
                     ENDDO
                  ELSE
!
!  STEP OFF ONLY ALONG THE MODE SPECIFIED BY IMODE.
!
                     IF ((IVEC.GE.0).AND.PTEST) PRINT*,'STEPPING AWAY FROM SADDLE ALONG MODE ',IMODE,' + DIRECTION'
                     IF ((IVEC.LT.0).AND.PTEST) PRINT*,'STEPPING AWAY FROM SADDLE ALONG MODE ',IMODE,' - DIRECTION'
                     IF (PUSHOFF.NE.0.0D0) THEN
                        STEP(IMODE)=PUSHOFF
                     ELSE
                        STEP(IMODE)=STPMAX(IMODE)/10.0D0
                     ENDIF
                     IF (IVEC.LT.0) STEP(IMODE)=-STEP(IMODE)
                  ENDIF
               ENDIF
            ELSE IF (MINTEST.OR.SDTEST) THEN
!
!  STEP OFF ALONG ALL THE MODES WITH NEGATIVE EIGENVALUES.
!
               IF (IVEC.EQ.0) THEN
                  DO J1=1,NOPT
                     IF (ZT(J1).AND.(DIAG(J1).LT.0.0D0)) THEN
                        IF (PTEST) PRINT*,'STEPPING AWAY FROM SADDLE ALONG MODE ',J1
                        IF (PUSHOFF.NE.0.0D0) THEN
                           STEP(J1)=PUSHOFF
                        ELSE
                           STEP(J1)=STPMAX(J1)/10.0D0
                        ENDIF
                     ENDIF
                  ENDDO
               ELSE
!
!  STEP OFF ONLY ALONG THE MODE SPECIFIED.
!
                  IF ((IVEC.GE.0).AND.PTEST) PRINT*,'STEPPING AWAY FROM SADDLE ALONG MODE ',IMODE,' + DIRECTION'
                  IF ((IVEC.LT.0).AND.PTEST) PRINT*,'STEPPING AWAY FROM SADDLE ALONG MODE ',IMODE,' - DIRECTION'
                  IF (PUSHOFF.NE.0.0D0) THEN
                  STEP(IMODE)=PUSHOFF
                  ELSE
                     STEP(IMODE)=STPMAX(IMODE)/10.0D0
                  ENDIF
                  IF (IVEC.LT.0) STEP(IMODE)=-STEP(IMODE)
               ENDIF
            ENDIF
         ENDIF

         IF (EFSTEPST.AND.(MOD(ITER-1,EFSTEPS).EQ.0).AND.(.NOT.SDTEST)) THEN
            DO I=NZERO+1,NOPT
                IF (PTEST) WRITE(*,360) I, STEP(I)
360             FORMAT(' UNSCALED STEP FOR MODE ',I4,'=',F20.10)
            ENDDO
         ENDIF
         IF ((TEMP.GT.1.0D0).AND.PTEST) WRITE(*,366) TEMP
366      FORMAT(' LARGEST MODULUS RATIO OF NON-ZERO E/VALUES= ',5X,G20.10)   

      ELSE
!
!  STEEPEST DESCENT/ASCENT STEP - PAGE-MCIVER METHOD
!
!  OUTLINE OF METHOD:
!  VALUE OF PARAMETER T IS DETERMINED BY THE ARC LENGTH VIA
!  A DIFFERENTIAL EQUATION (33) FROM THE PM PAPER.
!  IF ALL EIGENVALUES ARE +VE THEN THE INTEGRAL IS BOUNDED.
!  TO CONVERGE TO A SADDLE POINT THE GRADIENT MUST HAVE NO COMPONENT
!  IN EIGENDIRECTIONS WITH NEGATIVE EIGENVALUES. SUCH CASES CAN
!  OBVIOUSLY CAUSE NUMERICAL PROBLEMS!
!
!  ZERO GRADIENT COMPONENTS SHOULD BE CONSERVED, SO TRY SETTING STEPS
!  TO ZERO IF THE GRADIENT COMPONENT IS LESS THAN CONVR AND INR=7.
!
!  STPMAX(1) IS DYNAMICALLY ADJUSTED VIA A TRUST RADIUS SCHEME.
!     
         DELTAT=STPMAX(1)/(100.0D0*RMS*SQRT(1.0D0*NOPT))
         DELTAS=RMS*SQRT(1.0D0*NOPT)*DELTAT/2.0D0
         DO J1=1,NOPT
            DIAGEXP(J1)=DEXP(-2*DIAG(J1)*DELTAT)
         ENDDO
         IF (INR.EQ.8) DIAGEXP(IMODE)=DEXP(2*DIAG(IMODE)*DELTAT)
         J1=0

666      J1=J1+1
         DELTASP=DELTAS
         TEMP=0.0D0
         DO J2=1,NOPT
            IF (ZT(J2)) TEMP=TEMP+FOB(J2)**2*DIAGEXP(J2)**J1
         ENDDO
         DELTAS=DELTAS+DSQRT(TEMP)*DELTAT
!
!  WE NEED TO ESCAPE FROM THE LOOP IF THE INTEGRAL HAS EFFECTIVELY CONVERGED
!  OR IF THE ARC LENGTH EXCEEDS THE ALLOWED VALUE.
!
         IF ((DELTAS.LT.STPMAX(1)).AND.(J1.LT.100000).AND.((DELTAS-DELTASP)/DELTASP.GT.1.0D-10)) GOTO 666

         TPAR=J1*DELTAT
         IF (PTEST) WRITE(*,'(A,F12.6,A,F15.3,A,I6)') ' EFOL> ESTIMATED ARC LENGTH=',DELTAS,' FOR T=',TPAR,' INTEGRATION STEPS=',J1

         STEP(1:NOPT)=0.0D0
         DO J1=NOPT-NEV+1,NOPT 
            IF (.NOT.((DABS(FOB(J1)).LT.CONVR).AND.(INR.EQ.7)).AND.ZT(J1)) &
  &            STEP(J1)=FOB(J1)*(DEXP(-DIAG(J1)*TPAR)-1)/DIAG(J1)
         ENDDO
         IF (INR.EQ.8) STEP(IMODE)=FOB(IMODE)*(DEXP(DIAG(IMODE)*TPAR)-1)/DIAG(IMODE)
         STPMAG=DSQRT(DOTOPT(STEP(1),STEP(1),NOPT))
         SSTPMAG=STPMAG
         SCALE=1.0D0
         IF (PTEST) WRITE(*,'(A,2F12.6)') ' EFOL> % OF STEP AND GRADIENT ALONG SOFTEST MODE=',  &
     &                                       ABS(STEP(NOPT))*100.0D0/STPMAG,ABS(FOB(NOPT))*100.0D0/(RMS*SQRT(1.0D0*NOPT))
      ENDIF
!
!  CALCULATE PARTS OF THE NUMERICALLY PREDICTED ENERGY CHANGE BEFORE
!  SCALING FOR POSSIBLE DYNAMIC ADJUSTMENT OF THE STEP SIZE. THE
!  PREDICTED ENERGY CHANGE IS CALCULATED BELOW ONCE WE HAVE SCALED
!  EVERYTHING.
!
      E1=0.0D0
      DO J1=1,NOPT
         E1=E1+STEP(J1)*FOB(J1)
      ENDDO
      E2=0.0D0
      DO J1=1,NOPT
         E2=E2+DIAG(J1)*STEP(J1)**2
      ENDDO
      E2=E2/2.0D0

!
!  CALCULATE SCALING FACTOR FROM THE STEPS IN THE NORMAL MODE
!  BASIS. SEEMS TO WORK BEST FOR SCALING OF STEP IN EV BASIS
!  FOR CARTESIANS AND COORDINATE BASIS FOR INTERNALS.
!
!  SCALE ACCORDING TO STEP SIZE IN EV BASIS:
!
      IF (ISTCRT.EQ.10) THEN
         CALL VSTAT(STEP(1),AV,NOPT,3*NATOMS)
         STPMAG=MAX(AV(1),1D-10)
         DO J1=1,NOPT
            SCALE=MIN(STPMAX(J1)/MAX(DABS(STEP(J1)),1D-10),1.0D0)
            IF ((J1.NE.IMODE).OR.(.NOT.AWAY)) STEP(J1)=SCALE*STEP(J1)
            IF (ABS(DIAG(J1)).LT.EVCUT) THEN
               STEP(J1)=0.0D0
!              STEP(J1)=-FOB(J1)*MAXMAX/ABS(FOB(J1))
!              PRINT '(A,I8,A,G20.10)',' EFOL> EIGENVALUE ',J1,' IS TOO SMALL; PUSH OFF DOWNHILL ',STEP(J1)
!              PRINT '(A,I8,4G20.10)','J1,FOB,DIAG,MAXMAX,STEP=',J1,FOB(J1),DIAG(J1),MAXMAX,STEP(J1)
            ENDIF
         ENDDO
         CALL VSTAT(STEP(1),AV,NOPT,3*NATOMS)
         SSTPMAG=MAX(AV(1),1D-10)
         SCALE=1.0D0
      ELSE IF ((ISTCRT.EQ.3).AND.AWAY) THEN
         STPMAG=PUSHOFF
         SSTPMAG=PUSHOFF
         SCALE=1.0D0
      ENDIF

      IF (ISTCRT.EQ.10) THEN
         IF (SUMMARYT.AND.(MOD(ITER-1,NSUMMARY).EQ.0)) THEN
            IF (PTEST) WRITE(*,290)
290         FORMAT(79('-'))
            IF (PTEST) WRITE(*,'(A)') 'VECTOR      GRADIENT        SECDER       STEP          MAX STEP    TRUST RATIO'
            IF (PTEST) WRITE(*,290)
            DO I=NOPT-NEV+1,NOPT
!              IF (ZT(I)) THEN
                  IF (PTEST) WRITE(*,310) I,FOB(I),DIAG(I),STEP(I),STPMAX(I),RAT(I)
310              FORMAT(I4,1X,E15.6,1X,E15.6,1X,E13.6,1X,E12.6,1X,E15.6)
!              ENDIF
            ENDDO
            IF (PTEST) WRITE(*,290)
         ENDIF
      ELSE IF (ISTCRT.EQ.3) THEN
         IF (SUMMARYT.AND.(MOD(ITER-1,NSUMMARY).EQ.0)) THEN
            IF (PTEST) WRITE(*,291)
291         FORMAT(51('-'))
            IF (PTEST) WRITE(*,'(A)') 'VECTOR      GRADIENT        SECDER       STEP'
            IF (PTEST) WRITE(*,291)
            DO I=NOPT-NEV+1,NOPT
!              IF (ZT(I)) THEN
                  IF (PTEST) WRITE(*,'(I4,1X,E15.6,1X,E15.6,1X,E13.6)') I,FOB(I),DIAG(I),STEP(I)
!              ENDIF
            ENDDO
            IF (PTEST) WRITE(*,291)
         ENDIF
      ELSE IF (ISTCRT.EQ.2) THEN
         CALL VSTAT(STEP(1),AV,NOPT,3*NATOMS)
         SCALE=MIN(STPMAX(1)/MAX(AV(1),1D-10),1.D0)
         STPMAG=MAX(AV(1),1D-10)
         CALL SCDOT(SCALE,STEP(1),3*NATOMS)
         SSTPMAG=SCALE*STPMAG
      ENDIF
!
!  FIND THE STEP IN THE CARTESIAN BASIS AND STORE IN CSTEP
!
      DO J=1,NOPT
         DUMMY=0.0D0
         DO I=1,NOPT
            DUMMY=DUMMY+STEP(I)*HESS(J,I)
         ENDDO
         CSTEP(J)=DUMMY
      ENDDO
!
!  SCALING IF REQUIRED IN THE CARTESIAN BASIS - ACCORDING TO THE
!  MAXIMUM COMPONENT
!
      IF (ISTCRT.EQ.1) THEN
         CALL VSTAT(CSTEP(1),AV(1),NOPT,6*NATOMS)
         SCALE=MIN(STPMAX(1)/MAX(AV(1),1D-10),1.D0)
         STPMAG=MAX(AV(1),1D-10)
         CALL SCDOT(SCALE,CSTEP(1),6*NATOMS)
         SSTPMAG=SCALE*STPMAG
!
!   SCALING IN THE CARTESIAN BASIS IN TERMS OF THE TOTAL STEP.
!
      ELSE IF (ISTCRT.EQ.0) THEN
         CALL VSTAT(CSTEP(1),AV(1),NOPT,6*NATOMS)
         STPMAG=DSQRT(DOTOPT(CSTEP(1),CSTEP(1),NOPT))
         SCALE=MIN(STPMAX(1)/MAX(STPMAG,1D-10),1.D0)
         CALL SCDOT(SCALE,CSTEP(1),6*NATOMS)
         SSTPMAG=SCALE*STPMAG
      ENDIF
      IF ((.NOT.SDTEST).AND.PTEST) WRITE(*,'(A,12X,2G20.10)') ' THE MAXIMUM SCALED/UNSCALED STEP IS: ',SSTPMAG,STPMAG
!
!  WE CAN NOW CHECK FOR CONVERGENCE SINCE WE KNOW THE RMS FORCE, THE
!  HESSIAN INDEX AND THE MAGNITUDE OF THE PROPOSED STEP. IF CONVERGED,
!  WE DON'T TAKE THE STEP.
!
      IF ((CONVU.EQ.0.0D0).OR.SDTEST) THEN
         TEST1=RMS.LT.CONVR
      ELSE IF (CONVR.EQ.0.0D0) THEN
         TEST1=STPMAG.LT.CONVU
      ELSE
         TEST1=(STPMAG.LT.CONVU).AND.(RMS.LT.CONVR)
      ENDIF
      IF (INDEXT) THEN
         TEST2=NRTEST.OR.(MINTEST.AND.(INEG.EQ.0)).OR.(TSTEST.AND.(INEG.EQ.HINDEX))
      ELSE
         TEST2=.TRUE.
      ENDIF
      IF (TEST1.AND.TEST2) MFLAG=.TRUE.
      IF (ITER.LT.NSTEPMIN) MFLAG=.FALSE.
      IF (PV.AND.(.NOT.PVFLAG)) MFLAG=.FALSE.
!
!  DON'T CALL SYMMETRY IF WE'RE DOING FENSKE-HALL, OR IF THE RMS FORCE IS TOO HIGH.
!
      IF ((ZSYM(NATOMS).NE.'FH').AND.(.NOT.VARIABLES).AND.(.NOT.FIELDT).AND.(.NOT.RINGPOLYMERT).AND.(.NOT.AMBER)&
     &        .AND.(PTEST).AND.(((RMS.LT.SYMCUT).OR.(ITER.EQ.NSTEPS)).OR.MFLAG)) THEN
         IF (ZSYMSAVE(1:1).EQ.'W') THEN
!           DO J2=1,NOPT
!              QSAVE(J2)=QTS(J2)
!           ENDDO
!           DO J2=1,NATOMS  !  WCOMMENT
            DO J2=1,NATOMS/2
               CALL CONVERT(QTS(3*(J2-1)+1),QTS(3*(J2-1)+2),QTS(3*(J2-1)+3),&
!    &                      QTS(3*(NATOMS+J2-1)+1),QTS(3*(NATOMS+J2-1)+2),QTS(3*(NATOMS+J2-1)+3),&
     &                      QTS(3*(NATOMS/2+J2-1)+1),QTS(3*(NATOMS/2+J2-1)+2),QTS(3*(NATOMS/2+J2-1)+3),&
     &                      OVEC,H1VEC,H2VEC)
               QW(9*(J2-1)+1)=OVEC(1)
               QW(9*(J2-1)+2)=OVEC(2)
               QW(9*(J2-1)+3)=OVEC(3)
               QW(9*(J2-1)+4)=H1VEC(1)
               QW(9*(J2-1)+5)=H1VEC(2)
               QW(9*(J2-1)+6)=H1VEC(3)
               QW(9*(J2-1)+7)=H2VEC(1)
               QW(9*(J2-1)+8)=H2VEC(2)
               QW(9*(J2-1)+9)=H2VEC(3)
            ENDDO
!           NATOMS=NATOMS*3  ! WCOMMENT
            NATOMSSAVE=NATOMS
            NATOMS=(NATOMS/2)*3
            CALL SYMMETRY(HORDER,.TRUE.,QW,INERTIA)
!           NATOMS=NATOMS/3  ! WCOMMENT
            NATOMS=2*(NATOMS/3)
            NATOMS=NATOMSSAVE
!           DO J2=1,NOPT
!              QTS(J2)=QSAVE(J2)
!           ENDDO
         ELSE
            CALL SYMMETRY(HORDER,.TRUE.,QTS,INERTIA) 
         ENDIF
      ENDIF
      IF (MFLAG) THEN
         IF (ALLOCATED(QW)) THEN
            DEALLOCATE(QW)
         ENDIF
         GOTO 1111
      ENDIF
!
!  CALCULATE PREDICTED CHANGE IN ENERGY. TAKE THE STEP USING VADD.
!
      DELE=E1*SCALE+E2*SCALE**2
      CALL VADD(QTS,QTS,CSTEP,NOPT,1)
      KNOWE=.FALSE.
      KNOWG=.FALSE.
      KNOWH=.FALSE.
!
! SUMMARIZE
!
      IF ((ISTCRT.NE.10).AND.(ISTCRT.NE.3)) THEN
         IF (PTEST) WRITE(*,'(A,F8.5)') ' SCALE FACTOR SET TO: ',SCALE
         IF (PTEST) WRITE(*,'(A,F15.6)') ' MAXIMUM STEP LENGTH ALLOWED IS ',STPMAX(1)
         IF (SUMMARYT.AND.(MOD(ITER-1,NSUMMARY).EQ.0)) THEN
            IF (PTEST) WRITE(*,490)
            IF (PTEST) WRITE(*,480)
480         FORMAT('PARAMETER',T20,'DV/DR',T32,'STEP',T46,'ROLD',T56,'RNEW')
            IF (PTEST) WRITE(*,490)
490         FORMAT(64('-'))
            DO I=1,NOPT
               IF (ZT(I)) THEN
                  IF (PTEST) WRITE(*,500)' ',VNEW(I),CSTEP(I),(QTS(I)-CSTEP(I)),QTS(I)
500              FORMAT(T7,A,T17,F10.6,T29,F10.5,T41,F10.5,T53,F10.5)
               ENDIF
            ENDDO
            IF (PTEST) WRITE(*,490)
         ENDIF
      ENDIF

      IF ((FIXAFTER.GT.0).AND.(ITER.GT.FIXAFTER)) FIXIMAGE=.TRUE.
      CALL FLUSH(6,ISTAT)
!
!  UNDO MASS WEIGHTING IF NECESSARY.
!
      IF (MASST) THEN
         DO J1=1,NATOMS
            AMASS=1/SQRT(ATMASS(J1))
            QTS(3*J1-2)=AMASS*QTS(3*J1-2)
            QTS(3*J1-1)=AMASS*QTS(3*J1-1)
            QTS(3*J1)=AMASS*QTS(3*J1)
         ENDDO
      ENDIF

      CALL FLUSH(6,ISTAT)
      CALL GMETRY(ITER,VEC,QTS)
!
!     PRINT OUT THE COORDINATES AND DISTANCE MATRIX
!
      IF (ADMT.AND.(MOD(ITER-1,NADM).EQ.0)) CALL ADM(QTS)
!     IF ((AMBER).AND.(MOVIE)) CALL AMOVIEDUMP(FRAME)
      EOLD=ENERGY
      DO J1=1,NOPT
         PSTEP(J1)=STEP(J1)
         PFOB(J1)=FOB(J1)
         PZT(J1)=ZT(J1)
      ENDDO
      ITER=ITER+1
      IVEC=IVEC2
      IF (ITER.GE.ITMAX+1) THEN
         IF (ALLOCATED(QW)) THEN
            DEALLOCATE(QW)
         ENDIF
         GOTO 1111
      ENDIF

      GOTO 40

! 1111  IF (PRESENT(INRIN)) THEN ! SAT

1111  INR=INRSAVE
!     ENDIF

      END SUBROUTINE EFOL
END MODULE MODEFOL
