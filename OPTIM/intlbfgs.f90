!   COPYRIGHT (C) 2003-2010 DAVID J. WALES
!   THIS FILE IS PART OF OPTIM.
!
!   OPTIM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
!   IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
!   THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
!   (AT YOUR OPTION) ANY LATER VERSION.
!
!   OPTIM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
!   BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
!   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
!   GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
!
!   YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
!   ALONG WITH THIS PROGRAM; IF NOT, WRITE TO THE FREE SOFTWARE
!   FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330, BOSTON, MA  02111-1307  USA
!
SUBROUTINE INTLBFGS(QSTART,QFINISH,NMINFOUND,NTSFOUND,MINFOUND,TSFOUND)
USE PORFUNCS
USE KEY, ONLY : FREEZENODEST, FREEZETOL, DEBUG, MAXINTBFGS, NNREPULSIVE, &
     & INTCONSEP, INTRMSTOL, INTIMAGE, NREPMAX, NREPULSIVE, INTMUPDATE, INTDGUESS, &
     & INTCONSTRAINTT, NCONSTRAINT, CONI, CONJ, CONDISTREF, INTCONMAX, BSMIN, &
     & INTCONSTRAINREPCUT, REPCON, INTCONSTRAINTREP, INTREPSEP, NREPI, NREPJ, &
     & INTCONSTRAINTTOL, CONDISTREFLOCAL, INTCONFRAC, CONACTIVE, NITSTART, REPI, &
     & REPJ, NREPMAX, ATOMACTIVE, NCONSTRAINTON, CONION, CONJON, CONDISTREFLOCALON, CONDISTREFON, &
     & MAXCONUSE, NREPCUT, REPCUT, CHECKCONINT, INTCONSTEPS, INTRELSTEPS, MAXCONE, COLDFUSIONLIMIT, &
     & INTSTEPS1, DUMPINTXYZ, DUMPINTXYZFREQ, DUMPINTEOS, DUMPINTEOSFREQ, MUPDATE, BFGSSTEPS, INTTST, &
     & BFGSTST, NSTEPS, IMSEPMIN, IMSEPMAX, MAXINTIMAGE
USE COMMONS, ONLY: NATOMS, NOPT, ZSYM
USE MODEFOL

IMPLICIT NONE 

DOUBLE PRECISION, INTENT(IN) :: QSTART(NOPT), QFINISH(NOPT)  ! THE TWO END POINTS
INTEGER D, U
DOUBLE PRECISION DMAX, DS, DF, FRAC, DMIN
DOUBLE PRECISION, ALLOCATABLE :: REPTEMP(:)
INTEGER, ALLOCATABLE :: IREPTEMP(:)
INTEGER NDECREASE, NFAIL, NTOADD, NADDED, NMAXINT, NMININT, JMAX, JMIN, INTIMAGESAVE
LOGICAL KNOWE, KNOWG, KNOWH, ADDATOM, PTEST, MFLAG, PRINTOPTIMIZETS
COMMON /KNOWN/ KNOWE, KNOWG, KNOWH

DOUBLE PRECISION EDUMMY,EVALMIN,EVALMAX
INTEGER J2,POINT,BOUND,NPT,CP,I,ISTAT,J1,J3,J4,NIMAGEFREEZE,NACTIVE,NBEST,NEWATOM,NMINFOUND,NTSFOUND,NSIDE,ITDONE
INTEGER NCONFORNEWATOM, CONLIST(NATOMS), NCONATOM(NATOMS), TURNONORDER(NATOMS),NBACKTRACK
DOUBLE PRECISION, DIMENSION(3*NATOMS) :: LGDUMMY, VECS, XDIAG
INTEGER NDUMMY, CLOSEATOM, NLASTGOODE, NCONTOACTIVE(NATOMS), NSTEPSMAX
INTEGER NTRIES(NATOMS), N1, N2, N3, NITERDONE, EXITSTATUS
DOUBLE PRECISION :: YS,YY,SQ,YR,BETA,GNORM,DDOT,DUMMY,STPMIN,PREVGRAD,EMINUS,EPLUS, STARTTIME, TIME0, &
  &                 C1, C2, C3, VEC1(3), VEC2(3), VEC3(3), &
  &                 DUMMY2, RANDOM, INVDTOACTIVE(NATOMS), DINCREMENT, &
  &                 CONDIST(NATOMS), ESAVED, ESAVEC, ESAVE0, &
  &                 ETOTALTMP, RMSTMP, USEFRAC, & 
  &                 RAN1, STIME, FTIME, MAXCONDIST, &
  &                 MINCONDIST, ETOTAL, LASTGOODE, DPRAND, RMS, STEPTOT, &
  &                 VNEW(NOPT), ENERGY, RMS2, EREAL, MINCOORDS(2,NOPT), LINTCONSTRAINTTOL, LOCALCOORDS(3*NATOMS)

LOGICAL TSCONVERGED
DOUBLE PRECISION, DIMENSION(INTMUPDATE)     :: RHO1,ALPHA
DOUBLE PRECISION :: EOLD, DIFF, DIST, DTOTAL
LOGICAL SWITCHED, CHANGED
INTEGER NDIST1(NATOMS), NCYCLE, DMIN1, DMAX1, NUNCON1
DOUBLE PRECISION, POINTER :: X(:), G(:)
DOUBLE PRECISION, ALLOCATABLE :: EINT(:)
!
! THESE DECLARATIONS HAVE TO MATCH THOSE IN NEB/NTC.F90
!
TYPE MINFOUNDTYPE
   DOUBLE PRECISION,POINTER :: E
   DOUBLE PRECISION,POINTER :: COORD(:)
END TYPE MINFOUNDTYPE
INTEGER,PARAMETER :: NMINMAX = 3000 ! MAXIMAL NUMBER OF MIN TO BE CHECKED IN ONE INTLBFGS RUN
TYPE (MINFOUNDTYPE) :: MINFOUND(NMINMAX)

INTEGER,PARAMETER :: NTSMAX = 3000 ! MAXIMAL NUMBER OF TS TO BE CHECKED IN ONE INTLBFGS RUN
TYPE TSFOUNDTYPE
     DOUBLE PRECISION,POINTER :: E
     DOUBLE PRECISION,POINTER :: EVALMIN
     DOUBLE PRECISION,POINTER :: COORD(:)
     DOUBLE PRECISION,POINTER :: VECS(:)
END TYPE TSFOUNDTYPE

TYPE (TSFOUNDTYPE) :: TSFOUND(NTSMAX)
!
! EFK: FOR FREEZENODES
!
DOUBLE PRECISION :: TESTG, TOTGNORM
INTEGER :: IM
INTEGER NDFORNEWATOM, BESTPRESERVEDN(NATOMS)
INTEGER NCFORNEWATOM, BESTCLOSESTN(NATOMS)
DOUBLE PRECISION BESTPRESERVEDD(NATOMS), BESTCLOSESTD(NATOMS)
!
! DIMENSIONS INVOLVING INTIMAGE
!
DOUBLE PRECISION, ALLOCATABLE :: SAVEX(:), TRUEEE(:), GOODSAVE(:), &
  &              EEETMP(:), MYGTMP(:), XSAVED(:,:), XSAVEC(:,:), EEE(:), STEPIMAGE(:), &
  &              XSAVE0(:,:), GTMP(:), DIAG(:), STP(:), SEARCHSTEP(:,:), GDIF(:,:), GLAST(:), XSAVE(:)
DOUBLE PRECISION, ALLOCATABLE, TARGET :: XYZ(:), GGG(:), DPTMP(:), D2TMP(:,:)
LOGICAL, ALLOCATABLE :: CHECKG(:), IMGFREEZE(:), LOGTMP(:)

ALLOCATE(SAVEX(3*NATOMS*INTIMAGE),TRUEEE(INTIMAGE+2),GOODSAVE(3*NATOMS*(INTIMAGE+2)), &
  &      EEETMP(INTIMAGE+2), MYGTMP(3*NATOMS*INTIMAGE), XSAVED(3,INTIMAGE+2), &
  &      XSAVEC(3,INTIMAGE+2), XSAVE0(3,INTIMAGE+2), GTMP(3*NATOMS*INTIMAGE), &
  &      DIAG(3*NATOMS*INTIMAGE), STP(3*NATOMS*INTIMAGE), SEARCHSTEP(0:INTMUPDATE,NOPT*INTIMAGE), &
  &      GDIF(0:INTMUPDATE,NOPT*INTIMAGE),GLAST(NOPT*INTIMAGE), XSAVE(NOPT*INTIMAGE), &
  &      XYZ(NOPT*(INTIMAGE+2)), GGG(NOPT*(INTIMAGE+2)), CHECKG(NOPT*INTIMAGE), IMGFREEZE(INTIMAGE), &
  &      EEE(INTIMAGE+2), STEPIMAGE(INTIMAGE))

SWITCHED=.FALSE.
INTIMAGESAVE=INTIMAGE
NBACKTRACK=1
CALL MYCPU_TIME(STIME,.FALSE.)
PRINT '(A,I6)',' INTLBFGS> MAXIMUM NUMBER OF STEPS FOR CONSTRAINT POTENTIAL PHASE IS ',INTSTEPS1
PREVGRAD=1.0D100
ADDATOM=.FALSE.
NFAIL=0
IF (FREEZENODEST) IMGFREEZE(1:INTIMAGE)=.FALSE.
D=NOPT*INTIMAGE
U=INTMUPDATE
NITERDONE=1
LINTCONSTRAINTTOL=INTCONSTRAINTTOL

IF ( D<=0 ) THEN
   PRINT *, 'D IS NOT POSITIVE, D=',D
   CALL TSUMMARY
   STOP
ENDIF
IF ( U<=0 ) THEN
   PRINT *, 'U IS NOT POSITIVE, U=',U
   CALL TSUMMARY
   STOP
ENDIF
IF (INTSTEPS1 < 0) THEN
   PRINT '(1X,A)', 'MAXIMAL NUMBER OF ITERATIONS IS LESS THAN ZERO! STOP.'
   CALL TSUMMARY
   STOP
ENDIF
!
! XYZ, GGG, EEE INCLUDE THE END POINT IMAGES
! X, G DO NOT.
!
IF (.NOT.ALLOCATED(CONI)) THEN 
   ALLOCATE(CONI(INTCONMAX),CONJ(INTCONMAX),CONDISTREF(INTCONMAX))
   ALLOCATE(REPI(NREPMAX),REPJ(NREPMAX),NREPI(NREPMAX),NREPJ(NREPMAX),REPCUT(NREPMAX),NREPCUT(NREPMAX))
ENDIF
X=>XYZ(NOPT+1:NOPT*(INTIMAGE+1))
G=>GGG(NOPT+1:NOPT*(INTIMAGE+1))
!
! INITIALISE XYZ
!
XYZ(1:NOPT)=QSTART(1:NOPT)
XYZ(NOPT*(INTIMAGE+1)+1:NOPT*(INTIMAGE+2))=QFINISH(1:NOPT)
DO J1=1,INTIMAGE+2
   XYZ((J1-1)*NOPT+1:J1*NOPT)=((INTIMAGE+2-J1)*QSTART(1:NOPT)+(J1-1)*QFINISH(1:NOPT))/(INTIMAGE+1)
ENDDO
!
! CALCULATE INITIAL CONSTRAINTS.
!
NLASTGOODE=0
LASTGOODE=1.0D100
GOODSAVE(1:D)=X(1:D)
IF (.NOT.ALLOCATED(ATOMACTIVE)) ALLOCATE(ATOMACTIVE(NATOMS))
51   NCONSTRAINT=0 
MAXCONDIST=-1.0D0
SAVEX(1:D)=X(1:D)
MINCONDIST=1.0D100
DO J2=1,NATOMS
   DO J3=J2+1,NATOMS
      IF (J3-J2.GT.INTCONSEP) CYCLE ! FORBID CONSTRAINTS CORRESPONDING TO ATOMS DISTANT IN SEQUENCE
      DS=SQRT((XYZ(3*(J2-1)+1)-XYZ(3*(J3-1)+1))**2 &
  &          +(XYZ(3*(J2-1)+2)-XYZ(3*(J3-1)+2))**2 &
  &          +(XYZ(3*(J2-1)+3)-XYZ(3*(J3-1)+3))**2) 
      IF (DS.GT.5.0D0) CYCLE ! DON'T ALLOW CONSTRAINTS IF EITHER ENDPOINT SEPARATION IS TOO LARGE DJW
      DF=SQRT((XYZ((INTIMAGE+1)*3*NATOMS+3*(J2-1)+1)-XYZ((INTIMAGE+1)*3*NATOMS+3*(J3-1)+1))**2 &
  &          +(XYZ((INTIMAGE+1)*3*NATOMS+3*(J2-1)+2)-XYZ((INTIMAGE+1)*3*NATOMS+3*(J3-1)+2))**2 &
  &          +(XYZ((INTIMAGE+1)*3*NATOMS+3*(J2-1)+3)-XYZ((INTIMAGE+1)*3*NATOMS+3*(J3-1)+3))**2) 
      IF (DF.GT.5.0D0) CYCLE ! DON'T ALLOW CONSTRAINTS IF EITHER ENDPOINT SEPARATION IS TOO LARGE DJW
!     IF (2.0D0*ABS(DS-DF)/(DS+DF).LT.LINTCONSTRAINTTOL) THEN
      IF (ABS(DS-DF).LT.LINTCONSTRAINTTOL) THEN
!
!  ADD CONSTRAINT FOR THIS DISTANCE TO THE LIST.
!
         NCONSTRAINT=NCONSTRAINT+1
!        PRINT '(A,2I6,A,I6)','INTLBFGS> ADDING CONSTRAINT FOR ATOMS ',J2,J3,'  TOTAL=',NCONSTRAINT
         IF (NCONSTRAINT.GT.INTCONMAX) THEN
            ALLOCATE(IREPTEMP(INTCONMAX))
               
            IREPTEMP(1:INTCONMAX)=CONI(1:INTCONMAX)
            DEALLOCATE(CONI)
            ALLOCATE(CONI(2*INTCONMAX))
            CONI(1:INTCONMAX)=IREPTEMP(1:INTCONMAX)
               
            IREPTEMP(1:INTCONMAX)=CONJ(1:INTCONMAX)
            DEALLOCATE(CONJ)
            ALLOCATE(CONJ(2*INTCONMAX))
            CONJ(1:INTCONMAX)=IREPTEMP(1:INTCONMAX)
               
            DEALLOCATE(IREPTEMP)
            ALLOCATE(REPTEMP(1:INTCONMAX))
               
            REPTEMP(1:INTCONMAX)=CONDISTREF(1:INTCONMAX)
            DEALLOCATE(CONDISTREF)
            ALLOCATE(CONDISTREF(2*INTCONMAX))
            CONDISTREF(1:INTCONMAX)=REPTEMP(1:INTCONMAX)

            INTCONMAX=2*INTCONMAX
            DEALLOCATE(REPTEMP)
         ENDIF
         CONI(NCONSTRAINT)=J2
         CONJ(NCONSTRAINT)=J3
         CONDISTREF(NCONSTRAINT)=(DF+DS)/2.0D0
         IF (CONDISTREF(NCONSTRAINT).GT.MAXCONDIST) MAXCONDIST=CONDISTREF(NCONSTRAINT)
         IF (CONDISTREF(NCONSTRAINT).LT.MINCONDIST) MINCONDIST=CONDISTREF(NCONSTRAINT)
         IF (DEBUG) PRINT '(A,2I6,A,2F12.2,A,F12.4,A,I8)',' INTLBFGS> CONSTRAIN DISTANCE FOR ATOMS ',CONI(NCONSTRAINT), &
  &              CONJ(NCONSTRAINT),' VALUES ARE ',DS,DF,' FRACTION=',2*ABS(DS-DF)/(DS+DF), &
  &             ' # CONSTRAINTS=',NCONSTRAINT
      ENDIF
   ENDDO
ENDDO
!
! CHECK THAT WE HAVE A PERCOLATING CONSTRAINT NETWORK. IF NOT, INCREASE THE TOLERANCE AND TRY AGAIN!
! CALCULATE MINIMUM NUMBER OF STEPS OF EACH ATOM FROM NUMBER 1.
!
NDIST1(1:NATOMS)=1000000
NDIST1(1)=0
NCYCLE=0
5    CHANGED=.FALSE.
NCYCLE=NCYCLE+1
DMIN1=100000
DMAX1=0
NUNCON1=0
DO J1=1,NATOMS
   IF (NDIST1(J1).EQ.0) CYCLE ! MINIMUM 1
     DO J2=1,NCONSTRAINT
        IF (CONI(J2).EQ.J1) THEN
           IF (NDIST1(CONJ(J2))+1.LT.NDIST1(J1)) THEN
              CHANGED=.TRUE.
              NDIST1(J1)=NDIST1(CONJ(J2))+1
           ENDIF
        ELSE IF (CONJ(J2).EQ.J1) THEN
           IF (NDIST1(CONI(J2))+1.LT.NDIST1(J1)) THEN
              CHANGED=.TRUE.
              NDIST1(J1)=NDIST1(CONI(J2))+1
           ENDIF
        ENDIF
     ENDDO
     IF ((NDIST1(J1).GT.DMAX1).AND.(NDIST1(J1).NE.1000000)) DMAX1=NDIST1(J1)
     IF (NDIST1(J1).LT.DMIN1) DMIN1=NDIST1(J1)
     IF (NDIST1(J1).EQ.1000000) NUNCON1=NUNCON1+1
ENDDO
IF (CHANGED) GOTO 5
PRINT '(3(A,I8))',' INTLBFGS> STEPS TO ATOM 1 CONVERGED IN ',NCYCLE-1, &
  &               ' CYCLES; MAXIMUM=',DMAX1,' DISCONNECTED=',NUNCON1
IF (NUNCON1.GT.0) THEN
   LINTCONSTRAINTTOL=LINTCONSTRAINTTOL*1.1D0
   PRINT '(A,F15.5)',' INTLBFGS> INCREASING THE LOCAL CONSTRAINT TOLERANCE PARAMETER TO ',LINTCONSTRAINTTOL
   GOTO 51
ENDIF
NCONATOM(1:NATOMS)=0

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

PRINT '(A,I6,2(A,F15.5))',' INTLBFGS> TOTAL DISTANCE CONSTRAINTS=',NCONSTRAINT, &
  &                    ' SHORTEST=',MINCONDIST,' LONGEST=',MAXCONDIST
REPCON=-INTCONSTRAINTREP/INTCONSTRAINREPCUT**6 ! ALSO NEEDED FOR CONGRAD.F90 POTENTIAL
IF (ALLOCATED(CONDISTREFLOCAL)) THEN
   DEALLOCATE(CONDISTREFLOCAL)
ENDIF
ALLOCATE(CONDISTREFLOCAL(NCONSTRAINT))
IF (ALLOCATED(CONDISTREFLOCALON)) DEALLOCATE(CONDISTREFLOCALON)
IF (ALLOCATED(CONDISTREFON)) DEALLOCATE(CONDISTREFON)
IF (ALLOCATED(CONION)) DEALLOCATE(CONION)
IF (ALLOCATED(CONJON)) DEALLOCATE(CONJON)
ALLOCATE(CONDISTREFLOCALON(NCONSTRAINT),CONDISTREFON(NCONSTRAINT),CONION(NCONSTRAINT),CONJON(NCONSTRAINT))
CONDISTREFLOCAL(1:NCONSTRAINT)=CONDISTREF(1:NCONSTRAINT)
DUMMY=1.0D100
DO J1=1,NCONSTRAINT
   DF=SQRT((XYZ(3*(CONI(J1)-1)+1)-XYZ((INTIMAGE+1)*3*NATOMS+3*(CONI(J1)-1)+1))**2 &
  &       +(XYZ(3*(CONI(J1)-1)+2)-XYZ((INTIMAGE+1)*3*NATOMS+3*(CONI(J1)-1)+2))**2 &
  &       +(XYZ(3*(CONI(J1)-1)+3)-XYZ((INTIMAGE+1)*3*NATOMS+3*(CONI(J1)-1)+3))**2)&
  &  +SQRT((XYZ(3*(CONJ(J1)-1)+1)-XYZ((INTIMAGE+1)*3*NATOMS+3*(CONJ(J1)-1)+1))**2 &
  &       +(XYZ(3*(CONJ(J1)-1)+2)-XYZ((INTIMAGE+1)*3*NATOMS+3*(CONJ(J1)-1)+2))**2 &
  &       +(XYZ(3*(CONJ(J1)-1)+3)-XYZ((INTIMAGE+1)*3*NATOMS+3*(CONJ(J1)-1)+3))**2)
   IF (DF.LT.DUMMY) THEN
      NBEST=J1
      DUMMY=DF
   ENDIF
ENDDO
IF (DEBUG) PRINT '(A,I6,A,2I6,A,F15.5)',' INTLBFGS> SMALLEST OVERALL MOTION FOR CONSTRAINT ',NBEST,' ATOMS ', &
  &                           CONI(NBEST),CONJ(NBEST),' DISTANCE=',DUMMY
NACTIVE=2
TURNONORDER(1:NATOMS)=0
NTRIES(1:NATOMS)=1
IF (ALLOCATED(CONACTIVE)) DEALLOCATE(CONACTIVE)
IF (ALLOCATED(NITSTART)) DEALLOCATE(NITSTART)
ALLOCATE(CONACTIVE(NCONSTRAINT),NITSTART(NCONSTRAINT))
CONACTIVE(1:NCONSTRAINT)=.FALSE.
CONACTIVE(NBEST)=.TRUE.
NITSTART(NBEST)=1
ATOMACTIVE(1:NATOMS)=.FALSE.
ATOMACTIVE(CONI(NBEST))=.TRUE.
ATOMACTIVE(CONJ(NBEST))=.TRUE.
TURNONORDER(1)=CONI(NBEST)
TURNONORDER(2)=CONJ(NBEST)
NTRIES(CONI(NBEST))=1
NTRIES(CONJ(NBEST))=1
NREPULSIVE=0
NCONSTRAINTON=1
CONDISTREFLOCALON(1)=CONDISTREFLOCAL(NBEST)
CONDISTREFON(1)=CONDISTREF(NBEST)
CONION(1)=CONI(NBEST)
CONJON(1)=CONJ(NBEST)
!
! DON;T WANT TO REDISTRIBUTE IMAGES BEFORE EVEN TAKING A STEP, SO DON;T CALL CHECKSEP.
! MUST CALL CHECKREP TO INITIALISE NNREULSIVE, NREPI, NREPJ, ETC. SEGV OTHERWISE ON SECOND CYCLE!
!

CALL CHECKREP(INTIMAGE,XYZ,NOPT)
IF (CHECKCONINT) THEN
   CALL CONGRAD2(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
ELSE
   CALL CONGRAD(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
ENDIF
EOLD=ETOTAL
GLAST(1:D)=G(1:D)
XSAVE(1:D)=X(1:D)

IF (ETOTAL/INTIMAGE.LT.COLDFUSIONLIMIT) THEN
   WRITE(*,'(A,2G20.10)') ' INTLBFGS> COLD FUSION DIAGNOSED - STEP DISCARDED, ENERGY, LIMIT=', &
  &                       ETOTAL/INTIMAGE,COLDFUSIONLIMIT
   DEALLOCATE(CONI,CONJ,CONDISTREF,REPI,REPJ,NREPI,NREPJ,REPCUT,NREPCUT)
   DEALLOCATE(SAVEX,TRUEEE,GOODSAVE, EEETMP, MYGTMP, XSAVED, XSAVEC, XSAVE0, GTMP, &
  &      DIAG, STP, SEARCHSTEP, GDIF,GLAST, XSAVE, XYZ, GGG, CHECKG, IMGFREEZE, EEE, STEPIMAGE)
   INTIMAGE=INTIMAGESAVE
   NTSFOUND=0
   NMINFOUND=0
   RETURN
ENDIF

IF (DEBUG) WRITE(*,'(A6,A20,A20,A9,A9)') 'ITER','ENERGY PER IMAGE','RMS FORCE','STEP'
NSTEPSMAX=INTSTEPS1


DO ! MAIN DO LOOP WITH COUNTER NITERDONE, INITIALLY SET TO ONE
!
!  ADD NEXT ATOM TO ACTIVE SET IF ADDATOM IS TRUE. 
!  CONSTRAINTS TO ATOMS ALREADY IN THE ACTIVE SET ARE TURNED ON
!  AND SHORT-RANGE REPULSIONS TO ACTIVE ATOMS THAT ARE NOT DISTANCE CONSTRAINED ARE TURNED ON.
!  *** OLD FIND NEAREST ATOM TO ACTIVE SET ATTACHED BY A CONSTRAINT
!  *** NEW FIND ATOM WITH MOST CONSTRAINTS TO ACTIVE SET
!  TURN ON CONSTRAINT TERMS FOR THIS ATOM WITH ALL PREVIOUS MEMBERS OF THE ACTIVE SET
!  ADD REPULSIONS TO NON-CONSTRAINED ATOMS IN THIS SET
!  NTOADD IS THE NUMBER OF ATOMS TO ADD TO THE ACTIVE SET IN EACH PASS. 1 SEEMS BEST!
!
   NTOADD=1
!  NTOADD=NATOMS-2  !!!! DJW
   NADDED=0
   IF (ADDATOM.AND.(NACTIVE.LT.NATOMS)) THEN
542   CONTINUE
!     DUMMY=1.0D100
      NBEST=0
      NCONTOACTIVE(1:NATOMS)=0
      INVDTOACTIVE(1:NATOMS)=0.0D0
      SAVEX(D)=X(D)
      DO J2=1,NCONSTRAINT
         IF (CONACTIVE(J2)) CYCLE   ! COUNT NEW, INACTIVE CONSTRAINTS
         IF (ATOMACTIVE(CONI(J2))) THEN
            IF (.NOT.ATOMACTIVE(CONJ(J2))) THEN
               NCONTOACTIVE(CONJ(J2))=NCONTOACTIVE(CONJ(J2))+1
               INVDTOACTIVE(CONJ(J2))=INVDTOACTIVE(CONJ(J2))+1.0D0/CONDISTREF(J2)
            ENDIF
         ENDIF
         IF (ATOMACTIVE(CONJ(J2))) THEN
            IF (.NOT.ATOMACTIVE(CONI(J2))) THEN
               NCONTOACTIVE(CONI(J2))=NCONTOACTIVE(CONI(J2))+1
               INVDTOACTIVE(CONI(J2))=INVDTOACTIVE(CONI(J2))+1.0D0/CONDISTREF(J2)
            ENDIF
         ENDIF
         IF (NCONTOACTIVE(CONI(J2)).GT.NBEST) THEN
            NBEST=NCONTOACTIVE(CONI(J2))
         ENDIF
         IF (NCONTOACTIVE(CONJ(J2)).GT.NBEST) THEN
            NBEST=NCONTOACTIVE(CONJ(J2))
         ENDIF
!        PRINT '(A,7I6)','J2,NCONTOACTIVEI,NCONTOACTOVEJ,CONI,CONJ,NEWATOM,NBEST=', &
! &                             J2,NCONTOACTIVE(CONI(J2)),NCONTOACTIVE(CONJ(J2)),CONI(J2),CONJ(J2),NEWATOM,NBEST

      ENDDO
!
!  CHOOSE NEWATOM STOCHASTICALLY. BIAS TOWARDS ATOMS WITH THE MAXIMUM CONSTRAINTS.
!  USE A NORMALISED PROBABILITY AND GENERATE A RANDOM NUMBER BETWEEN 0 AND 1.
!
      DUMMY2=0.0D0
      DO J2=1,NATOMS
         IF (NCONTOACTIVE(J2).EQ.0) CYCLE
         IF (ATOMACTIVE(J2)) CYCLE
!        DUMMY2=DUMMY2+((1.0D0*NCONTOACTIVE(J2))/(1.0D0*CONDISTREF(J2)*NTRIES(J2)))**4 
         DUMMY2=DUMMY2+((1.0D0*INVDTOACTIVE(J2))/(1.0D0*NTRIES(J2)))**4 
!        PRINT '(A,I6,A,G20.10)',' INTLBFGS> UNNORMALISED PROBABILITY FOR CHOOSING ATOM ',J2,' IS ', &
! &                ((1.0D0*INVDTOACTIVE(J2))/(1.0D0*NTRIES(J2)))**4
      ENDDO

      RANDOM=DUMMY2*DPRAND()
      DUMMY2=0.0D0
      CHOOSENEW: DO J2=1,NATOMS
         IF (NCONTOACTIVE(J2).EQ.0) CYCLE
         IF (ATOMACTIVE(J2)) CYCLE
!        DUMMY2=DUMMY2+((1.0D0*NCONTOACTIVE(J2))/(1.0D0*CONDISTREF(J2)*NTRIES(J2)))**4 
         DUMMY2=DUMMY2+((1.0D0*INVDTOACTIVE(J2))/(1.0D0*NTRIES(J2)))**4 
         IF (DUMMY2.GE.RANDOM) THEN
            NEWATOM=J2
            IF (DEBUG) PRINT '(3(A,I6))',' INTLBFGS> CHOOSING NEW ACTIVE ATOM ',NEWATOM,' NEW CONSTRAINTS=', &
  &                                       NCONTOACTIVE(J2),' MAXIMUM=',NBEST
            EXIT CHOOSENEW
         ENDIF
      ENDDO CHOOSENEW
          
      IF (NEWATOM*NBEST.EQ.0) THEN ! SANITY CHECK
         PRINT '(A,I6,A,2I6)',' INTLBFGS> ERROR *** NEW ACTIVE ATOM NOT SET'
         STOP
      ELSE
!
!  WE NEED A SORTED LIST OF UP TO 3 ACTIVE ATOMS, SORTED ACCORDING TO HOW WELL THE
!  END POINT DISTANCE IS PRESERVED, EVEN IF THEY DON'T SATISFY THE CONSTRAINT 
!  CONDITION. WE WANT THREE ATOMS TO USE FOR A LOCAL AXIS SYSTEM IN THE INTERPOLATION.
!
!  TRY SORTING ON THE SHORTEST AVERAGE DISTANCES IN THE ENDPOINT STRUCTURES INSTEAD, TO AVOID
!  PROBLEMS WITH DISTANT ATOMS ACIDENTALLY HAVING A WELL-PRESERVED DISTANCE.
!
         NDFORNEWATOM=0
         BESTPRESERVEDD(1:NATOMS)=1.0D100
         DO J1=1,NATOMS
            IF (.NOT.ATOMACTIVE(J1)) CYCLE
            DS=SQRT((XYZ(3*(NEWATOM-1)+1)-XYZ(3*(J1-1)+1))**2 &
  &                +(XYZ(3*(NEWATOM-1)+2)-XYZ(3*(J1-1)+2))**2 &
  &                +(XYZ(3*(NEWATOM-1)+3)-XYZ(3*(J1-1)+3))**2) 
            DF=SQRT((XYZ((INTIMAGE+1)*3*NATOMS+3*(NEWATOM-1)+1)-XYZ((INTIMAGE+1)*3*NATOMS+3*(J1-1)+1))**2 &
  &                +(XYZ((INTIMAGE+1)*3*NATOMS+3*(NEWATOM-1)+2)-XYZ((INTIMAGE+1)*3*NATOMS+3*(J1-1)+2))**2 &
  &                +(XYZ((INTIMAGE+1)*3*NATOMS+3*(NEWATOM-1)+3)-XYZ((INTIMAGE+1)*3*NATOMS+3*(J1-1)+3))**2) 
            DUMMY=ABS(DS-DF)
            NDFORNEWATOM=NDFORNEWATOM+1
            DO J2=1,NDFORNEWATOM 
               IF (DUMMY.LT.BESTPRESERVEDD(J2)) THEN
!                 PRINT '(A,I6,G12.4,I6,G12.4)','J1,DUMMY < J2,BESTPRESERVEDD: ',J1,DUMMY,J2,BESTPRESERVEDD(J2)
                  DO J3=NDFORNEWATOM,J2+1,-1 
!                    PRINT '(A,I6,A,I6,A,G12.4)',' MOVING DIFF AND LIST FROM ',J3-1,' TO ',J3, &
!&                                               ' DIFF=',BESTPRESERVEDD(J3-1)
                     BESTPRESERVEDD(J3)=BESTPRESERVEDD(J3-1)
                     BESTPRESERVEDN(J3)=BESTPRESERVEDN(J3-1)
                  ENDDO
                  BESTPRESERVEDD(J2)=DUMMY
!                 PRINT '(A,I6,A,G12.4)',' SETTING BESTPRESERVEDD ELEMENT ',J2,' TO ',DUMMY
                  BESTPRESERVEDN(J2)=J1
!                 PRINT '(A,I6,A,G12.4)',' SETTING BESTPRESERVEDN ELEMENT ',J2,' TO ',J1
                  GOTO 653
               ENDIF
            ENDDO
653         CONTINUE
         ENDDO
         IF (DEBUG) THEN
            PRINT '(A,I6,A,I6,A)',' INTLBFGS> NEW ACTIVE ATOM ',NEWATOM,' BEST PRESERVED DISTANCES:'
            PRINT '(20I6)',BESTPRESERVEDN(1:MIN(10,NDFORNEWATOM))
            PRINT '(A,I6,A,I6,A)',' INTLBFGS> SORTED DIFFERENCES:'
            PRINT '(10G12.4)',BESTPRESERVEDD(1:MIN(10,NDFORNEWATOM))
         ENDIF
         IF (FREEZENODEST) IMGFREEZE(1:INTIMAGE)=.FALSE.

         NCFORNEWATOM=0
         BESTCLOSESTD(1:NATOMS)=1.0D100
         DO J1=1,NATOMS
            IF (.NOT.ATOMACTIVE(J1)) CYCLE
            DS=SQRT((XYZ(3*(NEWATOM-1)+1)-XYZ(3*(J1-1)+1))**2 &
  &                +(XYZ(3*(NEWATOM-1)+2)-XYZ(3*(J1-1)+2))**2 &
  &                +(XYZ(3*(NEWATOM-1)+3)-XYZ(3*(J1-1)+3))**2) 
            DF=SQRT((XYZ((INTIMAGE+1)*3*NATOMS+3*(NEWATOM-1)+1)-XYZ((INTIMAGE+1)*3*NATOMS+3*(J1-1)+1))**2 &
  &                +(XYZ((INTIMAGE+1)*3*NATOMS+3*(NEWATOM-1)+2)-XYZ((INTIMAGE+1)*3*NATOMS+3*(J1-1)+2))**2 &
  &                +(XYZ((INTIMAGE+1)*3*NATOMS+3*(NEWATOM-1)+3)-XYZ((INTIMAGE+1)*3*NATOMS+3*(J1-1)+3))**2) 
            DUMMY=(DS+DF)/2.0D0
            NCFORNEWATOM=NCFORNEWATOM+1
            DO J2=1,NCFORNEWATOM
               IF (DUMMY.LT.BESTCLOSESTD(J2)) THEN
!                 PRINT '(A,I6,G12.4,I6,G12.4)','J1,DUMMY < J2,BESTCLOSESTD: ',J1,DUMMY,J2,BESTCLOSESTD(J2)
                  DO J3=NCFORNEWATOM,J2+1,-1
!                    PRINT '(A,I6,A,I6,A,G12.4)',' MOVING DIFF AND LIST FROM ',J3-1,' TO ',J3, &
!&                                               ' DIFF=',BESTCLOSESTD(J3-1)
                     BESTCLOSESTD(J3)=BESTCLOSESTD(J3-1)
                     BESTCLOSESTN(J3)=BESTCLOSESTN(J3-1)
                  ENDDO
                  BESTCLOSESTD(J2)=DUMMY
!                 PRINT '(A,I6,A,G12.4)',' SETTING BESTCLOSESTD ELEMENT ',J2,' TO ',DUMMY
                  BESTCLOSESTN(J2)=J1
!                 PRINT '(A,I6,A,G12.4)',' SETTING BESTCLOSESTN ELEMENT ',J2,' TO ',J1
                  GOTO 659
               ENDIF
            ENDDO
659         CONTINUE
         ENDDO
         IF (DEBUG) THEN
            PRINT '(A,I6,A,I6,A)',' INTLBFGS> NEW ACTIVE ATOM ',NEWATOM,' SHORTEST AVERAGE DISTANCES IN ENDPOINTS:'
            PRINT '(20I6)',BESTCLOSESTN(1:MIN(10,NCFORNEWATOM))
            PRINT '(A,I6,A,I6,A)',' INTLBFGS> SORTED DIFFERENCES:'
            PRINT '(10G12.4)',BESTCLOSESTN(1:MIN(10,NCFORNEWATOM))
         ENDIF
!
!  MAINTAIN A SORTED LIST OF ACTIVE ATOMS THAT ARE CONSTRAINED TO THE NEW ATOM, SORTED
!  ACCORDING TO THEIR DISTANCE.
!
         NCONFORNEWATOM=0
         CONDIST(1:NATOMS)=1.0D100
         IF (DEBUG) PRINT '(3(A,I6))',' INTLBFGS> NEW ACTIVE ATOM IS NUMBER ',NEWATOM,' TOTAL=',NACTIVE+1, &
 &                        ' STEPS=',NITERDONE
         DO J1=1,NCONSTRAINT
            IF (CONACTIVE(J1)) CYCLE
            IF ((CONI(J1).EQ.NEWATOM).AND.(ATOMACTIVE(CONJ(J1))).OR.(CONJ(J1).EQ.NEWATOM).AND.(ATOMACTIVE(CONI(J1)))) THEN  
                 NCONFORNEWATOM=NCONFORNEWATOM+1
!                CONACTIVE(J1)=.TRUE.
!                NITSTART(J1)=NITERDONE
!                NCONSTRAINTON=NCONSTRAINTON+1
! !
! ! THE ...ON VARIABLES ARE NOT ACTUALLY USED IN CONGRAD.F90.
! !
!                CONDISTREFLOCALON(NCONSTRAINTON)=CONDISTREFLOCAL(J1)
!                CONDISTREFON(NCONSTRAINTON)=CONDISTREF(J1)
!                CONION(NCONSTRAINTON)=CONI(J1)
!                CONJON(NCONSTRAINTON)=CONJ(J1)
! 
!                IF (DEBUG) PRINT '(A,I6,A,2I6)',' INTLBFGS> TURNING ON CONSTRAINT ',J1,' FOR ATOMS ',CONI(J1),CONJ(J1)
               IF (NCONFORNEWATOM.EQ.1) THEN
                  CONDIST(1)=CONDISTREF(J1)
                  IF (CONI(J1).EQ.NEWATOM) CONLIST(1)=CONJ(J1)
                  IF (CONJ(J1).EQ.NEWATOM) CONLIST(1)=CONI(J1)
               ENDIF
               DO J2=1,NCONFORNEWATOM-1
                  IF (CONDISTREF(J1).LT.CONDIST(J2)) THEN
!                    PRINT '(A,I6,G12.4,I6,G12.4)','J1,CONDISTREF < J2,CONDIST: ',J1,CONDISTREF(J1),J2,CONDIST(J2)
                     DO J3=NCONFORNEWATOM,J2+1,-1
!                       PRINT '(A,I6,A,I6,A,G12.4)',' MOVING DIST AND LIST FROM ',J3-1,' TO ',J3,' CONDIST=',CONDIST(J3-1)
                        CONDIST(J3)=CONDIST(J3-1)
                        CONLIST(J3)=CONLIST(J3-1)
                     ENDDO
                     CONDIST(J2)=CONDISTREF(J1)
!                    PRINT '(A,I6,A,G12.4)',' SETTING CONDIST ELEMENT ',J2,' TO ',CONDISTREF(J1)
                     IF (CONI(J1).EQ.NEWATOM) CONLIST(J2)=CONJ(J1)
                     IF (CONJ(J1).EQ.NEWATOM) CONLIST(J2)=CONI(J1)
!                    PRINT '(A,I6,A,G12.4)',' SETTING CONLIST ELEMENT ',J2,' TO ',CONLIST(J2)
                     GOTO 654
                  ENDIF
               ENDDO 
               CONDIST(NCONFORNEWATOM)=CONDISTREF(J1)
!              PRINT '(A,I6,A,G12.4)',' SETTING CONDIST ELEMENT ',NCONFORNEWATOM,' TO ',CONDISTREF(J1)
               IF (CONI(J1).EQ.NEWATOM) CONLIST(NCONFORNEWATOM)=CONJ(J1)
               IF (CONJ(J1).EQ.NEWATOM) CONLIST(NCONFORNEWATOM)=CONI(J1)
!              PRINT '(A,I6,A,G12.4)',' SETTING CONLIST ELEMENT ',NCONFORNEWATOM,' TO ',CONLIST(NCONFORNEWATOM)
654          CONTINUE
            ENDIF
         ENDDO 
         IF (DEBUG) THEN
            PRINT '(A,I6,A,I6,A)',' INTLBFGS> NEW ACTIVE ATOM ',NEWATOM,' IS CONSTRAINED TO ',NCONFORNEWATOM,' OTHER ACTIVE ATOMS:'
            PRINT '(20I6)',CONLIST(1:NCONFORNEWATOM)
            PRINT '(A,I6,A,I6,A)',' INTLBFGS> SORTED DISTANCES:'
            PRINT '(10G12.4)',CONDIST(1:NCONFORNEWATOM)
         ENDIF
         DO J1=1,MIN(MAXCONUSE,NCONFORNEWATOM)
            DO J2=1,NCONSTRAINT
               IF ((CONI(J2).EQ.NEWATOM).AND.(CONJ(J2).EQ.CONLIST(J1))) THEN
                     CONACTIVE(J2)=.TRUE.
                     NCONATOM(CONI(J2))=NCONATOM(CONI(J2))+1
                     NCONATOM(CONJ(J2))=NCONATOM(CONJ(J2))+1
                     IF (DEBUG) PRINT '(A,I6,A,2I6)',' INTLBFGS> TURNING ON CONSTRAINT ',J2,' FOR ATOMS ',CONI(J2),CONJ(J2)
               ELSE IF ((CONJ(J2).EQ.NEWATOM).AND.(CONI(J2).EQ.CONLIST(J1))) THEN
                     CONACTIVE(J2)=.TRUE.
                     NCONATOM(CONI(J2))=NCONATOM(CONI(J2))+1
                     NCONATOM(CONJ(J2))=NCONATOM(CONJ(J2))+1
                     IF (DEBUG) PRINT '(A,I6,A,2I6)',' INTLBFGS> TURNING ON CONSTRAINT ',J2,' FOR ATOMS ',CONI(J2),CONJ(J2)
               ENDIF
            ENDDO
         ENDDO
         DO J1=1,NATOMS
            IF (.NOT.ATOMACTIVE(J1)) CYCLE ! IDENTIFY ACTIVE ATOMS
            IF (ABS(J1-NEWATOM).LE.INTREPSEP) CYCLE ! NO REPULSION FOR ATOMS TOO CLOSE IN SEQUENCE
            DO J2=1,NCONSTRAINT
!
!  WITH MAXCONUSE SET TO A FINITE VALUE THERE COULD BE CONSTRAINTS FOR THE NEW ATOM THAT ARE
!  NOT ACTIVE. WE DON'T WANT THESE TO BE CHANGED TO REPULSION, SURELY?!
!  OR PERHAPS WE DO NEED TO DO SOMETHING WITH THEM?
!
               IF (.NOT.CONACTIVE(J2)) CYCLE ! IDENTIFY ACTIVE CONSTRAINTS 
               IF (((CONI(J2).EQ.J1).AND.(CONJ(J2).EQ.NEWATOM)).OR.((CONJ(J2).EQ.J1).AND.(CONI(J2).EQ.NEWATOM))) GOTO 543
            ENDDO
            DMIN=1.0D100
            DMAX=-1.0D0
            DO J2=1,INTIMAGE+2,INTIMAGE+1 ! ONLY CONSIDER THE END-POINT DISTANCES
               DF=SQRT((XYZ((J2-1)*3*NATOMS+3*(NEWATOM-1)+1)-XYZ((J2-1)*3*NATOMS+3*(J1-1)+1))**2+ &
  &                    (XYZ((J2-1)*3*NATOMS+3*(NEWATOM-1)+2)-XYZ((J2-1)*3*NATOMS+3*(J1-1)+2))**2+ &
  &                    (XYZ((J2-1)*3*NATOMS+3*(NEWATOM-1)+3)-XYZ((J2-1)*3*NATOMS+3*(J1-1)+3))**2)
               IF (DF.GT.DMAX) DMAX=DF
               IF (DF.LT.DMIN) DMIN=DF
            ENDDO
!
! USE THE MINIMUM OF THE END POINT DISTANCES AND INTCONSTRAINREPCUT FOR EACH CONTACT.
!
            DMIN=MIN(DMIN-1.0D-3,INTCONSTRAINREPCUT)
            NREPULSIVE=NREPULSIVE+1
            IF (NREPULSIVE.GT.NREPMAX) THEN
               ALLOCATE(IREPTEMP(NREPMAX),REPTEMP(NREPMAX))

               IREPTEMP(1:NREPMAX)=REPI(1:NREPMAX)
               DEALLOCATE(REPI)
               ALLOCATE(REPI(2*NREPMAX))
               REPI(1:NREPMAX)=IREPTEMP(1:NREPMAX)
               IREPTEMP(1:NREPMAX)=REPJ(1:NREPMAX)
               DEALLOCATE(REPJ)
               ALLOCATE(REPJ(2*NREPMAX))
               REPJ(1:NREPMAX)=IREPTEMP(1:NREPMAX)
               REPTEMP(1:NREPMAX)=REPCUT(1:NREPMAX)
               DEALLOCATE(REPCUT)
               ALLOCATE(REPCUT(2*NREPMAX))
               REPCUT(1:NREPMAX)=REPTEMP(1:NREPMAX)

               IREPTEMP(1:NREPMAX)=NREPI(1:NREPMAX)
               DEALLOCATE(NREPI)
               ALLOCATE(NREPI(2*NREPMAX))
               NREPI(1:NREPMAX)=IREPTEMP(1:NREPMAX)
               IREPTEMP(1:NREPMAX)=NREPJ(1:NREPMAX)
               DEALLOCATE(NREPJ)
               ALLOCATE(NREPJ(2*NREPMAX))
               NREPJ(1:NREPMAX)=IREPTEMP(1:NREPMAX)
               REPTEMP(1:NREPMAX)=NREPCUT(1:NREPMAX)
               DEALLOCATE(NREPCUT)
               ALLOCATE(NREPCUT(2*NREPMAX))
               NREPCUT(1:NREPMAX)=REPTEMP(1:NREPMAX)

               DEALLOCATE(IREPTEMP,REPTEMP)
               NREPMAX=2*NREPMAX
            ENDIF
            REPI(NREPULSIVE)=J1
            REPJ(NREPULSIVE)=NEWATOM
            REPCUT(NREPULSIVE)=DMIN
            IF (DEBUG) PRINT '(A,I6,A,I6,A,F15.5)',' INTLBFGS> ADDING REPULSION FOR NEW ATOM ',NEWATOM,' WITH ATOM ',J1, &
  &                                                   ' CUTOFF=',DMIN
543         CONTINUE
         ENDDO
         ATOMACTIVE(NEWATOM)=.TRUE.
         NACTIVE=NACTIVE+1

         NDUMMY=0
         DO J1=1,NATOMS
            IF (ATOMACTIVE(J1)) NDUMMY=NDUMMY+1
         ENDDO
         IF (NDUMMY.NE.NACTIVE) THEN
            PRINT '(A,I6)',' INTLBFGS> ERROR *** INCONSISTENCY IN NUMBER OF ACTIVE ATOMS. SHOULD BE ',NACTIVE
            DO J1=1,NATOMS
               IF (ATOMACTIVE(J1)) PRINT '(A,I6)',' ACTIVE ATOM ',J1
            ENDDO
            STOP
         ENDIF

         TURNONORDER(NACTIVE)=NEWATOM
!
! INITIAL GUESS FOR NEW ACTIVE ATOM POSITION. THIS IS CRUCIAL FOR SUCCESS IN INTCONSTRAINT SCHEMES!
!
         ESAVED=1.0D100
         ESAVE0=1.0D100
         ESAVEC=1.0D100
         IF (NCONFORNEWATOM.GE.3) THEN
!
! MOVE THE NEW ATOM CONSISTENTLY IN THE LOCAL ENVIRONMENT OF ITS THREE NEAREST ACTIVELY CONSTRAINED ATOMS.
! MAKE A LOCAL ORTHOGONAL COORDINATE SYSTEM AND USE CONSTANT COMPONENTS IN THIS BASIS.
!
            IF (DEBUG) PRINT '(A)',' INTLBFGS> INITIAL GUESS FROM CLOSEST THREE CONSTRAINED ACTIVE ATOMS'
            VEC1(1:3)=XYZ(3*(CONLIST(2)-1)+1:3*(CONLIST(2)-1)+3)-XYZ(3*(CONLIST(1)-1)+1:3*(CONLIST(1)-1)+3)
            DUMMY=SQRT(VEC1(1)**2+VEC1(2)**2+VEC1(3)**2)
            IF (DUMMY.NE.0.0D0) VEC1(1:3)=VEC1(1:3)/DUMMY
            VEC2(1:3)=XYZ(3*(CONLIST(3)-1)+1:3*(CONLIST(3)-1)+3)-XYZ(3*(CONLIST(1)-1)+1:3*(CONLIST(1)-1)+3)
            DUMMY=VEC1(1)*VEC2(1)+VEC1(2)*VEC2(2)+VEC1(3)*VEC2(3)
            VEC2(1:3)=VEC2(1:3)-DUMMY*VEC1(1:3)
            DUMMY=SQRT(VEC2(1)**2+VEC2(2)**2+VEC2(3)**2)
            IF (DUMMY.NE.0.0D0) VEC2(1:3)=VEC2(1:3)/DUMMY
            VEC3(1)= VEC1(2)*VEC2(3)-VEC1(3)*VEC2(2)
            VEC3(2)=-VEC1(1)*VEC2(3)+VEC1(3)*VEC2(1)
            VEC3(3)= VEC1(1)*VEC2(2)-VEC1(2)*VEC2(1)
            C1=(XYZ(3*(NEWATOM-1)+1)-XYZ(3*(CONLIST(1)-1)+1))*VEC1(1)+ &
  &            (XYZ(3*(NEWATOM-1)+2)-XYZ(3*(CONLIST(1)-1)+2))*VEC1(2)+ &
  &            (XYZ(3*(NEWATOM-1)+3)-XYZ(3*(CONLIST(1)-1)+3))*VEC1(3)
            C2=(XYZ(3*(NEWATOM-1)+1)-XYZ(3*(CONLIST(1)-1)+1))*VEC2(1)+ &
  &            (XYZ(3*(NEWATOM-1)+2)-XYZ(3*(CONLIST(1)-1)+2))*VEC2(2)+ &
  &            (XYZ(3*(NEWATOM-1)+3)-XYZ(3*(CONLIST(1)-1)+3))*VEC2(3)
            C3=(XYZ(3*(NEWATOM-1)+1)-XYZ(3*(CONLIST(1)-1)+1))*VEC3(1)+ &
  &            (XYZ(3*(NEWATOM-1)+2)-XYZ(3*(CONLIST(1)-1)+2))*VEC3(2)+ &
  &            (XYZ(3*(NEWATOM-1)+3)-XYZ(3*(CONLIST(1)-1)+3))*VEC3(3)
            DO J1=2,INTIMAGE+1
               VEC1(1:3)=XYZ((J1-1)*3*NATOMS+3*(CONLIST(2)-1)+1:(J1-1)*3*NATOMS+3*(CONLIST(2)-1)+3) &
  &                     -XYZ((J1-1)*3*NATOMS+3*(CONLIST(1)-1)+1:(J1-1)*3*NATOMS+3*(CONLIST(1)-1)+3)
               DUMMY=SQRT(VEC1(1)**2+VEC1(2)**2+VEC1(3)**2)
               IF (DUMMY.NE.0.0D0) VEC1(1:3)=VEC1(1:3)/DUMMY
               VEC2(1:3)=XYZ((J1-1)*3*NATOMS+3*(CONLIST(3)-1)+1:(J1-1)*3*NATOMS+3*(CONLIST(3)-1)+3) &
  &                     -XYZ((J1-1)*3*NATOMS+3*(CONLIST(1)-1)+1:(J1-1)*3*NATOMS+3*(CONLIST(1)-1)+3)
               DUMMY=VEC1(1)*VEC2(1)+VEC1(2)*VEC2(2)+VEC1(3)*VEC2(3)
               VEC2(1:3)=VEC2(1:3)-DUMMY*VEC1(1:3)
               DUMMY=SQRT(VEC2(1)**2+VEC2(2)**2+VEC2(3)**2)
               IF (DUMMY.NE.0.0D0) VEC2(1:3)=VEC2(1:3)/DUMMY
               VEC3(1)= VEC1(2)*VEC2(3)-VEC1(3)*VEC2(2)
               VEC3(2)=-VEC1(1)*VEC2(3)+VEC1(3)*VEC2(1)
               VEC3(3)= VEC1(1)*VEC2(2)-VEC1(2)*VEC2(1)
               XYZ((J1-1)*3*NATOMS+3*(NEWATOM-1)+1:(J1-1)*3*NATOMS+3*(NEWATOM-1)+3)= &
  &            XYZ((J1-1)*3*NATOMS+3*(CONLIST(1)-1)+1:(J1-1)*3*NATOMS+3*(CONLIST(1)-1)+3)+C1*VEC1(1:3)+C2*VEC2(1:3)+C3*VEC3(1:3)
            ENDDO
            CALL CHECKREP(INTIMAGE,XYZ,NOPT) ! SET UP REPULSIVE NEIGHBOUR LIST
            IF (CHECKCONINT) THEN
               CALL CONGRAD2(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
            ELSE
               CALL CONGRAD(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
            ENDIF
            ESAVE0=ETOTAL
            DO J1=2,INTIMAGE+1
               XSAVE0(1:3,J1)=XYZ((J1-1)*3*NATOMS+3*(NEWATOM-1)+1:(J1-1)*3*NATOMS+3*(NEWATOM-1)+3)
            ENDDO
         ENDIF
         IF (NDFORNEWATOM.GE.3) THEN
!
! CHOOSE THREE ATOMS FROM THE BESTPRESERVEDN LIST AT RANDOM WITH BIAS TOWARDS THE 
! START OF THE LIST. LET THE RELATIVE WEIGHT FOR POSITION I BE 1/I**2 AND CALCULATE
! THE SUM TO NORMALISE.
!
            DUMMY=0.0D0
            DO J1=1,NDFORNEWATOM
!              DUMMY=DUMMY+1.0D0/(1.0D0*J1)
!              DUMMY=DUMMY+1.0D0/(1.0D0*BESTPRESERVEDD(J1))
               DUMMY=DUMMY+1.0D0/(1.0D0*J1**2)
            ENDDO
            N1=0; N2=0; N3=0
            DO WHILE (N3.EQ.0)
               DUMMY2=0.0D0
               RAN1=DPRAND()*DUMMY
               DO J1=1,NDFORNEWATOM
!                 DUMMY2=DUMMY2+1.0D0/(1.0D0*J1)
!                 DUMMY2=DUMMY2+1.0D0/(1.0D0*BESTPRESERVEDD(J1))
                  DUMMY2=DUMMY2+1.0D0/(1.0D0*J1**2)
                  IF (DUMMY2.GE.RAN1) THEN
                     IF ((J1.EQ.N1).OR.(J1.EQ.N2)) EXIT ! ALREADY CHOSEN
                     IF (N1.EQ.0) THEN
                        N1=J1
                        EXIT
                     ENDIF
                     IF (N2.EQ.0) THEN
                        N2=J1
                        EXIT
                     ENDIF
                     N3=J1
                     EXIT
                  ENDIF
               ENDDO
            ENDDO
            IF (DEBUG) PRINT '(A,3I6,A)',' INTLBFGS> CHOOSING POSITIONS ',N1,N2,N3,' IN BEST PRESERVED LIST'
            IF (DEBUG) PRINT '(A,3I6)',' INTLBFGS> ATOMS ARE ',BESTPRESERVEDN(N1),BESTPRESERVEDN(N2),BESTPRESERVEDN(N3)
!           IF (DEBUG) PRINT '(A,3I6,A)',' INTLBFGS> FULL LIST HAS LENGTH ',NDFORNEWATOM
!           IF (DEBUG) PRINT '(20I6)',BESTPRESERVEDN(1:NDFORNEWATOM)

!
! MOVE THE NEW ATOM CONSISTENTLY IN THE LOCAL ENVIRONMENT OF THE THREE ACTIVE ATOMS WITH THE
! BEST PRESERVED ABSOLUTE DISTANCES OR THE SHORTEST AVERAGE DISTANCES IN THE END POINTS.
! CHECK THE ENERGIES AND COMPARE LINEAR INTERPOLATION AS WELL, THEN CHOOSE THE INTERPOLATION
! WITH THE LOWEST ENERGY.
! MAKE A LOCAL ORTHOGONAL COORDINATE SYSTEM AND USE CONSTANT COMPONENTS IN THIS BASIS.
!
            VEC1(1:3)=XYZ(3*(BESTPRESERVEDN(N2)-1)+1:3*(BESTPRESERVEDN(N2)-1)+3) &
  &                  -XYZ(3*(BESTPRESERVEDN(N1)-1)+1:3*(BESTPRESERVEDN(N1)-1)+3)
            DUMMY=SQRT(VEC1(1)**2+VEC1(2)**2+VEC1(3)**2)
            IF (DUMMY.NE.0.0D0) VEC1(1:3)=VEC1(1:3)/DUMMY
            VEC2(1:3)=XYZ(3*(BESTPRESERVEDN(N3)-1)+1:3*(BESTPRESERVEDN(N3)-1)+3) &
  &                  -XYZ(3*(BESTPRESERVEDN(N1)-1)+1:3*(BESTPRESERVEDN(N1)-1)+3)
            DUMMY=VEC1(1)*VEC2(1)+VEC1(2)*VEC2(2)+VEC1(3)*VEC2(3)
            VEC2(1:3)=VEC2(1:3)-DUMMY*VEC1(1:3)
            DUMMY=SQRT(VEC2(1)**2+VEC2(2)**2+VEC2(3)**2)
            IF (DUMMY.NE.0.0D0) VEC2(1:3)=VEC2(1:3)/DUMMY
            VEC3(1)= VEC1(2)*VEC2(3)-VEC1(3)*VEC2(2)
            VEC3(2)=-VEC1(1)*VEC2(3)+VEC1(3)*VEC2(1)
            VEC3(3)= VEC1(1)*VEC2(2)-VEC1(2)*VEC2(1)
            C1=(XYZ(3*(NEWATOM-1)+1)-XYZ(3*(BESTPRESERVEDN(N1)-1)+1))*VEC1(1)+ &
  &            (XYZ(3*(NEWATOM-1)+2)-XYZ(3*(BESTPRESERVEDN(N1)-1)+2))*VEC1(2)+ &
  &            (XYZ(3*(NEWATOM-1)+3)-XYZ(3*(BESTPRESERVEDN(N1)-1)+3))*VEC1(3)
            C2=(XYZ(3*(NEWATOM-1)+1)-XYZ(3*(BESTPRESERVEDN(N1)-1)+1))*VEC2(1)+ &
  &            (XYZ(3*(NEWATOM-1)+2)-XYZ(3*(BESTPRESERVEDN(N1)-1)+2))*VEC2(2)+ &
  &            (XYZ(3*(NEWATOM-1)+3)-XYZ(3*(BESTPRESERVEDN(N1)-1)+3))*VEC2(3)
            C3=(XYZ(3*(NEWATOM-1)+1)-XYZ(3*(BESTPRESERVEDN(N1)-1)+1))*VEC3(1)+ &
  &            (XYZ(3*(NEWATOM-1)+2)-XYZ(3*(BESTPRESERVEDN(N1)-1)+2))*VEC3(2)+ &
  &            (XYZ(3*(NEWATOM-1)+3)-XYZ(3*(BESTPRESERVEDN(N1)-1)+3))*VEC3(3)
            DO J1=2,INTIMAGE+1
               VEC1(1:3)=XYZ((J1-1)*3*NATOMS+3*(BESTPRESERVEDN(N2)-1)+1:(J1-1)*3*NATOMS+3*(BESTPRESERVEDN(N2)-1)+3) &
  &                     -XYZ((J1-1)*3*NATOMS+3*(BESTPRESERVEDN(N1)-1)+1:(J1-1)*3*NATOMS+3*(BESTPRESERVEDN(N1)-1)+3)
               DUMMY=SQRT(VEC1(1)**2+VEC1(2)**2+VEC1(3)**2)
               IF (DUMMY.NE.0.0D0) VEC1(1:3)=VEC1(1:3)/DUMMY
               VEC2(1:3)=XYZ((J1-1)*3*NATOMS+3*(BESTPRESERVEDN(N3)-1)+1:(J1-1)*3*NATOMS+3*(BESTPRESERVEDN(N3)-1)+3) &
  &                     -XYZ((J1-1)*3*NATOMS+3*(BESTPRESERVEDN(N1)-1)+1:(J1-1)*3*NATOMS+3*(BESTPRESERVEDN(N1)-1)+3)
               DUMMY=VEC1(1)*VEC2(1)+VEC1(2)*VEC2(2)+VEC1(3)*VEC2(3)
               VEC2(1:3)=VEC2(1:3)-DUMMY*VEC1(1:3)
               DUMMY=SQRT(VEC2(1)**2+VEC2(2)**2+VEC2(3)**2)
               IF (DUMMY.NE.0.0D0) VEC2(1:3)=VEC2(1:3)/DUMMY
               VEC3(1)= VEC1(2)*VEC2(3)-VEC1(3)*VEC2(2)
               VEC3(2)=-VEC1(1)*VEC2(3)+VEC1(3)*VEC2(1)
               VEC3(3)= VEC1(1)*VEC2(2)-VEC1(2)*VEC2(1)
               XYZ((J1-1)*3*NATOMS+3*(NEWATOM-1)+1:(J1-1)*3*NATOMS+3*(NEWATOM-1)+3)= &
  &            XYZ((J1-1)*3*NATOMS+3*(BESTPRESERVEDN(N1)-1)+1:(J1-1)*3*NATOMS+3*(BESTPRESERVEDN(N1)-1)+3)+ &
  &                   C1*VEC1(1:3)+C2*VEC2(1:3)+C3*VEC3(1:3)
            ENDDO

            CALL CHECKREP(INTIMAGE,XYZ,NOPT) ! SET UP REPULSIVE NEIGHBOUR LIST
            IF (CHECKCONINT) THEN
               CALL CONGRAD2(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
            ELSE
               CALL CONGRAD(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
            ENDIF
            ESAVED=ETOTAL
            DO J1=2,INTIMAGE+1
               XSAVED(1:3,J1)=XYZ((J1-1)*3*NATOMS+3*(NEWATOM-1)+1:(J1-1)*3*NATOMS+3*(NEWATOM-1)+3)
            ENDDO
         ENDIF

         IF (NCFORNEWATOM.GE.3) THEN
!
! CHOOSE THREE ATOMS FROM THE BESTCLOSEST LIST AT RANDOM WITH BIAS TOWARDS THE
! START OF THE LIST. LET THE RELATIVE WEIGHT FOR POSITION I BE 1/I**2 AND CALCULATE
! THE SUM TO NORMALISE.
!
            DUMMY=0.0D0
            DO J1=1,NCFORNEWATOM
!              DUMMY=DUMMY+1.0D0/(1.0D0*J1)
!              DUMMY=DUMMY+1.0D0/(1.0D0*BESTCLOSESTD(J1))
               DUMMY=DUMMY+1.0D0/(1.0D0*J1**2)
            ENDDO
            N1=0; N2=0; N3=0
            DO WHILE (N3.EQ.0)
               DUMMY2=0.0D0
               RAN1=DPRAND()*DUMMY
               DO J1=1,NCFORNEWATOM
!                 DUMMY2=DUMMY2+1.0D0/(1.0D0*J1)
!                 DUMMY2=DUMMY2+1.0D0/(1.0D0*BESTCLOSESTD(J1))
                  DUMMY2=DUMMY2+1.0D0/(1.0D0*J1**2)
                  IF (DUMMY2.GE.RAN1) THEN
                     IF ((J1.EQ.N1).OR.(J1.EQ.N2)) EXIT ! ALREADY CHOSEN
                     IF (N1.EQ.0) THEN
                        N1=J1
                        EXIT
                     ENDIF
                     IF (N2.EQ.0) THEN
                        N2=J1
                        EXIT
                     ENDIF
                     N3=J1
                     EXIT
                  ENDIF
               ENDDO
            ENDDO
            IF (DEBUG) PRINT '(A,3I6,A)',' INTLBFGS> CHOOSING POSITIONS ',N1,N2,N3,' IN CLOSEST LIST'

            VEC1(1:3)=XYZ(3*(BESTCLOSESTN(N2)-1)+1:3*(BESTCLOSESTN(N2)-1)+3)-XYZ(3*(BESTCLOSESTN(N1)-1)+1:3*(BESTCLOSESTN(N1)-1)+3)
            DUMMY=SQRT(VEC1(1)**2+VEC1(2)**2+VEC1(3)**2)
            IF (DUMMY.NE.0.0D0) VEC1(1:3)=VEC1(1:3)/DUMMY
            VEC2(1:3)=XYZ(3*(BESTCLOSESTN(N3)-1)+1:3*(BESTCLOSESTN(N3)-1)+3)-XYZ(3*(BESTCLOSESTN(N1)-1)+1:3*(BESTCLOSESTN(N1)-1)+3)
            DUMMY=VEC1(1)*VEC2(1)+VEC1(2)*VEC2(2)+VEC1(3)*VEC2(3)
            VEC2(1:3)=VEC2(1:3)-DUMMY*VEC1(1:3)
            DUMMY=SQRT(VEC2(1)**2+VEC2(2)**2+VEC2(3)**2)
            IF (DUMMY.NE.0.0D0) VEC2(1:3)=VEC2(1:3)/DUMMY
            VEC3(1)= VEC1(2)*VEC2(3)-VEC1(3)*VEC2(2)
            VEC3(2)=-VEC1(1)*VEC2(3)+VEC1(3)*VEC2(1)
            VEC3(3)= VEC1(1)*VEC2(2)-VEC1(2)*VEC2(1)
            C1=(XYZ(3*(NEWATOM-1)+1)-XYZ(3*(BESTCLOSESTN(N1)-1)+1))*VEC1(1)+ &
  &            (XYZ(3*(NEWATOM-1)+2)-XYZ(3*(BESTCLOSESTN(N1)-1)+2))*VEC1(2)+ &
  &            (XYZ(3*(NEWATOM-1)+3)-XYZ(3*(BESTCLOSESTN(N1)-1)+3))*VEC1(3)
            C2=(XYZ(3*(NEWATOM-1)+1)-XYZ(3*(BESTCLOSESTN(N1)-1)+1))*VEC2(1)+ &
  &            (XYZ(3*(NEWATOM-1)+2)-XYZ(3*(BESTCLOSESTN(N1)-1)+2))*VEC2(2)+ &
  &            (XYZ(3*(NEWATOM-1)+3)-XYZ(3*(BESTCLOSESTN(N1)-1)+3))*VEC2(3)
            C3=(XYZ(3*(NEWATOM-1)+1)-XYZ(3*(BESTCLOSESTN(N1)-1)+1))*VEC3(1)+ &
  &            (XYZ(3*(NEWATOM-1)+2)-XYZ(3*(BESTCLOSESTN(N1)-1)+2))*VEC3(2)+ &
  &            (XYZ(3*(NEWATOM-1)+3)-XYZ(3*(BESTCLOSESTN(N1)-1)+3))*VEC3(3)
            DO J1=2,INTIMAGE+1
               VEC1(1:3)=XYZ((J1-1)*3*NATOMS+3*(BESTCLOSESTN(N2)-1)+1:(J1-1)*3*NATOMS+3*(BESTCLOSESTN(N2)-1)+3) &
  &                     -XYZ((J1-1)*3*NATOMS+3*(BESTCLOSESTN(N1)-1)+1:(J1-1)*3*NATOMS+3*(BESTCLOSESTN(N1)-1)+3)
               DUMMY=SQRT(VEC1(1)**2+VEC1(2)**2+VEC1(3)**2)
               IF (DUMMY.NE.0.0D0) VEC1(1:3)=VEC1(1:3)/DUMMY
               VEC2(1:3)=XYZ((J1-1)*3*NATOMS+3*(BESTCLOSESTN(N3)-1)+1:(J1-1)*3*NATOMS+3*(BESTCLOSESTN(N3)-1)+3) &
  &                     -XYZ((J1-1)*3*NATOMS+3*(BESTCLOSESTN(N1)-1)+1:(J1-1)*3*NATOMS+3*(BESTCLOSESTN(N1)-1)+3)
               DUMMY=VEC1(1)*VEC2(1)+VEC1(2)*VEC2(2)+VEC1(3)*VEC2(3)
               VEC2(1:3)=VEC2(1:3)-DUMMY*VEC1(1:3)
               DUMMY=SQRT(VEC2(1)**2+VEC2(2)**2+VEC2(3)**2)
               IF (DUMMY.NE.0.0D0) VEC2(1:3)=VEC2(1:3)/DUMMY
               VEC3(1)= VEC1(2)*VEC2(3)-VEC1(3)*VEC2(2)
               VEC3(2)=-VEC1(1)*VEC2(3)+VEC1(3)*VEC2(1)
               VEC3(3)= VEC1(1)*VEC2(2)-VEC1(2)*VEC2(1)
               XYZ((J1-1)*3*NATOMS+3*(NEWATOM-1)+1:(J1-1)*3*NATOMS+3*(NEWATOM-1)+3)= &
  &            XYZ((J1-1)*3*NATOMS+3*(BESTCLOSESTN(N1)-1)+1:(J1-1)*3*NATOMS+3*(BESTCLOSESTN(N1)-1)+3)+ &
  &                   C1*VEC1(1:3)+C2*VEC2(1:3)+C3*VEC3(1:3)
            ENDDO

            CALL CHECKREP(INTIMAGE,XYZ,NOPT) ! SET UP REPULSIVE NEIGHBOUR LIST
            IF (CHECKCONINT) THEN
               CALL CONGRAD2(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
            ELSE
               CALL CONGRAD(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
            ENDIF
            ESAVEC=ETOTAL
            DO J1=2,INTIMAGE+1
               XSAVEC(1:3,J1)=XYZ((J1-1)*3*NATOMS+3*(NEWATOM-1)+1:(J1-1)*3*NATOMS+3*(NEWATOM-1)+3)
            ENDDO
         ENDIF
!
! STANDARD LINEAR INTERPOLATION, WITH CONSTRAINT DISTANCE SCALED BY FRAC.
! WORKS FOR FRAC AS SMALL AS 0.1 WITH REPULSION TURNED OFF.
! WE USE AN APPROPRIATELY WEIGHTED DISPLACEMENT FROM ATOM CONLIST(1) USING THE DISPLACEMENTS
! IN THE TWO END POINTS.
!
         FRAC=1.0D0
         DO J1=2,INTIMAGE+1
            XYZ((J1-1)*3*NATOMS+3*(NEWATOM-1)+1)=XYZ((J1-1)*3*NATOMS+3*(CONLIST(1)-1)+1)  &
 &            +(INTIMAGE-J1+2)*FRAC*(XYZ(3*(NEWATOM-1)+1)-XYZ(3*(CONLIST(1)-1)+1))/(INTIMAGE+1) &
 &   +(J1-1)*(XYZ(3*NATOMS*(INTIMAGE+1)+3*(NEWATOM-1)+1)-XYZ(3*NATOMS*(INTIMAGE+1)+3*(CONLIST(1)-1)+1))/(INTIMAGE+1)
            XYZ((J1-1)*3*NATOMS+3*(NEWATOM-1)+2)=XYZ((J1-1)*3*NATOMS+3*(CONLIST(1)-1)+2)  &
 &            +(INTIMAGE-J1+2)*FRAC*(XYZ(3*(NEWATOM-1)+2)-XYZ(3*(CONLIST(1)-1)+2))/(INTIMAGE+1) &
 &   +(J1-1)*(XYZ(3*NATOMS*(INTIMAGE+1)+3*(NEWATOM-1)+2)-XYZ(3*NATOMS*(INTIMAGE+1)+3*(CONLIST(1)-1)+2))/(INTIMAGE+1)
            XYZ((J1-1)*3*NATOMS+3*(NEWATOM-1)+3)=XYZ((J1-1)*3*NATOMS+3*(CONLIST(1)-1)+3)  &
 &            +(INTIMAGE-J1+2)*FRAC*(XYZ(3*(NEWATOM-1)+3)-XYZ(3*(CONLIST(1)-1)+3))/(INTIMAGE+1) &
 &   +(J1-1)*(XYZ(3*NATOMS*(INTIMAGE+1)+3*(NEWATOM-1)+3)-XYZ(3*NATOMS*(INTIMAGE+1)+3*(CONLIST(1)-1)+3))/(INTIMAGE+1)
         ENDDO
         CALL CHECKREP(INTIMAGE,XYZ,NOPT) ! SET UP REPULSIVE NEIGHBOUR LIST
         IF (CHECKCONINT) THEN
            CALL CONGRAD2(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
         ELSE
            CALL CONGRAD(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
         ENDIF
         IF (DEBUG) PRINT '(A,4G15.5)',' INTLBFGS> ENERGIES FOR CONSTRAINED, PRESERVED, CLOSEST, AND LINEAR SCHEMES=', &
  &                 ESAVE0,ESAVED,ESAVEC,ETOTAL
         IF ((ETOTAL.LT.ESAVEC).AND.(ETOTAL.LT.ESAVED).AND.(ETOTAL.LT.ESAVE0)) THEN
            IF (DEBUG) PRINT '(A,2G20.10)',' INTLBFGS> LOWEST ENERGY FROM LINEAR INTERPOLATION'
         ELSE IF ((ESAVEC.LT.ESAVED).AND.(ESAVEC.LT.ESAVE0)) THEN
            IF (DEBUG) PRINT '(A,2G20.10)',' INTLBFGS> LOWEST ENERGY FROM INTERPOLATION USING CLOSEST ATOMS'
            DO J1=2,INTIMAGE+1
               XYZ((J1-1)*3*NATOMS+3*(NEWATOM-1)+1:(J1-1)*3*NATOMS+3*(NEWATOM-1)+3)=XSAVEC(1:3,J1)
            ENDDO
            ETOTAL=ESAVEC
         ELSE IF (ESAVED.LT.ESAVE0) THEN
            IF (DEBUG) PRINT '(A,2G20.10)',' INTLBFGS> LOWEST ENERGY FROM INTERPOLATION USING PRESERVED DISTANCES'
            DO J1=2,INTIMAGE+1
               XYZ((J1-1)*3*NATOMS+3*(NEWATOM-1)+1:(J1-1)*3*NATOMS+3*(NEWATOM-1)+3)=XSAVED(1:3,J1)
            ENDDO
            ETOTAL=ESAVED
         ELSE 
            IF (DEBUG) PRINT '(A,2G20.10)',' INTLBFGS> LOWEST ENERGY FROM INTERPOLATION USING CLOSEST CONSTRAINTS'
            DO J1=2,INTIMAGE+1
               XYZ((J1-1)*3*NATOMS+3*(NEWATOM-1)+1:(J1-1)*3*NATOMS+3*(NEWATOM-1)+3)=XSAVE0(1:3,J1)
            ENDDO
            ETOTAL=ESAVE0
         ENDIF
      ENDIF
      NADDED=NADDED+1
      IF (NADDED.LT.NTOADD) GOTO 542
      CALL CHECKREP(INTIMAGE,XYZ,NOPT) ! SET UP REPULSIVE NEIGHBOUR LIST
!
! NEED A NEW GRADIENT SINCE THE ACTIVE ATOM HAS CHANGED !
!
      IF (CHECKCONINT) THEN
         CALL CONGRAD2(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
      ELSE
         CALL CONGRAD(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
      ENDIF
      NLASTGOODE=NITERDONE
      LASTGOODE=ETOTAL
      GOODSAVE(1:D)=X(1:D)
   ENDIF 

   MAIN: IF (NITERDONE==1) THEN
        POINT = 0
        DIAG(1:D)=INTDGUESS
        SEARCHSTEP(0,1:D)= -G(1:D)*DIAG                           ! NR STEP FOR DIAGONAL INVERSE HESSIAN
        GTMP(1:D)        = SEARCHSTEP(0,1:D)
        GNORM            = MAX(SQRT(DOT_PRODUCT(G(1:D),G(1:D))),1.0D-100)
        STP(1:D)         = MIN(1.0D0/GNORM, GNORM)           ! MAKE THE FIRST GUESS FOR THE STEP LENGTH CAUTIOUS
   ELSE MAIN
        BOUND=NITERDONE-1
        IF (NITERDONE.GT.INTMUPDATE) BOUND=INTMUPDATE
        YS=DOT_PRODUCT( GDIF(NPT/D,:), SEARCHSTEP(NPT/D,:)  )
        IF (YS==0.0D0) YS=1.0D0
    
        ! UPDATE ESTIMATE OF DIAGONAL INVERSE HESSIAN ELEMENTS.
        ! WE DIVIDE BY BOTH YS AND YY AT DIFFERENT POINTS, SO THEY HAD BETTER NOT BE ZERO!

        YY=DOT_PRODUCT( GDIF(NPT/D,:) , GDIF(NPT/D,:) )
        IF (YY==0.0D0) YY=1.0D0
!       DIAG = ABS(YS/YY)
        DIAG = YS/YY
      
        ! COMPUTE -H*G USING THE FORMULA GIVEN IN: NOCEDAL, J. 1980, "UPDATING QUASI-NEWTON MATRICES WITH LIMITED STORAGE",
        ! MATHEMATICS OF COMPUTATION, VOL.35, NO.151, PP. 773-782
        CP= POINT; IF (POINT==0) CP = INTMUPDATE
        RHO1(CP)=1.0D0/YS
        GTMP(1:D) = -G(1:D)
        CP= POINT 
                   
        DO I= 1,BOUND 
!            CP = CP - 1; IF (CP == -1) CP = M - 1
             CP = CP - 1; IF (CP == -1) CP = INTMUPDATE - 1
             SQ= DOT_PRODUCT( SEARCHSTEP(CP,1:D),GTMP(1:D) )
             ALPHA(CP+1) = RHO1(CP+1) * SQ
             GTMP(1:D)        = -ALPHA(CP+1)*GDIF(CP,1:D) + GTMP(1:D)
        ENDDO
              
        GTMP(1:D)=DIAG*GTMP(1:D)

        DO I=1,BOUND
             YR= DOT_PRODUCT( GDIF(CP,1:D) , GTMP )
             BETA= RHO1(CP+1)*YR
             BETA= ALPHA(CP+1)-BETA
             GTMP(1:D) = BETA*SEARCHSTEP(CP,1:D) + GTMP(1:D)
             CP=CP+1
!            IF (CP==M) CP=0
             IF (CP==INTMUPDATE) CP=0
        ENDDO
              
        STP(1:D) = 1.0D0
   ENDIF MAIN

   !  STORE THE NEW SEARCH DIRECTION
   IF (NITERDONE.GT.1) SEARCHSTEP(POINT,1:D)=GTMP(1:D)
      
!
! IF THE NUMBER OF IMAGES HAS CHANGED SINCE G WAS DECLARED THEN G IS NOT THE SAME
! SIZE AS GTMP AND DOT_PRODUCT CANNOT BE USED.
!
!  IF (DOT_PRODUCT(G,GTMP)/SQRT( DOT_PRODUCT(G,G)*DOT_PRODUCT(GTMP,GTMP) ) > 0.0D0) THEN
!
!  SEPARATE SQRT;S TO AVOID OVERFLOW.
!
   IF (DDOT(D,G,1,GTMP,1)/MAX(1.0D-100,SQRT( DDOT(D,G,1,G,1))*SQRT(DDOT(D,GTMP,1,GTMP,1)) ) > 0.0D0) THEN
        IF (DEBUG) PRINT*,'SEARCH DIRECTION HAS POSITIVE PROJECTION ONTO GRADIENT - REVERSING STEP'
        GTMP(1:D)=-GTMP(1:D)
        SEARCHSTEP(POINT,1:D)=GTMP(1:D)
   ENDIF
   GTMP(1:D)=G(1:D)

!  WE SHOULD APPLY THE MAXIMUM LBFGS STEP TO EACH IMAGE SEPARATELY.
!  HOWEVER, USING DIFFERENT SCALE FACTORS FOR DIFFERENT IMAGES LEADS TO HUGE
!  DISCONTINUITIES! NOW TAKE THE MINIMUM SCALE FACTOR FOR ALL IMAGES. DJW 26/11/07

   STPMIN=1.0D0
   DO J2=1,INTIMAGE
      STEPIMAGE(J2) = SQRT(DOT_PRODUCT(SEARCHSTEP(POINT,NOPT*(J2-1)+1:NOPT*J2),SEARCHSTEP(POINT,NOPT*(J2-1)+1:NOPT*J2)))
      DUMMY=STEPIMAGE(J2)
      IF (STEPIMAGE(J2) > MAXINTBFGS) THEN
           STP(NOPT*(J2-1)+1:NOPT*J2) = MAXINTBFGS/STEPIMAGE(J2)
           STPMIN=MIN(STPMIN,STP(NOPT*(J2-1)+1))
      ENDIF
!     PRINT '(A,I8,3G20.10)',' IMAGE,INITIAL STEP SIZE,STP,PROD=',J2,DUMMY,STP(NOPT*(J2-1)+1),STEPIMAGE(J2)*STP(NOPT*(J2-1)+1)
   ENDDO
   STP(1:D)=STPMIN

! EFK: DECIDE WHETHER TO FREEZE SOME NODES
   IF (FREEZENODEST) THEN
      TOTGNORM=SQRT(DOT_PRODUCT(G(1:NOPT*INTIMAGE),G(1:NOPT*INTIMAGE))/INTIMAGE)
      NIMAGEFREEZE=0
      DO IM=1,INTIMAGE
         TESTG=SQRT(DOT_PRODUCT(G(NOPT*(IM-1)+1:NOPT*IM),G(NOPT*(IM-1)+1:NOPT*IM)))
         IMGFREEZE(IM)=.FALSE.
         IF (TOTGNORM.NE.0.0D0) THEN
            IF (TESTG/TOTGNORM.LT.FREEZETOL) THEN
!              IF (DEBUG) PRINT '(A,I6,2G20.10)', ' INTLBFGS> FREEZING IMAGE: ', IM, TESTG, TOTGNORM
               IMGFREEZE(IM)=.TRUE.
               STEPIMAGE(IM)=0.0D0
               NIMAGEFREEZE=NIMAGEFREEZE+1
               STP(NOPT*(IM-1)+1:NOPT*IM)=0.0D0
            ENDIF
         ENDIF
      ENDDO
      IF (DEBUG) PRINT '(2(A,I6))', ' INTLBFGS> NUMBER OF FROZEN IMAGES=',NIMAGEFREEZE,' / ',INTIMAGE
   ENDIF
   !  WE NOW HAVE THE PROPOSED STEP - UPDATE GEOMETRY AND CALCULATE NEW GRADIENT
   NDECREASE=0
20 X(1:D) = X(1:D) + STP(1:D)*SEARCHSTEP(POINT,1:D)

   IF (.NOT.SWITCHED) THEN
!     IF ((RMS.LT.INTRMSTOL*1.0D10).AND.(MOD(NITERDONE,10).EQ.0).AND.(NSTEPSMAX-NITERDONE.GT.100)) &
! &               CALL CHECKSEP(NMAXINT,NMININT,INTIMAGE,XYZ,NOPT,NATOMS)
      IF (MOD(NITERDONE,50).EQ.0) THEN
         DMAX=0.0D0
         DMIN=HUGE(1.0D0)
         DO J1=1,INTIMAGE+1
            DUMMY=0.0D0
            DO J2=1,3*NATOMS
               IF (ATOMACTIVE((J2-1)/3+1)) THEN
                  DUMMY=DUMMY+( XYZ((J1-1)*3*NATOMS+J2) - XYZ(J1*3*NATOMS+J2) )**2
               ENDIF
            ENDDO
            DUMMY=SQRT(DUMMY)
            IF (DUMMY.GT.DMAX) THEN
               DMAX=DUMMY
               JMAX=J1
            ENDIF
            IF (DUMMY.LT.DMIN) THEN
               DMIN=DUMMY
               JMIN=J1
            ENDIF
            IF (DEBUG) PRINT '(A,I6,A,I6,A,G20.10)',' INTLBFGS> DISTANCE BETWEEN IMAGES ', &
  &                                                  J1,' AND ',J1+1,' IS ',DUMMY
         ENDDO
         IF ((DMAX.GT.IMSEPMAX).AND.(INTIMAGE.LT.MAXINTIMAGE)) THEN
            PRINT '(A,I6,A,I6)',' INTLBFGS> ADD AN IMAGE BETWEEN ',JMAX,' AND ',JMAX+1
            ALLOCATE(DPTMP(3*NATOMS*(INTIMAGE+2)))
            DPTMP(1:3*NATOMS*(INTIMAGE+2))=XYZ(1:3*NATOMS*(INTIMAGE+2))
            DEALLOCATE(XYZ)
            ALLOCATE(XYZ(3*NATOMS*(INTIMAGE+3)))
            XYZ(1:3*NATOMS*JMAX)=DPTMP(1:3*NATOMS*JMAX)
            XYZ(3*NATOMS*JMAX+1:3*NATOMS*(JMAX+1))=(DPTMP(3*NATOMS*(JMAX-1)+1:3*NATOMS*JMAX) &
  &                                               + DPTMP(3*NATOMS*JMAX+1:3*NATOMS*(JMAX+1)))/2.0D0
            XYZ(3*NATOMS*(JMAX+1)+1:3*NATOMS*(INTIMAGE+3))=DPTMP(3*NATOMS*JMAX+1:3*NATOMS*(INTIMAGE+2))
!
! SAVE STEP-TAKING MEMORIES IN SEARCHSTEP AND GDIF.
! THESE ARRAYS RUN FROM 0 TO INTMUPDATE OVER MEMORIES AND
! 1:NOPT*INTIMAGE OVER ONLY THE VARIABLE IMAGES.
!
            DEALLOCATE(DPTMP)
            ALLOCATE(D2TMP(0:INTMUPDATE,1:NOPT*INTIMAGE))
            D2TMP(0:INTMUPDATE,1:NOPT*INTIMAGE)=SEARCHSTEP(0:INTMUPDATE,1:NOPT*INTIMAGE)
            DEALLOCATE(SEARCHSTEP)
            ALLOCATE(SEARCHSTEP(0:INTMUPDATE,1:NOPT*(INTIMAGE+1)))
            DO J1=1,INTMUPDATE
               IF (JMAX.GT.1) SEARCHSTEP(J1,1:3*NATOMS*(JMAX-1))=D2TMP(J1,1:3*NATOMS*(JMAX-1))
               IF (JMAX.LT.INTIMAGE+1) SEARCHSTEP(J1,3*NATOMS*JMAX+1:3*NATOMS*(INTIMAGE+1))= &
  &                 D2TMP(J1,3*NATOMS*(JMAX-1)+1:3*NATOMS*INTIMAGE)
               SEARCHSTEP(J1,3*NATOMS*(JMAX-1)+1:3*NATOMS*JMAX)= &
  &                             D2TMP(J1,3*NATOMS*(MIN(JMAX,INTIMAGE)-1)+1:3*NATOMS*MIN(JMAX,INTIMAGE))
            ENDDO
            D2TMP(0:INTMUPDATE,1:NOPT*INTIMAGE)=GDIF(0:INTMUPDATE,1:NOPT*INTIMAGE)
            DEALLOCATE(GDIF)
            ALLOCATE(GDIF(0:INTMUPDATE,1:NOPT*(INTIMAGE+1)))
            DO J1=1,INTMUPDATE
               IF (JMAX.GT.1) GDIF(J1,1:3*NATOMS*(JMAX-1))=D2TMP(J1,1:3*NATOMS*(JMAX-1))
               IF (JMAX.LT.INTIMAGE+1) GDIF(J1,3*NATOMS*JMAX+1:3*NATOMS*(INTIMAGE+1))= &
  &                 D2TMP(J1,3*NATOMS*(JMAX-1)+1:3*NATOMS*INTIMAGE)
               GDIF(J1,3*NATOMS*(JMAX-1)+1:3*NATOMS*JMAX)= &
  &                       D2TMP(J1,3*NATOMS*(MIN(JMAX,INTIMAGE)-1)+1:3*NATOMS*MIN(JMAX,INTIMAGE))
            ENDDO
            DEALLOCATE(D2TMP)

            DEALLOCATE(SAVEX,TRUEEE,GOODSAVE,EEETMP,MYGTMP,XSAVED,XSAVEC,XSAVE0,GTMP,GGG, &
  &                    DIAG,STP,GLAST,XSAVE,EEE,STEPIMAGE,CHECKG,IMGFREEZE)
            ALLOCATE(SAVEX(3*NATOMS*(INTIMAGE+1)),TRUEEE(INTIMAGE+3),GOODSAVE(3*NATOMS*(INTIMAGE+3)), &
  &                  EEETMP(INTIMAGE+3), MYGTMP(3*NATOMS*(INTIMAGE+1)), XSAVED(3,INTIMAGE+3), &
  &                  XSAVEC(3,INTIMAGE+3), XSAVE0(3,INTIMAGE+3), GTMP(3*NATOMS*(INTIMAGE+1)), &
  &                  DIAG(3*NATOMS*(INTIMAGE+1)), STP(3*NATOMS*(INTIMAGE+1)), &
  &                  GLAST(NOPT*(INTIMAGE+1)), &
  &                  XSAVE(NOPT*(INTIMAGE+1)), CHECKG(NOPT*(INTIMAGE+1)), IMGFREEZE(INTIMAGE+1), &
  &                  EEE(INTIMAGE+3), STEPIMAGE(INTIMAGE+1), GGG(3*NATOMS*(INTIMAGE+3)))
            GGG(1:3*NATOMS*(INTIMAGE+3))=0.0D0
            SAVEX(1:3*NATOMS*(INTIMAGE+1))=0.0D0
            TRUEEE(1:INTIMAGE+3)=0.0D0
            EEETMP(1:INTIMAGE+3)=0.0D0
            MYGTMP(1:3*NATOMS*(INTIMAGE+1))=0.0D0
            XSAVED(1:3,1:INTIMAGE+3)=0.0D0
            XSAVEC(1:3,1:INTIMAGE+3)=0.0D0
            XSAVE0(1:3,1:INTIMAGE+3)=0.0D0
            GTMP(1:3*NATOMS*(INTIMAGE+1))=0.0D0
            DIAG(1:3*NATOMS*(INTIMAGE+1))=0.0D0
            STP(1:3*NATOMS*(INTIMAGE+1))=0.0D0
            GLAST(1:NOPT*(INTIMAGE+1))=0.0D0
            XSAVE(1:NOPT*(INTIMAGE+1))=0.0D0
            CHECKG(1:NOPT*(INTIMAGE+1))=.FALSE.
            IMGFREEZE(1:INTIMAGE+1)=.FALSE.
            EEE(1:INTIMAGE+3)=0.0D0
            STEPIMAGE(1:INTIMAGE+1)=0.0D0

            X=>XYZ(NOPT+1:NOPT*(INTIMAGE+2))
            G=>GGG(NOPT+1:NOPT*(INTIMAGE+2))
            INTIMAGE=INTIMAGE+1
            D=NOPT*INTIMAGE
            CALL CHECKREP(INTIMAGE,XYZ,NOPT)
            IF (CHECKCONINT) THEN
               CALL CONGRAD2(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
            ELSE
               CALL CONGRAD(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
            ENDIF
         ELSEIF ((DMIN.LT.IMSEPMIN).AND.(INTIMAGE.GT.1)) THEN
            IF (JMIN.EQ.1) JMIN=2
            PRINT '(A,I6,A,I6)',' INTLBFGS> REMOVE IMAGE ',JMIN
            ALLOCATE(DPTMP(3*NATOMS*(INTIMAGE+2)))
            DPTMP(1:3*NATOMS*(INTIMAGE+2))=XYZ(1:3*NATOMS*(INTIMAGE+2))
            DEALLOCATE(XYZ)
            ALLOCATE(XYZ(3*NATOMS*(INTIMAGE+1)))
            XYZ(1:3*NATOMS*(JMIN-1))=DPTMP(1:3*NATOMS*(JMIN-1))
            XYZ(3*NATOMS*(JMIN-1)+1:3*NATOMS*(INTIMAGE+1))=DPTMP(3*NATOMS*JMIN+1:3*NATOMS*(INTIMAGE+2))

            DEALLOCATE(DPTMP)
!
! SAVE STEP-TAKING MEMORIES IN SEARCHSTEP AND GDIF.
! THESE ARRAYS RUN FROM 0 TO INTMUPDATE OVER MEMORIES AND
! 1:NOPT*INTIMAGE OVER ONLY THE VARIABLE IMAGES.
!
            ALLOCATE(D2TMP(0:INTMUPDATE,1:NOPT*INTIMAGE))
            D2TMP(0:INTMUPDATE,1:NOPT*INTIMAGE)=SEARCHSTEP(0:INTMUPDATE,1:NOPT*INTIMAGE)
            DEALLOCATE(SEARCHSTEP)
            ALLOCATE(SEARCHSTEP(0:INTMUPDATE,1:NOPT*(INTIMAGE-1)))
            DO J1=1,INTMUPDATE
               SEARCHSTEP(J1,1:3*NATOMS*(JMIN-2))=D2TMP(J1,1:3*NATOMS*(JMIN-2))
               SEARCHSTEP(J1,3*NATOMS*(JMIN-2)+1:3*NATOMS*(INTIMAGE-1))= &
  &                     D2TMP(J1,3*NATOMS*(JMIN-1)+1:3*NATOMS*INTIMAGE)
            ENDDO
            D2TMP(0:INTMUPDATE,1:NOPT*INTIMAGE)=GDIF(0:INTMUPDATE,1:NOPT*INTIMAGE)
            DEALLOCATE(GDIF)
            ALLOCATE(GDIF(0:INTMUPDATE,1:NOPT*(INTIMAGE-1)))
            DO J1=1,INTMUPDATE
               GDIF(J1,1:3*NATOMS*(JMIN-2))=D2TMP(J1,1:3*NATOMS*(JMIN-2))
               GDIF(J1,3*NATOMS*(JMIN-2)+1:3*NATOMS*(INTIMAGE-1))= &
  &                     D2TMP(J1,3*NATOMS*(JMIN-1)+1:3*NATOMS*INTIMAGE)
            ENDDO
            DEALLOCATE(D2TMP)

            DEALLOCATE(SAVEX,TRUEEE,GOODSAVE,EEETMP,MYGTMP,XSAVED,XSAVEC,XSAVE0,GTMP,GGG, &
  &                    DIAG,STP,GLAST,XSAVE,EEE,STEPIMAGE,CHECKG,IMGFREEZE)
            ALLOCATE(SAVEX(3*NATOMS*(INTIMAGE-1)),TRUEEE(INTIMAGE+1),GOODSAVE(3*NATOMS*(INTIMAGE+1)), &
  &                  EEETMP(INTIMAGE+1), MYGTMP(3*NATOMS*(INTIMAGE-1)), XSAVED(3,INTIMAGE+1), &
  &                  XSAVEC(3,INTIMAGE+1), XSAVE0(3,INTIMAGE+1), GTMP(3*NATOMS*(INTIMAGE-1)), &
  &                  DIAG(3*NATOMS*(INTIMAGE-1)), STP(3*NATOMS*(INTIMAGE-1)), &
  &                  GLAST(NOPT*(INTIMAGE-1)), &
  &                  XSAVE(NOPT*(INTIMAGE-1)), CHECKG(NOPT*(INTIMAGE-1)), IMGFREEZE(INTIMAGE-1), &
  &                  EEE(INTIMAGE+1), STEPIMAGE(INTIMAGE-1), GGG(3*NATOMS*(INTIMAGE+1)))
            GGG(1:3*NATOMS*(INTIMAGE+1))=0.0D0
            SAVEX(1:3*NATOMS*(INTIMAGE-1))=0.0D0
            TRUEEE(1:INTIMAGE+1)=0.0D0
            EEETMP(1:INTIMAGE+1)=0.0D0
            MYGTMP(1:3*NATOMS*(INTIMAGE-1))=0.0D0
            XSAVED(1:3,1:INTIMAGE+1)=0.0D0
            XSAVEC(1:3,1:INTIMAGE+1)=0.0D0
            XSAVE0(1:3,1:INTIMAGE+1)=0.0D0
            GTMP(1:3*NATOMS*(INTIMAGE-1))=0.0D0
            DIAG(1:3*NATOMS*(INTIMAGE-1))=0.0D0
            STP(1:3*NATOMS*(INTIMAGE-1))=0.0D0
            GLAST(1:NOPT*(INTIMAGE-1))=0.0D0
            XSAVE(1:NOPT*(INTIMAGE-1))=0.0D0
            CHECKG(1:NOPT*(INTIMAGE-1))=.FALSE.
            IMGFREEZE(1:INTIMAGE-1)=.FALSE.
            EEE(1:INTIMAGE+1)=0.0D0
            STEPIMAGE(1:INTIMAGE-1)=0.0D0

            X=>XYZ(NOPT+1:NOPT*(INTIMAGE))
            G=>GGG(NOPT+1:NOPT*(INTIMAGE))
            INTIMAGE=INTIMAGE-1
            D=NOPT*INTIMAGE
            CALL CHECKREP(INTIMAGE,XYZ,NOPT)
            IF (CHECKCONINT) THEN
               CALL CONGRAD2(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
            ELSE
               CALL CONGRAD(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
            ENDIF
         ENDIF
      ELSE
         IF (MOD(NITERDONE,25).EQ.0) CALL CHECKREP(INTIMAGE,XYZ,NOPT)
         IF (CHECKCONINT) THEN
            CALL CONGRAD2(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
         ELSE
            CALL CONGRAD(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
         ENDIF
      ENDIF
      IF ((ETOTAL-EOLD.LT.1.0D100).OR.ADDATOM) THEN ! MAXERISE EFFECTIVELY SET TO 1.0D100 HERE
!     IF ((ETOTAL-EOLD.LT.2.0D-1).OR.ADDATOM) THEN 
         EOLD=ETOTAL
         GLAST(1:D)=G(1:D)
         XSAVE(1:D)=X(1:D)
      ELSE
         NDECREASE=NDECREASE+1
         IF (NDECREASE.GT.5) THEN
            NFAIL=NFAIL+1
            WRITE(*,'(A,I6)') ' INTLBFGS> WARNING *** IN LBFGS CANNOT FIND A LOWER ENERGY, NFAIL=',NFAIL
            X(1:D)=XSAVE(1:D)
            G(1:D)=GLAST(1:D)
         ELSE
            X(1:D)=XSAVE(1:D)
            G(1:D)=GLAST(1:D)
            STP(1:D)=STP(1:D)/10.0D0
            WRITE(*,'(A,G25.15,A,G25.15,A)') ' INTLBFGS> ENERGY INCREASED FROM ',EOLD,' TO ',ETOTAL, &
     &          ' DECREASING STEP SIZE'
            GOTO 20
         ENDIF
      ENDIF
      ADDATOM=.FALSE.
   ELSE ! COMBINE CONSTRAINT AND TRUE POTENTIALS
!     IF ((RMS.LT.INTRMSTOL*1.0D10).AND.(MOD(NITERDONE,10).EQ.0).AND.(NSTEPSMAX-NITERDONE.GT.100)) &
! &               CALL CHECKSEP(NMAXINT,NMININT,INTIMAGE,XYZ,NOPT)

!!!
!
! CHECK THAT MAKE_CONPOT PRODUCES THE SAME CONSTRAINTS AND REPULSIONS - THIS IS TO DEBUG MAKE_CONPOT
!
!     MINCOORDS(1,1:NOPT)=XYZ(1:NOPT)
!     MINCOORDS(2,1:NOPT)=XYZ(NOPT*(INTIMAGE+1)+1:NOPT*(INTIMAGE+2))
!     PRINT '(A)',' INTLBFGS> BEFORE MAKE_CONPOT'
!     CALL CHECKREP(INTIMAGE,XYZ,NOPT)
!     DO J2=1,NCONSTRAINT
!        PRINT '(A,I6,L5,2I6,2F20.10)','J2,CONACTIVE,CONI,CONJ,CONDISTREF,CONDISTREFLOCAL=', &
! &                      J2,CONACTIVE(J2),CONI(J2),CONJ(J2),CONDISTREF(J2),CONDISTREFLOCAL(J2)
!     ENDDO
!     DO J2=1,NREPULSIVE
!        PRINT '(A,3I6,F20.10)','J2,REPI,REPJ,REPCUT=',J2,REPI(J2),REPJ(J2),REPCUT(J2)
!     ENDDO
!     DO J2=1,NNREPULSIVE
!        PRINT '(A,3I6,F20.10)','J2,NREPI,NREPJ,NREPCUT=',J2,NREPI(J2),NREPJ(J2),NREPCUT(J2)
!     ENDDO
!     PRINT '(A)',' INTLBFGS> CALLING MAKE_CONPOT'
!     CALL MAKE_CONPOT(2,MINCOORDS)
!     CALL CHECKREP(INTIMAGE,XYZ,NOPT)
!     DO J2=1,NCONSTRAINT
!        PRINT '(A,I6,L5,2I6,2F20.10)','J2,CONACTIVE,CONI,CONJ,CONDISTREF,CONDISTREFLOCAL=', &
! &                      J2,CONACTIVE(J2),CONI(J2),CONJ(J2),CONDISTREF(J2),CONDISTREFLOCAL(J2)
!     ENDDO
!     DO J2=1,NREPULSIVE
!        PRINT '(A,3I6,F20.10)','J2,REPI,REPJ,REPCUT=',J2,REPI(J2),REPJ(J2),REPCUT(J2)
!     ENDDO
!     DO J2=1,NNREPULSIVE
!        PRINT '(A,3I6,F20.10)','J2,NREPI,NREPJ,NREPCUT=',J2,NREPI(J2),NREPJ(J2),NREPCUT(J2)
!     ENDDO
!     STOP
!!! DJW
      IF (MOD(NITERDONE,25).EQ.0) CALL CHECKREP(INTIMAGE,XYZ,NOPT)
      ETOTALTMP=0.0D0
      DO J4=2,INTIMAGE+1
         CALL POTENTIAL(XYZ(NOPT*(J4-1)+1:NOPT*J4),EEE(J4),GGG(NOPT*(J4-1)+1:NOPT*J4),.TRUE.,.FALSE.,RMS,.FALSE.,.FALSE.)
         ETOTALTMP=ETOTALTMP+EEE(J4)
      ENDDO
      RMSTMP=RMS
      EEETMP(1:INTIMAGE+2)=EEE(1:INTIMAGE+2)
      MYGTMP(1:D)=G(1:D)
      IF (CHECKCONINT) THEN
         CALL CONGRAD2(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
      ELSE
         CALL CONGRAD(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
      ENDIF
      ETOTAL=USEFRAC*ETOTALTMP+(1.0D0-USEFRAC)*ETOTAL
      RMS=USEFRAC*RMSTMP+(1.0D0-USEFRAC)*RMS
      G(1:D)=USEFRAC*MYGTMP(1:D)+(1.0D0-USEFRAC)*G(1:D)
      EEE(1:INTIMAGE+2)=USEFRAC*EEETMP(1:INTIMAGE+2)+(1.0D0-USEFRAC)*EEE(1:INTIMAGE+2)
!     USEFRAC=USEFRAC+INTCONFRAC
      IF (USEFRAC.GE.1.0D0) PRINT '(A,I6)',' INTLBFGS> SWITCHING OFF CONSTRAINT POTENTIAL COMPLETELY AT STEP ',NITERDONE
   ENDIF
   IF (ETOTAL/INTIMAGE.LT.COLDFUSIONLIMIT) THEN
      WRITE(*,'(A,2G20.10)') ' INTLBFGS> COLD FUSION DIAGNOSED - STEP DISCARDED, ENERGY, LIMIT=',ETOTAL/INTIMAGE,COLDFUSIONLIMIT
      DEALLOCATE(CONI,CONJ,CONDISTREF,REPI,REPJ,NREPI,NREPJ,REPCUT,NREPCUT)
      DEALLOCATE(SAVEX,TRUEEE,GOODSAVE, EEETMP, MYGTMP, XSAVED, XSAVEC, XSAVE0, GTMP, &
  &              DIAG, STP, SEARCHSTEP, GDIF,GLAST, XSAVE, XYZ, GGG, CHECKG, IMGFREEZE, EEE, STEPIMAGE)
      INTIMAGE=INTIMAGESAVE
      NTSFOUND=0
      NMINFOUND=0
      RETURN
   ENDIF

   STEPTOT = SUM(STEPIMAGE)/INTIMAGE

   IF (DEBUG) THEN
      WRITE(*,'(A,I6,2G20.10,G20.10,I8)') ' INTLBFGS> STEPS: ',NITERDONE,ETOTAL/INTIMAGE,RMS,STEPTOT,NACTIVE
      CALL FLUSH(6,ISTAT)
   ENDIF

   IF (.NOT.SWITCHED) THEN
      IF ((NITERDONE-NLASTGOODE.GT.INTRELSTEPS).AND.((ETOTAL.GT.LASTGOODE).OR.(ETOTAL/INTIMAGE.GT.MAXCONE*1.0D8))) THEN
         PRINT '(2(A,I6))',' INTLBFGS> BACKTRACKING ',NBACKTRACK,' STEPS, ACTIVE ATOMS=',NACTIVE-NBACKTRACK
         NTRIES(NEWATOM)=NTRIES(NEWATOM)+1
         IF (FREEZENODEST) IMGFREEZE(1:INTIMAGE)=.FALSE.
!
! BACKTRACK BY REMOVING THE LAST NBACKTRACK ATOMS ALONG WITH THEIR ACTIVE CONSTRAINTS AND
! REPULSIONS.
!
         DO J1=1,NBACKTRACK
            NDUMMY=TURNONORDER(NACTIVE-J1+1)
            IF (DEBUG) PRINT '(A,I6,A,2I6)',' INTLBFGS> TURNING OFF ACTIVE ATOM ',NDUMMY
            DO J2=1,NCONSTRAINT
               IF (.NOT.CONACTIVE(J2)) CYCLE
               IF ((CONI(J2).EQ.NDUMMY).OR.(CONJ(J2).EQ.NDUMMY)) THEN
                  CONACTIVE(J2)=.FALSE.
                  IF (DEBUG) PRINT '(A,I6,A,2I6)',' INTLBFGS> TURNING OFF CONSTRAINT ',J2,' FOR ATOMS ',CONI(J2),CONJ(J2)
               ENDIF
            ENDDO
            ATOMACTIVE(NDUMMY)=.FALSE.
         ENDDO
!
! RECONSTRUCT REPULSIONS. 
!
         NREPULSIVE=0
         DO J1=1,NATOMS
            IF (.NOT.ATOMACTIVE(J1)) CYCLE ! IDENTIFY ACTIVE ATOMS
            DO J2=J1+1,NATOMS
               IF (.NOT.ATOMACTIVE(J2)) CYCLE ! IDENTIFY ACTIVE ATOMS
               IF (ABS(J1-J2).LE.INTREPSEP) CYCLE ! NO REPULSION FOR ATOMS TOO CLOSE IN SEQUENCE
               DO J3=1,NCONSTRAINT
                  IF (.NOT.CONACTIVE(J3)) CYCLE ! IDENTIFY ACTIVE CONSTRAINTS 
                  IF (((CONI(J3).EQ.J1).AND.(CONJ(J3).EQ.J2)).OR. &
  &                   ((CONJ(J3).EQ.J1).AND.(CONI(J3).EQ.J2))) GOTO 548
               ENDDO
               DMIN=1.0D100
               DO J3=1,INTIMAGE+2,INTIMAGE+1 ! ONLY CONSIDER THE END-POINT DISTANCES
                  DF=SQRT((XYZ((J3-1)*3*NATOMS+3*(J2-1)+1)-XYZ((J3-1)*3*NATOMS+3*(J1-1)+1))**2+ &
  &                       (XYZ((J3-1)*3*NATOMS+3*(J2-1)+2)-XYZ((J3-1)*3*NATOMS+3*(J1-1)+2))**2+ &
  &                       (XYZ((J3-1)*3*NATOMS+3*(J2-1)+3)-XYZ((J3-1)*3*NATOMS+3*(J1-1)+3))**2)
                  IF (DF.LT.DMIN) DMIN=DF
               ENDDO
!
! USE THE MINIMUM OF THE END POINT DISTANCES AND INTCONSTRAINREPCUT FOR EACH CONTACT.
!
               DMIN=MIN(DMIN-1.0D-3,INTCONSTRAINREPCUT)
               NREPULSIVE=NREPULSIVE+1
               REPI(NREPULSIVE)=J1
               REPJ(NREPULSIVE)=J2
               REPCUT(NREPULSIVE)=DMIN
548            CONTINUE
            ENDDO
         ENDDO

         NACTIVE=NACTIVE-NBACKTRACK
         NBACKTRACK=MIN(MIN(1.0D0*(NBACKTRACK+1),1.0D0*20),0.1D0*(NACTIVE-2))
         IF (DEBUG) PRINT '(A,I6)',' INTLBFGS> NUMBER OF ATOMS TO BACKTRACK IS NOW ',NBACKTRACK
         NDUMMY=0
         DO J1=1,NATOMS
            IF (ATOMACTIVE(J1)) NDUMMY=NDUMMY+1
         ENDDO
         IF (NDUMMY.NE.NACTIVE) THEN
            PRINT '(A,I6)',' INTLBFGS> ERROR *** INCONSISTENCY IN NUMBER OF ACTIVE ATOMS. SHOULD BE ',NACTIVE
            DO J1=1,NATOMS
               IF (ATOMACTIVE(J1)) PRINT '(A,I6)',' ACTIVE ATOM ',J1
            ENDDO
            STOP
         ENDIF
         ADDATOM=.TRUE.

         CALL CHECKREP(INTIMAGE,XYZ,NOPT)
         IF (CHECKCONINT) THEN
            CALL CONGRAD2(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
         ELSE
            CALL CONGRAD(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
         ENDIF
      ENDIF
      LASTGOODE=ETOTAL
   ENDIF

   EXITSTATUS=0
   IF (INTIMAGE.EQ.0) THEN ! SANITY CHECK - SHOULD BE UNNECESSARY
      PRINT '(A,2I10)','INTLBFGS> ERROR *** INTIMAGE,SIZE(DIAG,1)=',INTIMAGE,SIZE(DIAG,1)
      STOP
   ENDIF
   INTDGUESS=DIAG(1) ! SHOULD BE OK FOR SUBSEQUENT RUNS OF THE SAME SYSTEM DJW
   IF (RMS<=INTRMSTOL.AND.NITERDONE>1) EXITSTATUS=1
   IF (NITERDONE==NSTEPSMAX) EXITSTATUS=2

   IF (.FALSE.) THEN
      CHECKG(1:D)=.FALSE.
      DO J1=1,D
         IF (ABS(G(J1)).GT.1.0D-6) THEN
            PRINT '(3I6,G20.10)',J1,2+(J1-1)/(3*NATOMS),(J1-3*NATOMS*((J1-1)/(3*NATOMS))-1)/3+1,G(J1)
            CHECKG(J1)=.TRUE.
         ENDIF
     ENDDO
!!!!!!!!!!!!!!!!!!!
!     NDUMMY=NREPULSIVE
!     NCONSTRAINT=0
!     NREPULSIVE=0
!!!!!!!!!!!!!!!!!!!
      IF (CHECKCONINT) THEN
         CALL CONGRAD2(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
      ELSE
         CALL CONGRAD(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
      ENDIF
      GLAST(1:D)=G(1:D)
      DIFF=1.0D-6
      PRINT '(A,I6)',' INTLBFGS> ANALYTIC AND NUMERICAL GRADIENTS: D=',D
      DO J2=1,D
         IF (.NOT.CHECKG(J2)) CYCLE
         X(J2)=X(J2)+DIFF
!        PRINT '(A,I6)',' INTLBFGS> CALLING CONGRAD + FOR COORDINATE J2'
         IF (CHECKCONINT) THEN
            CALL CONGRAD2(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
         ELSE
            CALL CONGRAD(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
         ENDIF
         EPLUS=ETOTAL
         X(J2)=X(J2)-2.0D0*DIFF
!        PRINT '(A,I6)',' INTLBFGS> CALLING CONGRAD - FOR COORDINATE J2'
         IF (CHECKCONINT) THEN
            CALL CONGRAD2(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
         ELSE
            CALL CONGRAD(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
         ENDIF
         EMINUS=ETOTAL
         X(J2)=X(J2)+DIFF
         IF (ABS(GLAST(J2)).NE.0.0D0) THEN
            IF (100.0D0*ABS((GLAST(J2)-(EPLUS-EMINUS)/(2.0D0*DIFF))/GLAST(J2)).GT.10.0D0) THEN
               WRITE(*,'(A,3I8,3G20.10)') 'ERROR ',(J2-1)/NOPT+1,(J2-NOPT*((J2-1)/NOPT)-1)/3+1,J2, &
  &                                 GLAST(J2),(EPLUS-EMINUS)/(2.0D0*DIFF), &
  &                                 (EPLUS-EMINUS)/(2.0D0*DIFF*GLAST(J2))
            ELSE
               WRITE(*,'(A,3I8,3G20.10)') 'OK    ',(J2-1)/NOPT+1,(J2-NOPT*((J2-1)/NOPT)-1)/3+1,J2, &
  &                                       GLAST(J2),(EPLUS-EMINUS)/(2.0D0*DIFF), &
  &                                       (EPLUS-EMINUS)/(2.0D0*DIFF*GLAST(J2))
            ENDIF
         ENDIF
      ENDDO
   ENDIF

   IF (EXITSTATUS > 0) THEN  
      IF ((.NOT.SWITCHED).AND.(EXITSTATUS.EQ.1)) THEN ! ADD ACTIVE ATOM OR RESTART WITH TRUE POTENTIAL ON
         IF (ETOTAL/INTIMAGE.GT.MAXCONE) GOTO 777
         IF (NACTIVE.LT.NATOMS) THEN 
            ADDATOM=.TRUE.
            GOTO 777
         ENDIF
         CALL MYCPU_TIME(FTIME,.FALSE.)
         PRINT '(A,I6,A,F12.6,A,I6,A,F10.1)',' INTLBFGS> SWITCH ON TRUE POTENTIAL AT STEP ',NITERDONE, &
  &                                     ' FRACTION=',INTCONFRAC,' IMAGES=',INTIMAGE,' TIME=',FTIME-STIME
         PRINT '(A,I6,A,F15.6)',' INTLBFGS> ALLOWING ',INTCONSTEPS,' FURTHER OPTIMIZATION STEPS'
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   IF (.FALSE.) THEN
      CHECKG(1:D)=.FALSE.
      DO J1=1,D
         IF (ABS(G(J1)).GT.1.0D-6) THEN
            PRINT '(3I6,G20.10)',J1,2+(J1-1)/(3*NATOMS),(J1-3*NATOMS*((J1-1)/(3*NATOMS))-1)/3+1,G(J1)
            CHECKG(J1)=.TRUE.
         ENDIF
     ENDDO
      IF (CHECKCONINT) THEN
         CALL CONGRAD2(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
      ELSE
         CALL CONGRAD(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
      ENDIF
      GLAST(1:D)=G(1:D)
      DIFF=1.0D-6
      PRINT '(A,I6)',' INTLBFGS> ANALYTIC AND NUMERICAL GRADIENTS: D=',D
      DO J2=1,D
         IF (.NOT.CHECKG(J2)) CYCLE
         X(J2)=X(J2)+DIFF
!        PRINT '(A,I6)',' INTLBFGS> CALLING CONGRAD + FOR COORDINATE J2'
         IF (CHECKCONINT) THEN
            CALL CONGRAD2(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
         ELSE
            CALL CONGRAD(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
         ENDIF
         EPLUS=ETOTAL
         X(J2)=X(J2)-2.0D0*DIFF
!        PRINT '(A,I6)',' INTLBFGS> CALLING CONGRAD - FOR COORDINATE J2'
         IF (CHECKCONINT) THEN
            CALL CONGRAD2(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
         ELSE
            CALL CONGRAD(NMAXINT,NMININT,ETOTAL,XYZ,GGG,EEE,IMGFREEZE,RMS)
         ENDIF
         EMINUS=ETOTAL
         X(J2)=X(J2)+DIFF
         IF (ABS(GLAST(J2)).NE.0.0D0) THEN
            IF (100.0D0*ABS((GLAST(J2)-(EPLUS-EMINUS)/(2.0D0*DIFF))/GLAST(J2)).GT.10.0D0) THEN
               WRITE(*,'(A,3I8,3G20.10)') 'ERROR ',(J2-1)/NOPT+1,(J2-NOPT*((J2-1)/NOPT)-1)/3+1,J2, &
  &                                 GLAST(J2),(EPLUS-EMINUS)/(2.0D0*DIFF), &
  &                                 (EPLUS-EMINUS)/(2.0D0*DIFF*GLAST(J2))
            ELSE
               WRITE(*,'(A,3I8,3G20.10)') 'OK    ',(J2-1)/NOPT+1,(J2-NOPT*((J2-1)/NOPT)-1)/3+1,J2, &
  &                                       GLAST(J2),(EPLUS-EMINUS)/(2.0D0*DIFF), &
  &                                       (EPLUS-EMINUS)/(2.0D0*DIFF*GLAST(J2))
            ENDIF
         ENDIF
      ENDDO
   ENDIF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         DO J1=1,NATOMS
            IF (.NOT.ATOMACTIVE(J1)) THEN
               PRINT '(A,I6,A,I6,A)',' INTLBFGS> ERROR *** NUMBER OF ACTIVE ATOMS=',NACTIVE,' BUT ATOM ',J1,' IS NOT ACTIVE'
            ENDIF
         ENDDO
         NSTEPSMAX=NITERDONE+INTCONSTEPS
         SWITCHED=.TRUE.
         USEFRAC=INTCONFRAC
         GOTO 777
      ELSEIF ((.NOT.SWITCHED).AND.(EXITSTATUS.EQ.2)) THEN 
         PRINT '(A,I6)',' INTLBFGS> ERROR *** NUMBER OF ACTIVE ATOMS AT FINAL STEP=',NACTIVE
         STOP
      ELSEIF (DEBUG) THEN
         PRINT '(A,I6,A,I6)','INTLBFGS> ENERGIES FOR IMAGES:'
         PRINT '(I6,F20.10)',(J2,EEE(J2),J2=1,INTIMAGE+2)
      ENDIF
      EXIT
   ENDIF
   777 CONTINUE
!
! COMPUTE THE NEW STEP AND GRADIENT CHANGE
!
   NPT=POINT*D
   SEARCHSTEP(POINT,:) = STP*SEARCHSTEP(POINT,:)
   GDIF(POINT,:)=G-GTMP
   POINT=POINT+1; IF (POINT==INTMUPDATE) POINT=0

   IF (DUMPINTXYZ.AND.MOD(NITERDONE,DUMPINTXYZFREQ)==0) CALL RWG(NITERDONE,INTIMAGE,XYZ)
   IF (DUMPINTEOS.AND.MOD(NITERDONE,DUMPINTEOSFREQ)==0) CALL WRITEPROFILE(NITERDONE,EEE,INTIMAGE)
   PREVGRAD=RMS

   NITERDONE=NITERDONE+1
   IF (NITERDONE.GT.NSTEPSMAX) EXIT

ENDDO ! END OF MAIN DO LOOP OVER COUNTER NITERDONE

IF (.NOT.SWITCHED) THEN 
   PRINT '(A,I6)',' INTLBFGS> ERROR *** NUMBER OF ACTIVE ATOMS AT FINAL STEP=',NACTIVE,' NO POTENTIAL SWITCH'
   STOP
ENDIF
IF (EXITSTATUS.EQ.1) THEN
   WRITE(*,'(A,I6,A,G20.10,A,G20.10)') ' INTLBFGS> CONVERGED AFTER ',NITERDONE,' STEPS, ENERGY PER IMAGE=',ETOTAL/INTIMAGE, &
  &                               ' RMS GRADIENT=',RMS
ELSEIF (EXITSTATUS.EQ.2) THEN
   WRITE(*,'(A,I6,A,G20.10,A,G20.10)') ' INTLBFGS> AFTER ',NITERDONE,' STEPS, ENERGY PER IMAGE=',ETOTAL/INTIMAGE, &
  &                               ' RMS GRADIENT=',RMS
ENDIF
!
! LINEAR INTERPOLATION FOR CONSTRAINT POTENTIAL AND REAL POTENTIAL SEPARATELY.
! CONSTRAINT POTENTIAL NEED NOT BE FLAT IF WE HAVE DONE SOME STEPS WITH BOTH
! POTENTIALS TURNED ON.
!
DINCREMENT=0.02D0
DTOTAL=0.0D0
OPEN(UNIT=753,FILE='INTENERGY',STATUS='UNKNOWN')
!
! LOCAL MAXIMA MUST HAVE NSIDE HIGHER ENERGIES ON EACH SIDE
! THIS HAS THE DESIRABLE SIDE-EFFECT THAT WE DON'T BOTHER WITH
! IMAGES THAT ARE ESSENTIALLY COLLAPSED ON EACH OTHER - THEIR
! SPACING WILL PROBABLY BE < DINCREMENT, OR 5*DINCREMENT.
!
NSIDE=5
INTTST=.TRUE. ! TRY PASSING LOCAL MAXIMA BACK AS TS GUESSES
! INTTST=.FALSE. 
NTSFOUND=0
NMINFOUND=0
PRINTOPTIMIZETS=DEBUG
DO J1=1,INTIMAGE+1
   DUMMY=0.0D0
   DO J2=1,3*NATOMS
      DUMMY=DUMMY+( XYZ((J1-1)*3*NATOMS+J2) - XYZ(J1*3*NATOMS+J2) )**2
   ENDDO
   DUMMY=SQRT(DUMMY)
   DIST=0.0D0
   PRINT '(A,I6,A,I6,A,G20.10)',' INTLBFGS> DISTANCE BETWEEN IMAGES ',J1,' AND ',J1+1,' IS ',DUMMY
   NDUMMY=DUMMY/DINCREMENT+1
   ALLOCATE(EINT(NDUMMY))
   J3=1

   INTLOOP: DO
      LOCALCOORDS(1:3*NATOMS)=((DUMMY-DIST)*XYZ((J1-1)*3*NATOMS+1:J1*3*NATOMS)+ &
  &                                    DIST*XYZ(J1*3*NATOMS+1:(J1+1)*3*NATOMS))/DUMMY
      CALL POTENTIAL(LOCALCOORDS,EREAL,VNEW,.FALSE.,.FALSE.,RMS,.FALSE.,.FALSE.)
      IF (DEBUG) PRINT '(A,3G20.10)',' INTLBFGS> ',DTOTAL+DIST,EREAL
      WRITE(753,'(3G20.10)') DTOTAL+DIST,EREAL
      DIST=DIST+DINCREMENT
      EINT(J3)=EREAL
      IF (INTTST) THEN
         IF (J3-NSIDE.GT.0) THEN
            DO J4=MAX(J3-2*NSIDE,1),J3
               IF (J4.EQ.J3-NSIDE) CYCLE
               IF (EINT(J3-NSIDE).LT.EINT(J4)) GOTO 432
            ENDDO
!
! WE HAVE A TS CANDIDATE. TRY OPTIMISING IT!
!
            CALL MYCPU_TIME(STARTTIME,.FALSE.)
            KNOWG=.FALSE.
            KNOWE=.FALSE. ! TO BE SAFE!
            LOCALCOORDS(1:NOPT)= &
  &                 ((DUMMY-(J3-NSIDE-1)*DINCREMENT)*XYZ((J1-1)*NOPT+1:J1*NOPT)+ &
  &                         (J3-NSIDE-1)*DINCREMENT *XYZ(J1*NOPT+1:(J1+1)*NOPT))/DUMMY
            IF (BFGSTST) THEN
               VECS(1:NOPT)=(XYZ((J1-1)*NOPT+1:J1*NOPT)-XYZ(J1*NOPT+1:(J1+1)*NOPT))/DUMMY
               CALL BFGSTS(NSTEPS,LOCALCOORDS,  &
  &               EDUMMY,LGDUMMY,TSCONVERGED,RMS,EVALMIN,EVALMAX,VECS,ITDONE,.TRUE.,PRINTOPTIMIZETS)
            ELSE
               CALL EFOL(LOCALCOORDS,TSCONVERGED,NSTEPS,EDUMMY,ITDONE,EVALMIN,DEBUG,XDIAG,2)
            ENDIF
            CALL MYCPU_TIME(TIME0,.FALSE.)
            IF (TSCONVERGED) THEN
               NTSFOUND=NTSFOUND+1
!
! SAVE COORDINATES AND DIRECTION VECTOR BETWEEN IMAGES TO USE AS STARTING GUESS
! FOR THE EIGENVECTOR.
!
               ALLOCATE(TSFOUND(NTSFOUND)%E,TSFOUND(NTSFOUND)%COORD(NOPT), &
  &                     TSFOUND(NTSFOUND)%EVALMIN,TSFOUND(NTSFOUND)%VECS(NOPT))
               TSFOUND(NTSFOUND)%VECS(1:NOPT)=VECS(1:NOPT)
               TSFOUND(NTSFOUND)%COORD(1:NOPT)=LOCALCOORDS(1:NOPT)
               TSFOUND(NTSFOUND)%E=EDUMMY
               TSFOUND(NTSFOUND)%EVALMIN=EVALMIN
               PRINT '(A,I6,A,G20.10,A,F10.1)',' INTLBFGS> TRANSITION STATE FOUND, ITERATIONS=',ITDONE, &
  &                                  ' ENERGY=',EDUMMY,' TIME=',TIME0-STARTTIME
            ENDIF
432         CONTINUE
         ENDIF
      ENDIF
      J3=J3+1
      IF (DIST.GT.DUMMY) EXIT INTLOOP
      IF (J3.GT.NDUMMY) THEN
         PRINT '(A,I6)',' INTLBFGS> ERROR *** NUMBER OF INTERPOLATED ENERGIES SHOULD NOT BE ',J3
      ENDIF
   ENDDO INTLOOP
   DTOTAL=DTOTAL+DUMMY
   DEALLOCATE(EINT)
ENDDO

LOCALCOORDS(1:3*NATOMS)=XYZ((INTIMAGE+1)*3*NATOMS+1:(INTIMAGE+2)*3*NATOMS)
CALL POTENTIAL(LOCALCOORDS,EREAL,VNEW,.FALSE.,.FALSE.,RMS,.FALSE.,.FALSE.)
PRINT '(A,3G20.10)',' INTLBFGS> ',DTOTAL,EREAL
WRITE(753,'(3G20.10)') DTOTAL,EREAL
CLOSE(753)

IF (.NOT.INTTST) THEN
   PTEST=.FALSE.
   INTTST=.FALSE.
   PRINT '(A,I8)',' INTLBFGS> MINIMISING ALL THE IMAGES - RESULTS WRITTEN TO IMAGES.MIN'
   OPEN(987,FILE='IMAGES.MIN',STATUS='UNKNOWN')
   WRITE(987,'(I6)') NATOMS
   WRITE(987,'(A)') 'START - IMAGE 1'
   WRITE(987,'(A,3G20.10)') (ZSYM(J2),XYZ(3*(J2-1)+1:3*(J2-1)+3),J2=1,NATOMS)
   DO J1=2,INTIMAGE+1
      KNOWG=.FALSE.
      KNOWE=.FALSE. ! COULD USE EEE VALUE
      PRINT '(A,I8,A,F20.10)',' INTLBFGS> MINIMISING IMAGE ',J1,' INITIAL ENERGY=',EEE(J1)

!     BSMIN=.TRUE.
!     DEBUG=.TRUE.
!     CALL ODESD(100,XYZ(NOPT*(J1-1)+1:NOPT*J1),MFLAG,ITDONE,.TRUE.)
!     DEBUG=.FALSE.
!     BSMIN=.FALSE.

!     KNOWG=.FALSE.
!     KNOWE=.FALSE. 
!     PTEST=.TRUE.
      CALL MYLBFGS(NOPT,MUPDATE,XYZ(NOPT*(J1-1)+1:NOPT*J1),.FALSE., &
   &               MFLAG,ENERGY,RMS2,EREAL,RMS,BFGSSTEPS,.TRUE.,ITDONE,PTEST,VNEW,.TRUE.,.FALSE.)
!     PTEST=.FALSE.
   
      IF (MFLAG) THEN
         NMINFOUND=NMINFOUND+1
!
!  WE HAVE TO COMMUNICATE THE MINIMA FOUND BACK TO TRYCONNECT USING THE DATA STRUCTURE
!  SET UP FOR NEW TRANSITION STATES.
!  ADDED NEW VARIABLE MINFOUND TO ALLOW FOR THIS CHECK IN TRYCONNECT.
!  IT SEEMS IMPOSSIBLE TO MAKE INTLBFGS SEE ISNEWMIN AND ADDNEWMIN FOR SOME REASON.
!
         ALLOCATE(MINFOUND(NMINFOUND)%E,MINFOUND(NMINFOUND)%COORD(NOPT))
         MINFOUND(NMINFOUND)%COORD(1:NOPT)=XYZ(NOPT*(J1-1)+1:NOPT*J1)
         MINFOUND(NMINFOUND)%E=EREAL
         WRITE(987,'(I6)') NATOMS
         WRITE(987,'(A,I5)') 'IMAGE ',J1
         WRITE(987,'(A,3G20.10)') (ZSYM(J2), MINFOUND(NMINFOUND)%COORD(3*(J2-1)+1:3*(J2-1)+3),J2=1,NATOMS)
      ENDIF
   ENDDO
   WRITE(987,'(I6)') NATOMS
   WRITE(987,'(A)') 'FINISH - IMAGE INTIMAGE+2'
   WRITE(987,'(A,3G20.10)') (ZSYM(J2),XYZ(NOPT*(INTIMAGE+1)+3*(J2-1)+1:NOPT*(INTIMAGE+1)+3*(J2-1)+3),J2=1,NATOMS)
   CLOSE(987)
ENDIF
 
DEALLOCATE(CONI,CONJ,CONDISTREF,REPI,REPJ,NREPI,NREPJ,REPCUT,NREPCUT)
DEALLOCATE(SAVEX,TRUEEE,GOODSAVE, EEETMP, MYGTMP, XSAVED, XSAVEC, XSAVE0, GTMP, &
  &      DIAG, STP, SEARCHSTEP, GDIF,GLAST, XSAVE, XYZ, GGG, CHECKG, IMGFREEZE, EEE, STEPIMAGE)
INTIMAGE=INTIMAGESAVE

END SUBROUTINE INTLBFGS
!
! POSSIBLE REDISTRIBUTION OF IMAGES FOR INTCONSTRAINT DEPENDING UPON DISTANCES.
!
SUBROUTINE CHECKSEP(NMAXINT,NMININT,INTIMAGE,XYZ,NOPT,NATOMS)
IMPLICIT NONE
INTEGER NSEPMAX, NSEPMIN, J, NMININT, NMAXINT, INTIMAGE, NOPT, J1, J2, NATOMS
DOUBLE PRECISION SEPMAX, SEPMIN, XYZ(*), DUMMY

RETURN !!! DJW

IF ((NMININT.EQ.NMAXINT).OR.(NMININT.EQ.NMAXINT+1)) THEN
   PRINT '(A,2I6)',' CHECKSEP> SKIPPING IMAGE REDISTRIBUTION FOR IMAGES ',NMININT,NMAXINT
   RETURN
ENDIF
IF ((NMININT.EQ.1).OR.(NMININT.EQ.INTIMAGE+2)) THEN
   PRINT '(A,I6)',' CHECKSEP> ERROR *** NMININT=',NMININT
ENDIF
IF ((NMAXINT.EQ.1).OR.(NMAXINT.EQ.INTIMAGE+2)) THEN
   PRINT '(A,I6)',' CHECKSEP> ERROR *** NMAXINT=',NMAXINT
ENDIF
! 
! DVEC(J) CONTAINS THE DISTANCE BETWEEN IMAGE J AND IMAGE J+1
!
!      SEPMAX=-1.0D0
!      SEPMIN=1.0D100
!      DO J=1,INTIMAGE+1
!         IF (DVEC(J).GT.SEPMAX) THEN
!            SEPMAX=DVEC(J)
!            NSEPMAX=J
!         ENDIF
!      ENDDO
!      DO J=2,INTIMAGE+1
!         IF (DVEC(J-1)+DVEC(J).LT.SEPMIN) THEN
!            SEPMIN=DVEC(J-1)+DVEC(J)
!            NSEPMIN=J
!         ENDIF
!      ENDDO
!      PRINT '(A,F20.10,A,I6,A,I6)',' CHECKSEP> MAXIMUM IMAGE SEPARATION=',SEPMAX,' FOR IMAGES ',NSEPMAX,' AND ',NSEPMAX+1
!      PRINT '(A,F20.10,A,I6)',' CHECKSEP> MINIMUM SUM OF IMAGE SEPARATIONS=',SEPMIN,' FOR IMAGE ',NSEPMIN

!    IF (SEPMIN*2.0D0.LT.SEPMAX) THEN ! REDISTRIBUTE IMAGES

IF (.TRUE.) THEN ! REDISTRIBUTE IMAGES
   PRINT '(A,I6,A,2I6)',' CHECKSEP> REMOVING IMAGE ',NMININT,' AND ADDING ONE BETWEEN IMAGES ',NMAXINT,NMAXINT+1
!  IF (NSEPMIN.LT.NSEPMAX) THEN
   IF (NMININT.LT.NMAXINT) THEN
!     DO J=NSEPMIN,NSEPMAX-1 ! MOVE IMAGE J+1 TO POSITION J FOR IMAGES J=NSEPMIN+1 TO NSEPMAX-1
      DO J=NMININT,NMAXINT-1 ! MOVE IMAGE J+1 TO POSITION J FOR IMAGES J=NMININT+1 TO NMAXINT-1
         XYZ(NOPT*(J-1)+1:NOPT*J)=XYZ(NOPT*J+1:NOPT*(J+1))
      ENDDO
!     XYZ(NOPT*(NSEPMAX-1)+1:NOPT*NSEPMAX)=(XYZ(NOPT*(NSEPMAX-1)+1:NOPT*NSEPMAX)+XYZ(NOPT*NSEPMAX+1:NOPT*(NSEPMAX+1)))/2.0D0
      XYZ(NOPT*(NMAXINT-1)+1:NOPT*NMAXINT)=(XYZ(NOPT*(NMAXINT-1)+1:NOPT*NMAXINT)+XYZ(NOPT*NMAXINT+1:NOPT*(NMAXINT+1)))/2.0D0
   ELSE
!     DO J=NSEPMIN,NSEPMAX+2,-1 ! MOVE IMAGE J-1 TO POSITION J FOR IMAGES J=NSEPMIN-1 TO NSEPMAX+1
      DO J=NMININT,NMAXINT+2,-1 ! MOVE IMAGE J-1 TO POSITION J FOR IMAGES J=NMININT-1 TO NMAXINT+1
         PRINT '(2(A,I6))',' PUTTING IMAGE ',J-1,' IN IMAGE ',J
         XYZ(NOPT*(J-1)+1:NOPT*J)=XYZ(NOPT*(J-2)+1:NOPT*(J-1))
      ENDDO
      XYZ(NOPT*NMAXINT+1:NOPT*(NMAXINT+1))=(XYZ(NOPT*NMAXINT+1:NOPT*(NMAXINT+1))+XYZ(NOPT*(NMAXINT-1)+1:NOPT*NMAXINT))/2.0D0
   ENDIF
ENDIF

END SUBROUTINE CHECKSEP
!
! NEIGHBOUR LIST FOR REPULSIONS TO REDUCE COST OF CONSTRAINT POTENTIAL.
!
SUBROUTINE CHECKREP(INTIMAGE,XYZ,NOPT)
USE KEY,ONLY : NREPI, NREPJ, NREPCUT, NNREPULSIVE, NREPULSIVE, REPI, REPJ, REPCUT, DEBUG
USE PORFUNCS
IMPLICIT NONE
INTEGER JJ, KK, NI1, NJ1, NI2, NJ2, INTIMAGE, NOPT, ISTAT
DOUBLE PRECISION LDIST, XYZ(NOPT*(INTIMAGE+2))
DOUBLE PRECISION R1AX,R1AY,R1AZ,R2AX,R2AY,R2AZ,R1BX,R1BY,R1BZ,R2BX,R2BY,R2BZ,DMIN
LOGICAL NOINT
 
NNREPULSIVE=0
DO JJ=1,NREPULSIVE
 CALL FLUSH(6,ISTAT)
   DO KK=1,INTIMAGE+2 ! FIRST CHECK FOR STANDARD DISTANCES WITHIN THRESHOLD
      LDIST=SQRT((XYZ((KK-1)*NOPT+3*(REPI(JJ)-1)+1)-XYZ((KK-1)*NOPT+3*(REPJ(JJ)-1)+1))**2 &
  &             +(XYZ((KK-1)*NOPT+3*(REPI(JJ)-1)+2)-XYZ((KK-1)*NOPT+3*(REPJ(JJ)-1)+2))**2 &
  &             +(XYZ((KK-1)*NOPT+3*(REPI(JJ)-1)+3)-XYZ((KK-1)*NOPT+3*(REPJ(JJ)-1)+3))**2)
      IF (LDIST.LT.1.5D0*REPCUT(JJ)) THEN
         NNREPULSIVE=NNREPULSIVE+1
         NREPI(NNREPULSIVE)=REPI(JJ)
         NREPJ(NNREPULSIVE)=REPJ(JJ)
         NREPCUT(NNREPULSIVE)=REPCUT(JJ)
         GOTO 246
      ENDIF
   ENDDO 
 CALL FLUSH(6,ISTAT)
   DO KK=2,INTIMAGE+2 ! NOW CHECK INTERNAL MINIMA WITHIN THRESHOLD
      DMIN=1.0D10
      NI2=NOPT*(KK-2)+3*(REPI(JJ)-1)
      NI1=NOPT*(KK-1)+3*(REPI(JJ)-1)
      NJ2=NOPT*(KK-2)+3*(REPJ(JJ)-1)
      NJ1=NOPT*(KK-1)+3*(REPJ(JJ)-1)
      R1AX=XYZ(NI2+1); R1AY=XYZ(NI2+2); R1AZ=XYZ(NI2+3)
      R1BX=XYZ(NJ2+1); R1BY=XYZ(NJ2+2); R1BZ=XYZ(NJ2+3)
      R2AX=XYZ(NI1+1); R2AY=XYZ(NI1+2); R2AZ=XYZ(NI1+3)
      R2BX=XYZ(NJ1+1); R2BY=XYZ(NJ1+2); R2BZ=XYZ(NJ1+3)
      CALL INTMINONLY(R1AX,R1AY,R1AZ,R2AX,R2AY,R2AZ,R1BX,R1BY,R1BZ,R2BX,R2BY,R2BZ,DMIN,NOINT)

!     IF ((REPI(JJ).EQ.143).AND.(REPJ(JJ).EQ.191)) THEN
!        PRINT '(A,3G20.10)',' CHECKREP> R1AX,R1AY,R1AZ=',R1AX,R1AY,R1AZ
!        PRINT '(A,3G20.10)',' CHECKREP> R1BX,R1BY,R1BZ=',R1BX,R1BY,R1BZ
!        PRINT '(A,3G20.10)',' CHECKREP> R2AX,R2AY,R2AZ=',R2AX,R2AY,R2AZ
!        PRINT '(A,3G20.10)',' CHECKREP> R2BX,R2BY,R2BZ=',R2BX,R2BY,R2BZ
!        PRINT '(A,3I6,2G20.10)','JJ,REPI(JJ),REPJ(JJ),LDIST,DMIN=',JJ,REPI(JJ),REPJ(JJ),LDIST,DMIN
!     ENDIF
      IF (NOINT) CYCLE
      IF (DMIN.LT.1.5D0*REPCUT(JJ)) THEN
         NNREPULSIVE=NNREPULSIVE+1
         NREPI(NNREPULSIVE)=REPI(JJ)
         NREPJ(NNREPULSIVE)=REPJ(JJ)
         NREPCUT(NNREPULSIVE)=REPCUT(JJ)
         GOTO 246
      ENDIF
   ENDDO 
 CALL FLUSH(6,ISTAT)
246 CONTINUE
ENDDO
IF (DEBUG) PRINT '(A,2I8)',' CHECKREP> NUMBER OF ACTIVE REPULSIONS AND TOTAL=',NNREPULSIVE,NREPULSIVE

END SUBROUTINE CHECKREP

SUBROUTINE RWG(NITER,INTIMAGE,XYZ)
USE PORFUNCS
USE KEY,ONLY: FILTH,FILTHSTR,STOCKT,AMHT,SEQ,NUMGLY,STOCKAAT, RBAAT
USE COMMONS, ONLY: ZSYM, NRBSITES 
USE AMHGLOBALS, ONLY : NMRES
USE COMMONS, ONLY: NATOMS, NOPT
IMPLICIT NONE
CHARACTER(LEN=10) :: XYZFILE   = 'INT.XYZ   '
CHARACTER(LEN=12) :: RBXYZFILE = 'RBINT.XYZ   '
INTEGER,INTENT(IN) :: NITER
INTEGER :: J1,J2,GLY_COUNT,INTIMAGE
CHARACTER(LEN=80) :: FILENAME,FILENAME2,DUMMYS,DUMMYS2
DOUBLE PRECISION XYZ(NOPT*(INTIMAGE+2))

IF (FILTH.EQ.0) THEN
   FILENAME=XYZFILE
   IF (RBAAT) FILENAME2=RBXYZFILE
ELSE
   FILENAME=TRIM(XYZFILE)//'.'//TRIM(ADJUSTL(FILTHSTR))
   IF (RBAAT) FILENAME2=TRIM(RBXYZFILE)//'.'//TRIM(ADJUSTL(FILTHSTR))
ENDIF 

IF (NITER.GT.0) THEN
   IF (FILTH.EQ.0) THEN
      WRITE(DUMMYS,'(I8)') NITER
      DUMMYS2=TRIM(ADJUSTL(FILENAME))
      FILENAME='INT.' // TRIM(ADJUSTL(DUMMYS)) // '.XYZ' ! SO THAT VMD RECOGNISES THE FILE TYPE!
      FILENAME2='RBINT.' // TRIM(ADJUSTL(DUMMYS)) // '.XYZ'
   ELSE 
      WRITE(DUMMYS,'(I8)') NITER
      DUMMYS2=TRIM(ADJUSTL(FILENAME))
      FILENAME='INT.' // TRIM(ADJUSTL(DUMMYS)) // '.' // TRIM(ADJUSTL(FILTHSTR)) // '.XYZ' 
      FILENAME2='RBINT.' // TRIM(ADJUSTL(DUMMYS)) // '.' // TRIM(ADJUSTL(FILTHSTR)) // '.XYZ'
   ENDIF
ENDIF
OPEN(UNIT=993,FILE=FILENAME,STATUS='REPLACE')
IF (STOCKT .OR. STOCKAAT) THEN
   DO J2=1,INTIMAGE+2 
      WRITE(993,'(I4/)') (NATOMS/2)
      DO J1=1,(NATOMS/2) 
         WRITE(993,'(A5,1X,6F20.10)') ZSYM((J1+2)/3), &
  & XYZ((J2-1)*NOPT+3*(J1-1)+1), XYZ((J2-1)*NOPT+3*(J1-1)+2), XYZ((J2-1)*NOPT+3*(J1-1)+3), &
  &    XYZ((J2-1)*NOPT+3*((NATOMS/2)+J1-1)+1), XYZ((J2-1)*NOPT+3*((NATOMS/2)+J1-1)+2), XYZ((J2-1)*NOPT+3*((NATOMS/2)+J1-1)+3)
      ENDDO
   ENDDO
ELSEIF (RBAAT .AND. (.NOT. STOCKAAT)) THEN
   PRINT '(A)',' INTLBFGS> ERROR *** RGW ROUTINE NEEDS TO BE TAUGHT STXYZ FOR THIS POTENTIAL'
   STOP
!  OPEN(UNIT=114,FILE=FILENAME2,STATUS='UNKNOWN')
!  DO J2=1,INTIMAGE+2
!     WRITE(993,'(I4/)') NATOMS/2
!     DO J1=1,(NATOMS/2) 
!        WRITE(993,'(A5,1X,3F20.10)') 'O', &
! & XYZ((J2-1)*NOPT+3*(J1-1)+1), XYZ((J2-1)*NOPT+3*(J1-1)+2), XYZ((J2-1)*NOPT+3*(J1-1)+3)
!     ENDDO
!     CALL SITEPOS(XYZ((J2-1)*NOPT+1:J2*NOPT),STXYZ)
!     WRITE(114,'(I4/)') (NATOMS/2)*NRBSITES
!     DO J1=1,(NATOMS/2)*NRBSITES
!        J3 = 3*J1
!        WRITE(114,'(A5,1X,3F20.10)') 'O', STXYZ(J3-2), STXYZ(J3-1), STXYZ(J3)
!     ENDDO
!  ENDDO
!  CLOSE(UNIT=114)
ELSEIF (AMHT) THEN
   DO J2=1,INTIMAGE+2
!  GLY SET GETPARAMS.F
!               WRITE(993,'(I4)')NATOMS +NUMGLY
!  GLY PRINTING TURNED OFF DJW
      WRITE(993,'(I4)')NATOMS
      WRITE(993,*)'ENERGY'
      GLY_COUNT = 0

      DO J1=1,NMRES
         IF (SEQ(J1).EQ.8) THEN
            WRITE(993,'(A5,1X,3F20.10)') 'C1   ',XYZ((J2-1)*NOPT+9*(J1-1)+1-GLY_COUNT*3),XYZ((J2-1)*NOPT+9*(J1-1)+2-GLY_COUNT*3), &
     &                                  XYZ((J2-1)*NOPT+9*(J1-1)+3-GLY_COUNT*3)
!  GLY PRINTING TURNED OFF DJW
!           WRITE(993,'(A5,1X,3F20.10)') 'C1   ',XYZ((J2-1)*NOPT+9*(J1-1)+1-GLY_COUNT*3),XYZ((J2-1)*NOPT+9*(J1-1)+2-GLY_COUNT*3), &
!    &                                  XYZ((J2-1)*NOPT+9*(J1-1)+3-GLY_COUNT*3)
            WRITE(993,'(A5,1X,3F20.10)') 'O    ',XYZ((J2-1)*NOPT+9*(J1-1)+4-GLY_COUNT*3),XYZ((J2-1)*NOPT+9*(J1-1)+5-GLY_COUNT*3), &
     &                                  XYZ((J2-1)*NOPT+9*(J1-1)+6-GLY_COUNT*3)
            GLY_COUNT = GLY_COUNT +1
         ELSE
            WRITE(993,'(A5,1X,3F20.10)') 'C1   ',XYZ((J2-1)*NOPT+9*(J1-1)+1-GLY_COUNT*3),XYZ((J2-1)*NOPT+9*(J1-1)+2-GLY_COUNT*3), &
     &                                  XYZ((J2-1)*NOPT+9*(J1-1)+3-GLY_COUNT*3)
            WRITE(993,'(A5,1X,3F20.10)') 'C2   ',XYZ((J2-1)*NOPT+9*(J1-1)+4-GLY_COUNT*3),XYZ((J2-1)*NOPT+9*(J1-1)+5-GLY_COUNT*3), &
     &                                  XYZ((J2-1)*NOPT+9*(J1-1)+6-GLY_COUNT*3)
            WRITE(993,'(A5,1X,3F20.10)') 'O    ',XYZ((J2-1)*NOPT+9*(J1-1)+7-GLY_COUNT*3),XYZ((J2-1)*NOPT+9*(J1-1)+8-GLY_COUNT*3), &
     &                                  XYZ((J2-1)*NOPT+9*(J1-1)+9-GLY_COUNT*3)
         ENDIF
      ENDDO
   ENDDO
ELSE
   DO J2=1,INTIMAGE+2
      WRITE(993,'(I4/)') NATOMS
      WRITE(993,'(A5,1X,3F20.10)') (ZSYM((J1+2)/3),XYZ( (J2-1)*NOPT+J1),&
    & XYZ((J2-1)*NOPT+J1+1), XYZ((J2-1)*NOPT+J1+2),J1=1,NOPT,3)
   ENDDO
ENDIF

PRINT *, 'RWG> INTERPOLATED IMAGE COORDINATES WERE SAVED TO XYZ FILE "'//TRIM(FILENAME)//'"'

CLOSE(UNIT=993)
END SUBROUTINE RWG

SUBROUTINE WRITEPROFILE(NITER,EEE,INTIMAGE)
USE KEY,ONLY: FILTH,FILTHSTR
IMPLICIT NONE 
INTEGER,INTENT(IN) :: NITER, INTIMAGE
INTEGER :: I,UNIT
DOUBLE PRECISION :: EEE(INTIMAGE+2)
CHARACTER(LEN=20) :: FILENAME

UNIT=992
IF (NITER.GT.0) THEN
   WRITE(FILENAME,'(I8)') NITER
   FILENAME='INT.EOFS.' // TRIM(ADJUSTL(FILENAME))
ELSE   
   FILENAME='INT.EOFS'
ENDIF
IF (.NOT.FILTH==0) THEN
   FILENAME=TRIM(FILENAME)//'.'//TRIM(ADJUSTL(FILTHSTR))
ENDIF
OPEN(UNIT=UNIT,FILE=FILENAME,STATUS='REPLACE')

WRITE(UNIT=UNIT,FMT='(2G24.13)') EEE(1)
DO I=2,INTIMAGE+1
   WRITE(UNIT=UNIT,FMT='(2G24.13)') EEE(I)
ENDDO
WRITE(UNIT=UNIT,FMT='(2G24.13)') EEE(INTIMAGE+2)

CLOSE(UNIT)
PRINT '(A)',' WRITEPROFILE> INTERPOLATED ENERGY PROFILE WAS SAVED TO FILE "'//TRIM(FILENAME)//'"'

END SUBROUTINE WRITEPROFILE
