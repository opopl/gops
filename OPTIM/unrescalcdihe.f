C   OPTIM: A PROGRAM FOR OPTIMIZING GEOMETRIES AND CALCULATING REACTION PATHWAYS
C   COPYRIGHT (C) 1999-2006 DAVID J. WALES
C   THIS FILE IS PART OF OPTIM.
C
C   OPTIM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C   IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C   THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C   (AT YOUR OPTION) ANY LATER VERSION.
C
C   OPTIM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
C   BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
C   GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C   YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C   ALONG WITH THIS PROGRAM; IF NOT, WRITE TO THE FREE SOFTWARE
C   FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330, BOSTON, MA  02111-1307  USA
C
C JMC MAY NEED TO USE DIFFERENCE BETWEEN POLAR ANGLES AS WELL IN THE ORDER PARAMETER FOR UNRES
C LIKE WITH TWISTTYPE10...
C
C ROUTINE TO CALCULATE DIFFERENCE BETWEEN DIFFERENT INTERNAL COORDINATE DIHEDRAL VALUES FOR QLOCAL AND FIN (CARTESIAN) COORDS
C
      SUBROUTINE UNRESCALCDIHE(DIHE,ALLANG,QLOCAL,FIN)
      USE COMMONS
C     USE KEY
      USE MODUNRES
      IMPLICIT NONE
C
      INTEGER I1,J1
      REAL*8 DIFFPP,DIHE, SUMD2,ALLDIFFPP, ALLANG, ALLSUMD2,FINPPSANGLE(4*NRES-9) ! DIM OF *PPSANGLE IS NPHI+NTHETA+2(NRES-2)
      REAL*8 QPPSANGLE(4*NRES-9),DIFFARRAY(4*NRES-9),QLOCAL(3*NATOMS),FIN(3*NATOMS)
      INTEGER IICD,TWISTMODE,TWISTTYPE,NM,NWRONG
      LOGICAL LINTCOOR,PTEST
      DOUBLE PRECISION PI
      PARAMETER (PI=3.141592653589793D0)

      DO I1=1,NRES
         C(1,I1)=FIN(6*(I1-1)+1)
         C(2,I1)=FIN(6*(I1-1)+2)
         C(3,I1)=FIN(6*(I1-1)+3)
         C(1,I1+NRES)=FIN(6*(I1-1)+4)
         C(2,I1+NRES)=FIN(6*(I1-1)+5)
         C(3,I1+NRES)=FIN(6*(I1-1)+6)
      END DO
      CALL UPDATEDC
      CALL INT_FROM_CART(.TRUE.,.FALSE.)

C USE UNRES GEOMETRY ARRAYS PHI (BB DIHEDRALS) AND OMEG (SC DIHEDRALS)
C TAKE CARE WITH NUMBERING - SEE /UNRES/SRC/READPDB.F (SUBROUTINE INT_FROM_CART)
C FOR SIDE CHAIN DIHEDRALS, HAVE ZERO ELEMENTS FOR PROPER (I.E. NOT CAPPING) GLYCINES.
C NEED TO REMEMBER NOT TO TRY TO TWIST THEM THOUGH!
C NO ENTRIES IN QPPSANGLE FOR CAPPING 'RESIDUES'.
      DO I1=1,NRES-3
        FINPPSANGLE(I1)=PHI(I1+3)
      END DO
      DO I1=1,NRES-2
        FINPPSANGLE(I1+NRES-3)=OMEG(I1+1)
C JMC 30/4/03 TRY ADDING BACKBONE AND SIDE CHAIN POLAR ANGLES
C THIS SHOULD BE MORE IMPORTANT FOR UNRES THAN FOR CHARMM...
C ORDER IS BB DIHEDRALS, SC DIHEDRALS, BB POLARS, SC POLARS.
        FINPPSANGLE(I1+2*NRES-5)=THETA(I1+2)
        FINPPSANGLE(I1+3*NRES-7)=ALPH(I1+1)
      END DO

      DO I1=1,NRES
         C(1,I1)=QLOCAL(6*(I1-1)+1)
         C(2,I1)=QLOCAL(6*(I1-1)+2)
         C(3,I1)=QLOCAL(6*(I1-1)+3)
         C(1,I1+NRES)=QLOCAL(6*(I1-1)+4)
         C(2,I1+NRES)=QLOCAL(6*(I1-1)+5)
         C(3,I1+NRES)=QLOCAL(6*(I1-1)+6)
      END DO
      CALL UPDATEDC
      CALL INT_FROM_CART(.TRUE.,.FALSE.)

      DO I1=1,NRES-3
        QPPSANGLE(I1)=PHI(I1+3)
      END DO
      DO I1=1,NRES-2
        QPPSANGLE(I1+NRES-3)=OMEG(I1+1)
C JMC 30/4/03 TRY ADDING BACKBONE AND SIDE CHAIN POLAR ANGLES
C THIS SHOULD BE MORE IMPORTANT FOR UNRES THAN FOR CHARMM...
C ORDER IS BB DIHEDRALS, SC DIHEDRALS, BB POLARS, SC POLARS.
        QPPSANGLE(I1+2*NRES-5)=THETA(I1+2)
        QPPSANGLE(I1+3*NRES-7)=ALPH(I1+1)
      END DO
C
      SUMD2=0.D0
      DO I1=1,NPHI+NRES-2
         DIFFPP = QPPSANGLE(I1) - FINPPSANGLE(I1)
C
C NEXT TWO LINES ARE MEANT TO ENSURE THAT YOU ALWAYS INTERPOLATE
C ALONG THE SHORTEST DISTANCE BETWEEN THE DIHEDRAL ANGLES.
C
C JMC         IF (DIFFPP.GT.180.0) DIFFPP = DIFFPP-360.D0
C JMC         IF (DIFFPP.GT.180.0) DIFFPP = DIFFPP-360.D0
         IF (DIFFPP.LT.-PI) DIFFPP = DIFFPP+2.0D0*PI
         IF (DIFFPP.GT.PI) DIFFPP = DIFFPP-2.0D0*PI
C        WRITE(*,'(A,I6,3F15.10)') 'FINS QS',I1,FINPPSANGLE(I1),QPPSANGLE(I1),DIFFPP
         SUMD2=SUMD2+DIFFPP*DIFFPP
      ENDDO

      ALLSUMD2=SUMD2
      DO I1=NPHI+NRES-1,NPHI+NTHETA+2*NRES-4
         DIFFPP = QPPSANGLE(I1) - FINPPSANGLE(I1)
C        WRITE(*,'(A,I6,3F15.10)') 'FINS QS',I1,FINPPSANGLE(I1),QPPSANGLE(I1),DIFFPP
         ALLSUMD2=ALLSUMD2+DIFFPP*DIFFPP
      ENDDO
 
C JMC TESTING
C     PRINT *,'DIHE,ALLANG ',SUMD2,ALLSUMD2
C JMC REMEMBER IF SUMD IS IN RADIANS, THEN DIHE WILL HAVE DIFFERENT
C RANGE OF VALUES FOR CHARMM VS UNRES...
      DIHE=DSQRT(SUMD2/(NPHI+NSIDE))
      ALLANG=DSQRT(ALLSUMD2/(NPHI+NTHETA+2.0D0*NSIDE))

      RETURN

      END

C JMC MAY NEED TO USE DIFFERENCE BETWEEN POLAR ANGLES AS WELL IN THE ORDER PARAMETER FOR UNRES
C LIKE WITH TWISTTYPE10...
C
C ROUTINE TO CALCULATE DIFFERENCE BETWEEN
C DIFFERENT INTERNAL COORDINATE DIHEDRAL VALUES FOR PASSED COORDINATE ARRAY QLOCAL AND A STORED REFERENCE ARRAY
C (SEE KEYWORDS.F)
C
      SUBROUTINE UNRESCALCDIHEREF(DIHE,ALLANG,QLOCAL)
      USE COMMONS
C     USE KEY
      USE MODUNRES
      IMPLICIT NONE

      INTEGER I1,J1
C
      REAL*8 X(NATOMS),Y(NATOMS),Z(NATOMS)
      REAL*8 DIFFPP,DIHE, SUMD2,ALLDIFFPP, ALLANG, ALLSUMD2
      REAL*8 QPPSANGLE(4*NRES-9),DIFFARRAY(4*NRES-9),QLOCAL(3*NATOMS)
      INTEGER IICD,TWISTMODE,TWISTTYPE,NM,NWRONG
      LOGICAL LINTCOOR,PTEST
      DOUBLE PRECISION PI
      PARAMETER (PI=3.141592653589793D0)

      DO I1=1,NRES
         C(1,I1)=QLOCAL(6*(I1-1)+1)
         C(2,I1)=QLOCAL(6*(I1-1)+2)
         C(3,I1)=QLOCAL(6*(I1-1)+3)
         C(1,I1+NRES)=QLOCAL(6*(I1-1)+4)
         C(2,I1+NRES)=QLOCAL(6*(I1-1)+5)
         C(3,I1+NRES)=QLOCAL(6*(I1-1)+6)
C     PRINT *,'QLOCAL IN UNRESCALCDIHE: ',QLOCAL(6*(I1-1)+1),QLOCAL(6*(I1-1)+2),QLOCAL(6*(I1-1)+3)
C     PRINT *,'QLOCAL IN UNRESCALCDIHE: ',QLOCAL(6*(I1-1)+4),QLOCAL(6*(I1-1)+5),QLOCAL(6*(I1-1)+6)
      END DO
      CALL UPDATEDC
      CALL INT_FROM_CART(.TRUE.,.FALSE.)

C USE UNRES GEOMETRY ARRAYS PHI (BB DIHEDRALS) AND OMEG (SC DIHEDRALS)
C TAKE CARE WITH NUMBERING - SEE /UNRES/SRC/READPDB.F (SUBROUTINE INT_FROM_CART)
C FOR SIDE CHAIN DIHEDRALS, HAVE ZERO ELEMENTS FOR PROPER (I.E. NOT CAPPING) GLYCINES.
C NEED TO REMEMBER NOT TO TRY TO TWIST THEM THOUGH!
C NO ENTRIES IN QPPSANGLE FOR CAPPING 'RESIDUES'.
      DO I1=1,NRES-3
        QPPSANGLE(I1)=PHI(I1+3)
      END DO
      DO I1=1,NRES-2
        QPPSANGLE(I1+NRES-3)=OMEG(I1+1)
C JMC 30/4/03 TRY ADDING BACKBONE AND SIDE CHAIN POLAR ANGLES
C THIS SHOULD BE MORE IMPORTANT FOR UNRES THAN FOR CHARMM...
C ORDER IS BB DIHEDRALS, SC DIHEDRALS, BB POLARS, SC POLARS.
        QPPSANGLE(I1+2*NRES-5)=THETA(I1+2)
        QPPSANGLE(I1+3*NRES-7)=ALPH(I1+1)
      END DO
C
      SUMD2=0.D0
      DO I1=1,NPHI+NRES-2
         DIFFPP = QPPSANGLE(I1) - UREFPPSANGLE(I1)

C
C NEXT TWO LINES ARE MEANT TO ENSURE THAT YOU ALWAYS INTERPOLATE
C ALONG THE SHORTEST DISTANCE BETWEEN THE DIHEDRAL ANGLES.
C
C JMC         IF (DIFFPP.GT.180.0) DIFFPP = DIFFPP-360.D0
C JMC         IF (DIFFPP.GT.180.0) DIFFPP = DIFFPP-360.D0
         IF (DIFFPP.LT.-PI) DIFFPP = DIFFPP+2.0D0*PI
         IF (DIFFPP.GT.PI) DIFFPP = DIFFPP-2.0D0*PI
         SUMD2=SUMD2+DIFFPP*DIFFPP
      ENDDO

      ALLSUMD2=SUMD2
      DO I1=NPHI+NRES-1,NPHI+NTHETA+2*NRES-4
         DIFFPP = QPPSANGLE(I1) - UREFPPSANGLE(I1)
C
C NEXT TWO LINES ARE MEANT TO ENSURE THAT YOU ALWAYS INTERPOLATE
C ALONG THE SHORTEST DISTANCE BETWEEN THE ANGLES.
C
C JMC         IF (DIFFPP.GT.180.0) DIFFPP = DIFFPP-360.D0
C JMC         IF (DIFFPP.GT.180.0) DIFFPP = DIFFPP-360.D0
C        IF (DIFFPP.LT.-PI) DIFFPP = DIFFPP+2.0D0*PI
C        IF (DIFFPP.GT.PI) DIFFPP = DIFFPP-2.0D0*PI
         ALLSUMD2=ALLSUMD2+DIFFPP*DIFFPP
      ENDDO
 
C JMC TESTING
C     PRINT *,'DIHE,ALLANG ',SUMD2,ALLSUMD2
C JMC REMEMBER IF SUMD IS IN RADIANS, THEN DIHE WILL HAVE DIFFERENT
C RANGE OF VALUES FOR CHARMM VS UNRES...
      DIHE=DSQRT(SUMD2/(NPHI+NSIDE))
      ALLANG=DSQRT(ALLSUMD2/(NPHI+NTHETA+2.0D0*NSIDE))

      RETURN

      END

C
C ROUTINE TO READ IN REFERENCE COORDINATES IN PLAIN XYZ FORMAT (UNRES) FOR MIND/RMSD COMPARISON
C STORED IN CHREF COMMON BLOCK
C
      SUBROUTINE UNREADREF(NATOMS)
      USE MODUNRES
      IMPLICIT NONE
       
      INTEGER I1,NATOMS,J1
      REAL*8 X(NATOMS), Y(NATOMS), Z(NATOMS)
      CHARACTER*2 DUM

      OPEN (UNIT=10,FILE='REF.CRD',STATUS='OLD')

      READ(10,*)
      DO I1=1,NATOMS
         READ(10,*) DUM,UREFCOORD(3*(I1-1)+1),UREFCOORD(3*(I1-1)+2),UREFCOORD(3*(I1-1)+3)
      ENDDO
      CLOSE(10)
C
      DO I1=1,NRES
         C(1,I1)=UREFCOORD(6*(I1-1)+1)
         C(2,I1)=UREFCOORD(6*(I1-1)+2)
         C(3,I1)=UREFCOORD(6*(I1-1)+3)
         C(1,I1+NRES)=UREFCOORD(6*(I1-1)+4)
         C(2,I1+NRES)=UREFCOORD(6*(I1-1)+5)
         C(3,I1+NRES)=UREFCOORD(6*(I1-1)+6)
      END DO
      CALL UPDATEDC
      CALL INT_FROM_CART(.TRUE.,.FALSE.)

C USE UNRES GEOMETRY ARRAYS PHI (BB DIHEDRALS) AND OMEG (SC DIHEDRALS)
C TAKE CARE WITH NUMBERING - SEE /UNRES/SRC/READPDB.F (SUBROUTINE INT_FROM_CART)
C FOR SIDE CHAIN DIHEDRALS, HAVE ZERO ELEMENTS FOR PROPER (I.E. NOT CAPPING) GLYCINES.
C NEED TO REMEMBER NOT TO TRY TO TWIST THEM THOUGH!
C NO ENTRIES IN QPPSANGLE FOR CAPPING 'RESIDUES'.
      DO I1=1,NRES-3
        UREFPPSANGLE(I1)=PHI(I1+3)
      END DO
      DO I1=1,NRES-2
        UREFPPSANGLE(I1+NRES-3)=OMEG(I1+1)
C JMC 30/4/03 TRY ADDING BACKBONE AND SIDE CHAIN POLAR ANGLES
C THIS SHOULD BE MORE IMPORTANT FOR UNRES THAN FOR CHARMM...
C ORDER IS BB DIHEDRALS, SC DIHEDRALS, BB POLARS, SC POLARS.
        UREFPPSANGLE(I1+2*NRES-5)=THETA(I1+2)
        UREFPPSANGLE(I1+3*NRES-7)=ALPH(I1+1)
      END DO

      RETURN
      END

C
C ROUTINE TO CALCULATE RADIUS OF GYRATION
C
      SUBROUTINE UNRESCALCRGYR(RGYR,QLOCAL)
      USE COMMONS
      IMPLICIT NONE

      INTEGER I1
      REAL*8 X(NATOMS),Y(NATOMS),Z(NATOMS),QLOCAL(3*NATOMS)
      REAL*8 RGYR
      REAL*8 AM(NATOMS),W(NATOMS)
      INTEGER ISLCT(NATOMS)
      REAL*8 FACT
      LOGICAL LMASS,LWEIG
 
      DO I1=1,NATOMS
        X(I1)=QLOCAL(3*(I1-1)+1)
        Y(I1)=QLOCAL(3*(I1-1)+2)
        Z(I1)=QLOCAL(3*(I1-1)+3)
        ISLCT(I1)=1
      ENDDO

      LMASS=.FALSE.
      LWEIG=.FALSE.
      FACT=0.0D0

C JMC W IS WEIGHTING ARRAY.
C JMC WE'RE ALWAYS CALCULATING THE GEOMETRIC RGY, SINCE LMASS AND LWEIG ARE FALSE.
      CALL UEDITRGYR(RGYR,NATOMS,X,Y,Z,W,AM,ISLCT,FACT,LMASS,LWEIG)

      RETURN
      END
C
C DAE MODIFIED SOLELY TO PASS RG BACK TO OPTIM
C

CHARMM ELEMENT SOURCE/MANIP/RGYR.SRC 1.1

      SUBROUTINE UEDITRGYR(RG,NATOMS,X,Y,Z,W,AM,ISLCT,FACT,LMASS,LWEIG)

      IMPLICIT NONE
C-----------------------------------------------------------------------
C     COMPUTE THE RADIUS OF GYRATION, CENTER OF MASS,
C     AND TOTAL MASS OF THE SELECTED SUBSET OF EITHER THE MAIN OR
C     THE COMPARISON STRUCTURE. THE RESULTS ARE OUTPUT TO UNIT OUTU.
C     IF KEYWORD WEIG IS GIVEN THE WEIGHTING ARRAY, WHICH THE USER
C     MUST FILL WITH CORMAN OR SCALAR COMMANDS, IS USED FOR THE
C     WEIGHTING. THIS IS INDICATED BY LWEIG=.TRUE. AND IS TAKEN CARE
C     OF IN CORMAN'S CALL TO RGYR.
C     IF KEYWORD MASS IS GIVEN, THEN THE MASS-WEIGHTED RADIUS OF
C     GYRATION, ETC ARE COMPUTED, OTHERWISE UNIT WEIGHTING PER
C     ATOM IS USED (GIVING RMS DISTANCE FROM THE GEOMETRIC CENTER).
C     THE DEFAULT OPTION IS TO DO E GEOMETRIC RGYR CALCULATION.
C     A CONSTANT OFFSET TO BE SUBTRACTED FROM THE WEIGHTS CAN BE
C     SPECIFIED WITH KEYWORD FACT.
C
C     SYNTAX:
C
C     COOR RGYR  [FACT <REAL>] {[MASS]} [COMP]  [<ATOM-SELECTION>]
C     {[WEIG]}
C
C     1983-09-01/LN
C     1985-01-05/ DEFAULT REVISED /LN
C
C##INCLUDE '/EXPORT/HOME/DAE22/CHARMMCODE/FCM/IMPNON.FCM'
C##INCLUDE '/EXPORT/HOME/DAE22/CHARMMCODE/FCM/NUMBER.FCM'
C##INCLUDE '/EXPORT/HOME/DAE22/CHARMMCODE/FCM/STREAM.FCM'
C     IMPLICIT REAL*8(A-H,O-Z)

      INTEGER NATOMS
      REAL*8 X(*),Y(*),Z(*),W(*)
      REAL*8 AM(*)
      INTEGER ISLCT(*)
      REAL*8 FACT,ANUM
      LOGICAL LMASS,LWEIG
      REAL*8 XCM,YCM,ZCM
      INTEGER NMISS,I
      REAL*8 TMASS,WW,RG,AR

C JMC
      INTEGER*1 OUTU
      OUTU=6

      ANUM=9999.0D0
C
C     CENTER-OF-MASS:
C
      XCM=0.0D0
      YCM=0.0D0
      ZCM=0.0D0
      TMASS=0.0D0
      NMISS=0
C
      DO 10 I=1,NATOMS
        IF (ISLCT(I).NE.1) THEN
        ELSE IF (X(I).EQ.ANUM) THEN
          NMISS=NMISS+1
        ELSE
          IF (LMASS.AND.LWEIG) THEN
            WW=W(I)*AM(I)
          ELSE IF (LMASS) THEN
            WW=AM(I)
          ELSE IF (LWEIG) THEN
            WW=W(I)
          ELSE
            WW=1.0D0
          ENDIF
          WW=WW-FACT
          XCM=WW*X(I)+XCM
          YCM=WW*Y(I)+YCM
          ZCM=WW*Z(I)+ZCM
          TMASS=WW+TMASS
        ENDIF
 10   CONTINUE
C
      IF(NMISS.EQ.NATOMS) THEN
C       IF(WRNLEV.GE.2) WRITE(OUTU,25)
        WRITE(OUTU,25)
C       RETURN
      ENDIF
 25   FORMAT(/' RGYR: *** ERROR ***  ALL COORDINATES WERE MISSING'/)
C
      IF(TMASS.LE.0.0) THEN
C       IF(PRNLEV.GE.2) WRITE(OUTU,35) TMASS
        WRITE(OUTU,35) TMASS
        IF(TMASS.EQ.0.0) RETURN
      ENDIF
 35   FORMAT(/' RGYR: *** WARNING *** NET "MASS"=',F12.5/)
C
      XCM=XCM/TMASS
      YCM=YCM/TMASS
      ZCM=ZCM/TMASS
C     IF(NMISS.NE.0 .AND. WRNLEV.GE.2) WRITE(OUTU,45) NMISS
      IF(NMISS.NE.0) WRITE(OUTU,45) NMISS
 45   FORMAT(/' RGYR:   THERE WERE',I5,' MISSING COORDINATES.'/)
C
C     RADIUS OF GYRATION:
C
      RG=0.0D0
      DO 60 I=1,NATOMS
        IF (ISLCT(I).NE.1) THEN
        ELSE IF (X(I).EQ.ANUM) THEN
        ELSE
          IF (LMASS.AND.LWEIG) THEN
            WW=W(I)*AM(I)
          ELSE IF (LMASS) THEN
            WW=AM(I)
          ELSE IF (LWEIG) THEN
            WW=W(I)
          ELSE
            WW=1.0D0
          ENDIF
          WW=WW-FACT
          RG=RG+WW*((X(I)-XCM)**2+(Y(I)-YCM)**2+(Z(I)-ZCM)**2)
        ENDIF
 60   CONTINUE
      AR=ABS(RG/TMASS)
C
C     COMPUTE AN RG WITH THE SAME SIGN AS RG/TMASS:
C
      RG=SQRT(AR)*RG/(TMASS*AR)

C     CALL SETMSR('RGYR',RG)
C     CALL SETMSR('MASS',TMASS)
C     CALL SETMSR('XCM ',XCM)
C     CALL SETMSR('YCM ',YCM)
C     CALL SETMSR('ZCM ',ZCM)
C
C     IF(PRNLEV.GE.2) THEN
        IF(LWEIG) WRITE(OUTU,71)
        IF(LMASS) WRITE(OUTU,72)
        IF(.NOT. (LMASS.OR.LWEIG)) WRITE(OUTU,73)
        WRITE(OUTU,74) RG,TMASS,XCM,YCM,ZCM
C     ENDIF
 71   FORMAT(/' RGYR:'/)
 72   FORMAT(/' RGYR:  MASS WEIGHTED RESULTS:'/)
 73   FORMAT(/' RGYR:  GEOMETRIC RESULTS:'/)
 74   FORMAT(/'       RADIUS OF GYRATION=',F12.5,5X,
     $     'NET "MASS"=',F12.3/
     $     '       CENTER-OF-"MASS" = ' ,3F12.5/)
C
      RETURN
      END
