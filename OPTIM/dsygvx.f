C   OPTIM: A PROGRAM FOR OPTIMIZING GEOMETRIES AND CALCULATING REACTION PATHWAYS
C   COPYRIGHT (C) 1999-2006 DAVID J. WALES
C   THIS FILE IS PART OF OPTIM.
C
C   OPTIM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C   IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C   THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C   (AT YOUR OPTION) ANY LATER VERSION.
C
C   OPTIM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
C   BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
C   GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C   YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C   ALONG WITH THIS PROGRAM; IF NOT, WRITE TO THE FREE SOFTWARE
C   FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330, BOSTON, MA  02111-1307  USA
C
      SUBROUTINE DSYGVX( ITYPE, JOBZ, RANGE, UPLO, N, A, LDA, B, LDB,
     $                   VL, VU, IL, IU, ABSTOL, M, W, Z, LDZ, WORK,
     $                   LWORK, IWORK, IFAIL, INFO )
*
*  -- LAPACK DRIVER ROUTINE (VERSION 3.0) --
*     UNIV. OF TENNESSEE, UNIV. OF CALIFORNIA BERKELEY, NAG LTD.,
*     COURANT INSTITUTE, ARGONNE NATIONAL LAB, AND RICE UNIVERSITY
*     JUNE 30, 1999
*
*     .. SCALAR ARGUMENTS ..
      CHARACTER          JOBZ, RANGE, UPLO
      INTEGER            IL, INFO, ITYPE, IU, LDA, LDB, LDZ, LWORK, M, N
      DOUBLE PRECISION   ABSTOL, VL, VU
*     ..
*     .. ARRAY ARGUMENTS ..
      INTEGER            IFAIL( * ), IWORK( * )
      DOUBLE PRECISION   A( LDA, * ), B( LDB, * ), W( * ), WORK( * ),
     $                   Z( LDZ, * )
*     ..
*
*  PURPOSE
*  =======
*
*  DSYGVX COMPUTES SELECTED EIGENVALUES, AND OPTIONALLY, EIGENVECTORS
*  OF A REAL GENERALIZED SYMMETRIC-DEFINITE EIGENPROBLEM, OF THE FORM
*  A*X=(LAMBDA)*B*X,  A*BX=(LAMBDA)*X,  OR B*A*X=(LAMBDA)*X.  HERE A
*  AND B ARE ASSUMED TO BE SYMMETRIC AND B IS ALSO POSITIVE DEFINITE.
*  EIGENVALUES AND EIGENVECTORS CAN BE SELECTED BY SPECIFYING EITHER A
*  RANGE OF VALUES OR A RANGE OF INDICES FOR THE DESIRED EIGENVALUES.
*
*  ARGUMENTS
*  =========
*
*  ITYPE   (INPUT) INTEGER
*          SPECIFIES THE PROBLEM TYPE TO BE SOLVED:
*          = 1:  A*X = (LAMBDA)*B*X
*          = 2:  A*B*X = (LAMBDA)*X
*          = 3:  B*A*X = (LAMBDA)*X
*
*  JOBZ    (INPUT) CHARACTER*1
*          = 'N':  COMPUTE EIGENVALUES ONLY;
*          = 'V':  COMPUTE EIGENVALUES AND EIGENVECTORS.
*
*  RANGE   (INPUT) CHARACTER*1
*          = 'A': ALL EIGENVALUES WILL BE FOUND.
*          = 'V': ALL EIGENVALUES IN THE HALF-OPEN INTERVAL (VL,VU]
*                 WILL BE FOUND.
*          = 'I': THE IL-TH THROUGH IU-TH EIGENVALUES WILL BE FOUND.
*
*  UPLO    (INPUT) CHARACTER*1
*          = 'U':  UPPER TRIANGLE OF A AND B ARE STORED;
*          = 'L':  LOWER TRIANGLE OF A AND B ARE STORED.
*
*  N       (INPUT) INTEGER
*          THE ORDER OF THE MATRIX PENCIL (A,B).  N >= 0.
*
*  A       (INPUT/OUTPUT) DOUBLE PRECISION ARRAY, DIMENSION (LDA, N)
*          ON ENTRY, THE SYMMETRIC MATRIX A.  IF UPLO = 'U', THE
*          LEADING N-BY-N UPPER TRIANGULAR PART OF A CONTAINS THE
*          UPPER TRIANGULAR PART OF THE MATRIX A.  IF UPLO = 'L',
*          THE LEADING N-BY-N LOWER TRIANGULAR PART OF A CONTAINS
*          THE LOWER TRIANGULAR PART OF THE MATRIX A.
*
*          ON EXIT, THE LOWER TRIANGLE (IF UPLO='L') OR THE UPPER
*          TRIANGLE (IF UPLO='U') OF A, INCLUDING THE DIAGONAL, IS
*          DESTROYED.
*
*  LDA     (INPUT) INTEGER
*          THE LEADING DIMENSION OF THE ARRAY A.  LDA >= MAX(1,N).
*
*  B       (INPUT/OUTPUT) DOUBLE PRECISION ARRAY, DIMENSION (LDA, N)
*          ON ENTRY, THE SYMMETRIC MATRIX B.  IF UPLO = 'U', THE
*          LEADING N-BY-N UPPER TRIANGULAR PART OF B CONTAINS THE
*          UPPER TRIANGULAR PART OF THE MATRIX B.  IF UPLO = 'L',
*          THE LEADING N-BY-N LOWER TRIANGULAR PART OF B CONTAINS
*          THE LOWER TRIANGULAR PART OF THE MATRIX B.
*
*          ON EXIT, IF INFO <= N, THE PART OF B CONTAINING THE MATRIX IS
*          OVERWRITTEN BY THE TRIANGULAR FACTOR U OR L FROM THE CHOLESKY
*          FACTORIZATION B = U**T*U OR B = L*L**T.
*
*  LDB     (INPUT) INTEGER
*          THE LEADING DIMENSION OF THE ARRAY B.  LDB >= MAX(1,N).
*
*  VL      (INPUT) DOUBLE PRECISION
*  VU      (INPUT) DOUBLE PRECISION
*          IF RANGE='V', THE LOWER AND UPPER BOUNDS OF THE INTERVAL TO
*          BE SEARCHED FOR EIGENVALUES. VL < VU.
*          NOT REFERENCED IF RANGE = 'A' OR 'I'.
*
*  IL      (INPUT) INTEGER
*  IU      (INPUT) INTEGER
*          IF RANGE='I', THE INDICES (IN ASCENDING ORDER) OF THE
*          SMALLEST AND LARGEST EIGENVALUES TO BE RETURNED.
*          1 <= IL <= IU <= N, IF N > 0; IL = 1 AND IU = 0 IF N = 0.
*          NOT REFERENCED IF RANGE = 'A' OR 'V'.
*
*  ABSTOL  (INPUT) DOUBLE PRECISION
*          THE ABSOLUTE ERROR TOLERANCE FOR THE EIGENVALUES.
*          AN APPROXIMATE EIGENVALUE IS ACCEPTED AS CONVERGED
*          WHEN IT IS DETERMINED TO LIE IN AN INTERVAL [A,B]
*          OF WIDTH LESS THAN OR EQUAL TO
*
*                  ABSTOL + EPS *   MAX( |A|,|B| ) ,
*
*          WHERE EPS IS THE MACHINE PRECISION.  IF ABSTOL IS LESS THAN
*          OR EQUAL TO ZERO, THEN  EPS*|T|  WILL BE USED IN ITS PLACE,
*          WHERE |T| IS THE 1-NORM OF THE TRIDIAGONAL MATRIX OBTAINED
*          BY REDUCING A TO TRIDIAGONAL FORM.
*
*          EIGENVALUES WILL BE COMPUTED MOST ACCURATELY WHEN ABSTOL IS
*          SET TO TWICE THE UNDERFLOW THRESHOLD 2*DLAMCH('S'), NOT ZERO.
*          IF THIS ROUTINE RETURNS WITH INFO>0, INDICATING THAT SOME
*          EIGENVECTORS DID NOT CONVERGE, TRY SETTING ABSTOL TO
*          2*DLAMCH('S').
*
*  M       (OUTPUT) INTEGER
*          THE TOTAL NUMBER OF EIGENVALUES FOUND.  0 <= M <= N.
*          IF RANGE = 'A', M = N, AND IF RANGE = 'I', M = IU-IL+1.
*
*  W       (OUTPUT) DOUBLE PRECISION ARRAY, DIMENSION (N)
*          ON NORMAL EXIT, THE FIRST M ELEMENTS CONTAIN THE SELECTED
*          EIGENVALUES IN ASCENDING ORDER.
*
*  Z       (OUTPUT) DOUBLE PRECISION ARRAY, DIMENSION (LDZ, MAX(1,M))
*          IF JOBZ = 'N', THEN Z IS NOT REFERENCED.
*          IF JOBZ = 'V', THEN IF INFO = 0, THE FIRST M COLUMNS OF Z
*          CONTAIN THE ORTHONORMAL EIGENVECTORS OF THE MATRIX A
*          CORRESPONDING TO THE SELECTED EIGENVALUES, WITH THE I-TH
*          COLUMN OF Z HOLDING THE EIGENVECTOR ASSOCIATED WITH W(I).
*          THE EIGENVECTORS ARE NORMALIZED AS FOLLOWS:
*          IF ITYPE = 1 OR 2, Z**T*B*Z = I;
*          IF ITYPE = 3, Z**T*INV(B)*Z = I.
*
*          IF AN EIGENVECTOR FAILS TO CONVERGE, THEN THAT COLUMN OF Z
*          CONTAINS THE LATEST APPROXIMATION TO THE EIGENVECTOR, AND THE
*          INDEX OF THE EIGENVECTOR IS RETURNED IN IFAIL.
*          NOTE: THE USER MUST ENSURE THAT AT LEAST MAX(1,M) COLUMNS ARE
*          SUPPLIED IN THE ARRAY Z; IF RANGE = 'V', THE EXACT VALUE OF M
*          IS NOT KNOWN IN ADVANCE AND AN UPPER BOUND MUST BE USED.
*
*  LDZ     (INPUT) INTEGER
*          THE LEADING DIMENSION OF THE ARRAY Z.  LDZ >= 1, AND IF
*          JOBZ = 'V', LDZ >= MAX(1,N).
*
*  WORK    (WORKSPACE/OUTPUT) DOUBLE PRECISION ARRAY, DIMENSION (LWORK)
*          ON EXIT, IF INFO = 0, WORK(1) RETURNS THE OPTIMAL LWORK.
*
*  LWORK   (INPUT) INTEGER
*          THE LENGTH OF THE ARRAY WORK.  LWORK >= MAX(1,8*N).
*          FOR OPTIMAL EFFICIENCY, LWORK >= (NB+3)*N,
*          WHERE NB IS THE BLOCKSIZE FOR DSYTRD RETURNED BY ILAENV.
*
*          IF LWORK = -1, THEN A WORKSPACE QUERY IS ASSUMED; THE ROUTINE
*          ONLY CALCULATES THE OPTIMAL SIZE OF THE WORK ARRAY, RETURNS
*          THIS VALUE AS THE FIRST ENTRY OF THE WORK ARRAY, AND NO ERROR
*          MESSAGE RELATED TO LWORK IS ISSUED BY XERBLA.
*
*  IWORK   (WORKSPACE) INTEGER ARRAY, DIMENSION (5*N)
*
*  IFAIL   (OUTPUT) INTEGER ARRAY, DIMENSION (N)
*          IF JOBZ = 'V', THEN IF INFO = 0, THE FIRST M ELEMENTS OF
*          IFAIL ARE ZERO.  IF INFO > 0, THEN IFAIL CONTAINS THE
*          INDICES OF THE EIGENVECTORS THAT FAILED TO CONVERGE.
*          IF JOBZ = 'N', THEN IFAIL IS NOT REFERENCED.
*
*  INFO    (OUTPUT) INTEGER
*          = 0:  SUCCESSFUL EXIT
*          < 0:  IF INFO = -I, THE I-TH ARGUMENT HAD AN ILLEGAL VALUE
*          > 0:  DPOTRF OR DSYEVX RETURNED AN ERROR CODE:
*             <= N:  IF INFO = I, DSYEVX FAILED TO CONVERGE;
*                    I EIGENVECTORS FAILED TO CONVERGE.  THEIR INDICES
*                    ARE STORED IN ARRAY IFAIL.
*             > N:   IF INFO = N + I, FOR 1 <= I <= N, THEN THE LEADING
*                    MINOR OF ORDER I OF B IS NOT POSITIVE DEFINITE.
*                    THE FACTORIZATION OF B COULD NOT BE COMPLETED AND
*                    NO EIGENVALUES OR EIGENVECTORS WERE COMPUTED.
*
*  FURTHER DETAILS
*  ===============
*
*  BASED ON CONTRIBUTIONS BY
*     MARK FAHEY, DEPARTMENT OF MATHEMATICS, UNIV. OF KENTUCKY, USA
*
* =====================================================================
*
*     .. PARAMETERS ..
      DOUBLE PRECISION   ONE
      PARAMETER          ( ONE = 1.0D+0 )
*     ..
*     .. LOCAL SCALARS ..
      LOGICAL            ALLEIG, INDEIG, LQUERY, UPPER, VALEIG, WANTZ
      CHARACTER          TRANS
      INTEGER            LOPT, LWKOPT, NB
*     ..
*     .. EXTERNAL FUNCTIONS ..
      LOGICAL            LSAME
      INTEGER            ILAENV
      EXTERNAL           LSAME, ILAENV
*     ..
*     .. EXTERNAL SUBROUTINES ..
      EXTERNAL           DPOTRF, DSYEVX, DSYGST, DTRMM, DTRSM, XERBLA
*     ..
*     .. INTRINSIC FUNCTIONS ..
      INTRINSIC          MAX, MIN
*     ..
*     .. EXECUTABLE STATEMENTS ..
*
*     TEST THE INPUT PARAMETERS.
*
      UPPER = LSAME( UPLO, 'U' )
      WANTZ = LSAME( JOBZ, 'V' )
      ALLEIG = LSAME( RANGE, 'A' )
      VALEIG = LSAME( RANGE, 'V' )
      INDEIG = LSAME( RANGE, 'I' )
      LQUERY = ( LWORK.EQ.-1 )
*
      INFO = 0
      IF( ITYPE.LT.0 .OR. ITYPE.GT.3 ) THEN
         INFO = -1
      ELSE IF( .NOT.( WANTZ .OR. LSAME( JOBZ, 'N' ) ) ) THEN
         INFO = -2
      ELSE IF( .NOT.( ALLEIG .OR. VALEIG .OR. INDEIG ) ) THEN
         INFO = -3
      ELSE IF( .NOT.( UPPER .OR. LSAME( UPLO, 'L' ) ) ) THEN
         INFO = -4
      ELSE IF( N.LT.0 ) THEN
         INFO = -5
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -7
      ELSE IF( LDB.LT.MAX( 1, N ) ) THEN
         INFO = -9
      ELSE IF( VALEIG .AND. N.GT.0 ) THEN
         IF( VU.LE.VL )
     $      INFO = -11
      ELSE IF( INDEIG .AND. IL.LT.1 ) THEN
         INFO = -12
      ELSE IF( INDEIG .AND. ( IU.LT.MIN( N, IL ) .OR. IU.GT.N ) ) THEN
         INFO = -13
      ELSE IF( LDZ.LT.1 .OR. ( WANTZ .AND. LDZ.LT.N ) ) THEN
         INFO = -18
      ELSE IF( LWORK.LT.MAX( 1, 8*N ) .AND. .NOT.LQUERY ) THEN
         INFO = -20
      END IF
*
      IF( INFO.EQ.0 ) THEN
         NB = ILAENV( 1, 'DSYTRD', UPLO, N, -1, -1, -1 )
         LWKOPT = ( NB+3 )*N
         WORK( 1 ) = LWKOPT
      END IF
*
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DSYGVX', -INFO )
         RETURN
      ELSE IF( LQUERY ) THEN
         RETURN
      END IF
*
*     QUICK RETURN IF POSSIBLE
*
      M = 0
      IF( N.EQ.0 ) THEN
         WORK( 1 ) = 1
         RETURN
      END IF
*
*     FORM A CHOLESKY FACTORIZATION OF B.
*
      CALL DPOTRF( UPLO, N, B, LDB, INFO )
      IF( INFO.NE.0 ) THEN
         INFO = N + INFO
         RETURN
      END IF
*
*     TRANSFORM PROBLEM TO STANDARD EIGENVALUE PROBLEM AND SOLVE.
*
      CALL DSYGST( ITYPE, UPLO, N, A, LDA, B, LDB, INFO )
      CALL DSYEVX( JOBZ, RANGE, UPLO, N, A, LDA, VL, VU, IL, IU, ABSTOL,
     $             M, W, Z, LDZ, WORK, LWORK, IWORK, IFAIL, INFO )
      LOPT = WORK( 1 )
*
      IF( WANTZ ) THEN
*
*        BACKTRANSFORM EIGENVECTORS TO THE ORIGINAL PROBLEM.
*
         IF( INFO.GT.0 )
     $      M = INFO - 1
         IF( ITYPE.EQ.1 .OR. ITYPE.EQ.2 ) THEN
*
*           FOR A*X=(LAMBDA)*B*X AND A*B*X=(LAMBDA)*X;
*           BACKTRANSFORM EIGENVECTORS: X = INV(L)'*Y OR INV(U)*Y
*
            IF( UPPER ) THEN
               TRANS = 'N'
            ELSE
               TRANS = 'T'
            END IF
*
            CALL DTRSM( 'LEFT', UPLO, TRANS, 'NON-UNIT', N, M, ONE, B,
     $                  LDB, Z, LDZ )
*
         ELSE IF( ITYPE.EQ.3 ) THEN
*
*           FOR B*A*X=(LAMBDA)*X;
*           BACKTRANSFORM EIGENVECTORS: X = L*Y OR U'*Y
*
            IF( UPPER ) THEN
               TRANS = 'T'
            ELSE
               TRANS = 'N'
            END IF
*
            CALL DTRMM( 'LEFT', UPLO, TRANS, 'NON-UNIT', N, M, ONE, B,
     $                  LDB, Z, LDZ )
         END IF
      END IF
*
*     SET WORK(1) TO OPTIMAL WORKSPACE SIZE.
*
      WORK( 1 ) = LWKOPT
*
      RETURN
*
*     END OF DSYGVX
*
      END
      SUBROUTINE DSYEVX( JOBZ, RANGE, UPLO, N, A, LDA, VL, VU, IL, IU,
     $                   ABSTOL, M, W, Z, LDZ, WORK, LWORK, IWORK,
     $                   IFAIL, INFO )
*
*  -- LAPACK DRIVER ROUTINE (VERSION 3.0) --
*     UNIV. OF TENNESSEE, UNIV. OF CALIFORNIA BERKELEY, NAG LTD.,
*     COURANT INSTITUTE, ARGONNE NATIONAL LAB, AND RICE UNIVERSITY
*     JUNE 30, 1999
*
*     .. SCALAR ARGUMENTS ..
      CHARACTER          JOBZ, RANGE, UPLO
      INTEGER            IL, INFO, IU, LDA, LDZ, LWORK, M, N
      DOUBLE PRECISION   ABSTOL, VL, VU
*     ..
*     .. ARRAY ARGUMENTS ..
      INTEGER            IFAIL( * ), IWORK( * )
      DOUBLE PRECISION   A( LDA, * ), W( * ), WORK( * ), Z( LDZ, * )
*     ..
*
*  PURPOSE
*  =======
*
*  DSYEVX COMPUTES SELECTED EIGENVALUES AND, OPTIONALLY, EIGENVECTORS
*  OF A REAL SYMMETRIC MATRIX A.  EIGENVALUES AND EIGENVECTORS CAN BE
*  SELECTED BY SPECIFYING EITHER A RANGE OF VALUES OR A RANGE OF INDICES
*  FOR THE DESIRED EIGENVALUES.
*
*  ARGUMENTS
*  =========
*
*  JOBZ    (INPUT) CHARACTER*1
*          = 'N':  COMPUTE EIGENVALUES ONLY;
*          = 'V':  COMPUTE EIGENVALUES AND EIGENVECTORS.
*
*  RANGE   (INPUT) CHARACTER*1
*          = 'A': ALL EIGENVALUES WILL BE FOUND.
*          = 'V': ALL EIGENVALUES IN THE HALF-OPEN INTERVAL (VL,VU]
*                 WILL BE FOUND.
*          = 'I': THE IL-TH THROUGH IU-TH EIGENVALUES WILL BE FOUND.
*
*  UPLO    (INPUT) CHARACTER*1
*          = 'U':  UPPER TRIANGLE OF A IS STORED;
*          = 'L':  LOWER TRIANGLE OF A IS STORED.
*
*  N       (INPUT) INTEGER
*          THE ORDER OF THE MATRIX A.  N >= 0.
*
*  A       (INPUT/OUTPUT) DOUBLE PRECISION ARRAY, DIMENSION (LDA, N)
*          ON ENTRY, THE SYMMETRIC MATRIX A.  IF UPLO = 'U', THE
*          LEADING N-BY-N UPPER TRIANGULAR PART OF A CONTAINS THE
*          UPPER TRIANGULAR PART OF THE MATRIX A.  IF UPLO = 'L',
*          THE LEADING N-BY-N LOWER TRIANGULAR PART OF A CONTAINS
*          THE LOWER TRIANGULAR PART OF THE MATRIX A.
*          ON EXIT, THE LOWER TRIANGLE (IF UPLO='L') OR THE UPPER
*          TRIANGLE (IF UPLO='U') OF A, INCLUDING THE DIAGONAL, IS
*          DESTROYED.
*
*  LDA     (INPUT) INTEGER
*          THE LEADING DIMENSION OF THE ARRAY A.  LDA >= MAX(1,N).
*
*  VL      (INPUT) DOUBLE PRECISION
*  VU      (INPUT) DOUBLE PRECISION
*          IF RANGE='V', THE LOWER AND UPPER BOUNDS OF THE INTERVAL TO
*          BE SEARCHED FOR EIGENVALUES. VL < VU.
*          NOT REFERENCED IF RANGE = 'A' OR 'I'.
*
*  IL      (INPUT) INTEGER
*  IU      (INPUT) INTEGER
*          IF RANGE='I', THE INDICES (IN ASCENDING ORDER) OF THE
*          SMALLEST AND LARGEST EIGENVALUES TO BE RETURNED.
*          1 <= IL <= IU <= N, IF N > 0; IL = 1 AND IU = 0 IF N = 0.
*          NOT REFERENCED IF RANGE = 'A' OR 'V'.
*
*  ABSTOL  (INPUT) DOUBLE PRECISION
*          THE ABSOLUTE ERROR TOLERANCE FOR THE EIGENVALUES.
*          AN APPROXIMATE EIGENVALUE IS ACCEPTED AS CONVERGED
*          WHEN IT IS DETERMINED TO LIE IN AN INTERVAL [A,B]
*          OF WIDTH LESS THAN OR EQUAL TO
*
*                  ABSTOL + EPS *   MAX( |A|,|B| ) ,
*
*          WHERE EPS IS THE MACHINE PRECISION.  IF ABSTOL IS LESS THAN
*          OR EQUAL TO ZERO, THEN  EPS*|T|  WILL BE USED IN ITS PLACE,
*          WHERE |T| IS THE 1-NORM OF THE TRIDIAGONAL MATRIX OBTAINED
*          BY REDUCING A TO TRIDIAGONAL FORM.
*
*          EIGENVALUES WILL BE COMPUTED MOST ACCURATELY WHEN ABSTOL IS
*          SET TO TWICE THE UNDERFLOW THRESHOLD 2*DLAMCH('S'), NOT ZERO.
*          IF THIS ROUTINE RETURNS WITH INFO>0, INDICATING THAT SOME
*          EIGENVECTORS DID NOT CONVERGE, TRY SETTING ABSTOL TO
*          2*DLAMCH('S').
*
*          SEE "COMPUTING SMALL SINGULAR VALUES OF BIDIAGONAL MATRICES
*          WITH GUARANTEED HIGH RELATIVE ACCURACY," BY DEMMEL AND
*          KAHAN, LAPACK WORKING NOTE #3.
*
*  M       (OUTPUT) INTEGER
*          THE TOTAL NUMBER OF EIGENVALUES FOUND.  0 <= M <= N.
*          IF RANGE = 'A', M = N, AND IF RANGE = 'I', M = IU-IL+1.
*
*  W       (OUTPUT) DOUBLE PRECISION ARRAY, DIMENSION (N)
*          ON NORMAL EXIT, THE FIRST M ELEMENTS CONTAIN THE SELECTED
*          EIGENVALUES IN ASCENDING ORDER.
*
*  Z       (OUTPUT) DOUBLE PRECISION ARRAY, DIMENSION (LDZ, MAX(1,M))
*          IF JOBZ = 'V', THEN IF INFO = 0, THE FIRST M COLUMNS OF Z
*          CONTAIN THE ORTHONORMAL EIGENVECTORS OF THE MATRIX A
*          CORRESPONDING TO THE SELECTED EIGENVALUES, WITH THE I-TH
*          COLUMN OF Z HOLDING THE EIGENVECTOR ASSOCIATED WITH W(I).
*          IF AN EIGENVECTOR FAILS TO CONVERGE, THEN THAT COLUMN OF Z
*          CONTAINS THE LATEST APPROXIMATION TO THE EIGENVECTOR, AND THE
*          INDEX OF THE EIGENVECTOR IS RETURNED IN IFAIL.
*          IF JOBZ = 'N', THEN Z IS NOT REFERENCED.
*          NOTE: THE USER MUST ENSURE THAT AT LEAST MAX(1,M) COLUMNS ARE
*          SUPPLIED IN THE ARRAY Z; IF RANGE = 'V', THE EXACT VALUE OF M
*          IS NOT KNOWN IN ADVANCE AND AN UPPER BOUND MUST BE USED.
*
*  LDZ     (INPUT) INTEGER
*          THE LEADING DIMENSION OF THE ARRAY Z.  LDZ >= 1, AND IF
*          JOBZ = 'V', LDZ >= MAX(1,N).
*
*  WORK    (WORKSPACE/OUTPUT) DOUBLE PRECISION ARRAY, DIMENSION (LWORK)
*          ON EXIT, IF INFO = 0, WORK(1) RETURNS THE OPTIMAL LWORK.
*
*  LWORK   (INPUT) INTEGER
*          THE LENGTH OF THE ARRAY WORK.  LWORK >= MAX(1,8*N).
*          FOR OPTIMAL EFFICIENCY, LWORK >= (NB+3)*N,
*          WHERE NB IS THE MAX OF THE BLOCKSIZE FOR DSYTRD AND DORMTR
*          RETURNED BY ILAENV.
*
*          IF LWORK = -1, THEN A WORKSPACE QUERY IS ASSUMED; THE ROUTINE
*          ONLY CALCULATES THE OPTIMAL SIZE OF THE WORK ARRAY, RETURNS
*          THIS VALUE AS THE FIRST ENTRY OF THE WORK ARRAY, AND NO ERROR
*          MESSAGE RELATED TO LWORK IS ISSUED BY XERBLA.
*
*  IWORK   (WORKSPACE) INTEGER ARRAY, DIMENSION (5*N)
*
*  IFAIL   (OUTPUT) INTEGER ARRAY, DIMENSION (N)
*          IF JOBZ = 'V', THEN IF INFO = 0, THE FIRST M ELEMENTS OF
*          IFAIL ARE ZERO.  IF INFO > 0, THEN IFAIL CONTAINS THE
*          INDICES OF THE EIGENVECTORS THAT FAILED TO CONVERGE.
*          IF JOBZ = 'N', THEN IFAIL IS NOT REFERENCED.
*
*  INFO    (OUTPUT) INTEGER
*          = 0:  SUCCESSFUL EXIT
*          < 0:  IF INFO = -I, THE I-TH ARGUMENT HAD AN ILLEGAL VALUE
*          > 0:  IF INFO = I, THEN I EIGENVECTORS FAILED TO CONVERGE.
*                THEIR INDICES ARE STORED IN ARRAY IFAIL.
*
* =====================================================================
*
*     .. PARAMETERS ..
      DOUBLE PRECISION   ZERO, ONE
      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0 )
*     ..
*     .. LOCAL SCALARS ..
      LOGICAL            ALLEIG, INDEIG, LOWER, LQUERY, VALEIG, WANTZ
      CHARACTER          ORDER
      INTEGER            I, IINFO, IMAX, INDD, INDE, INDEE, INDIBL,
     $                   INDISP, INDIWO, INDTAU, INDWKN, INDWRK, ISCALE,
     $                   ITMP1, J, JJ, LLWORK, LLWRKN, LOPT, LWKOPT, NB,
     $                   NSPLIT
      DOUBLE PRECISION   ABSTLL, ANRM, BIGNUM, EPS, RMAX, RMIN, SAFMIN,
     $                   SIGMA, SMLNUM, TMP1, VLL, VUU
*     ..
*     .. EXTERNAL FUNCTIONS ..
      LOGICAL            LSAME
      INTEGER            ILAENV
      DOUBLE PRECISION   DLAMCH, DLANSY
      EXTERNAL           LSAME, ILAENV, DLAMCH, DLANSY
*     ..
*     .. EXTERNAL SUBROUTINES ..
      EXTERNAL           DCOPY, DLACPY, DORGTR, DORMTR, DSCAL, DSTEBZ,
     $                   DSTEIN, DSTEQR, DSTERF, DSWAP, DSYTRD, XERBLA
*     ..
*     .. INTRINSIC FUNCTIONS ..
      INTRINSIC          MAX, MIN, SQRT
*     ..
*     .. EXECUTABLE STATEMENTS ..
*
*     TEST THE INPUT PARAMETERS.
*
      LOWER = LSAME( UPLO, 'L' )
      WANTZ = LSAME( JOBZ, 'V' )
      ALLEIG = LSAME( RANGE, 'A' )
      VALEIG = LSAME( RANGE, 'V' )
      INDEIG = LSAME( RANGE, 'I' )
      LQUERY = ( LWORK.EQ.-1 )
*
      INFO = 0
      IF( .NOT.( WANTZ .OR. LSAME( JOBZ, 'N' ) ) ) THEN
         INFO = -1
      ELSE IF( .NOT.( ALLEIG .OR. VALEIG .OR. INDEIG ) ) THEN
         INFO = -2
      ELSE IF( .NOT.( LOWER .OR. LSAME( UPLO, 'U' ) ) ) THEN
         INFO = -3
      ELSE IF( N.LT.0 ) THEN
         INFO = -4
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -6
      ELSE
         IF( VALEIG ) THEN
            IF( N.GT.0 .AND. VU.LE.VL )
     $         INFO = -8
         ELSE IF( INDEIG ) THEN
            IF( IL.LT.1 .OR. IL.GT.MAX( 1, N ) ) THEN
               INFO = -9
            ELSE IF( IU.LT.MIN( N, IL ) .OR. IU.GT.N ) THEN
               INFO = -10
            END IF
         END IF
      END IF
      IF( INFO.EQ.0 ) THEN
         IF( LDZ.LT.1 .OR. ( WANTZ .AND. LDZ.LT.N ) ) THEN
            INFO = -15
         ELSE IF( LWORK.LT.MAX( 1, 8*N ) .AND. .NOT.LQUERY ) THEN
            INFO = -17
         END IF
      END IF
*
      IF( INFO.EQ.0 ) THEN
         NB = ILAENV( 1, 'DSYTRD', UPLO, N, -1, -1, -1 )
         NB = MAX( NB, ILAENV( 1, 'DORMTR', UPLO, N, -1, -1, -1 ) )
         LWKOPT = ( NB+3 )*N
         WORK( 1 ) = LWKOPT
      END IF
*
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DSYEVX', -INFO )
         RETURN
      ELSE IF( LQUERY ) THEN
         RETURN
      END IF
*
*     QUICK RETURN IF POSSIBLE
*
      M = 0
      IF( N.EQ.0 ) THEN
         WORK( 1 ) = 1
         RETURN
      END IF
*
      IF( N.EQ.1 ) THEN
         WORK( 1 ) = 7
         IF( ALLEIG .OR. INDEIG ) THEN
            M = 1
            W( 1 ) = A( 1, 1 )
         ELSE
            IF( VL.LT.A( 1, 1 ) .AND. VU.GE.A( 1, 1 ) ) THEN
               M = 1
               W( 1 ) = A( 1, 1 )
            END IF
         END IF
         IF( WANTZ )
     $      Z( 1, 1 ) = ONE
         RETURN
      END IF
*
*     GET MACHINE CONSTANTS.
*
      SAFMIN = DLAMCH( 'SAFE MINIMUM' )
      EPS = DLAMCH( 'PRECISION' )
      SMLNUM = SAFMIN / EPS
      BIGNUM = ONE / SMLNUM
      RMIN = SQRT( SMLNUM )
      RMAX = MIN( SQRT( BIGNUM ), ONE / SQRT( SQRT( SAFMIN ) ) )
*
*     SCALE MATRIX TO ALLOWABLE RANGE, IF NECESSARY.
*
      ISCALE = 0
      ABSTLL = ABSTOL
      VLL = VL
      VUU = VU
      ANRM = DLANSY( 'M', UPLO, N, A, LDA, WORK )
      IF( ANRM.GT.ZERO .AND. ANRM.LT.RMIN ) THEN
         ISCALE = 1
         SIGMA = RMIN / ANRM
      ELSE IF( ANRM.GT.RMAX ) THEN
         ISCALE = 1
         SIGMA = RMAX / ANRM
      END IF
      IF( ISCALE.EQ.1 ) THEN
         IF( LOWER ) THEN
            DO 10 J = 1, N
               CALL DSCAL( N-J+1, SIGMA, A( J, J ), 1 )
   10       CONTINUE
         ELSE
            DO 20 J = 1, N
               CALL DSCAL( J, SIGMA, A( 1, J ), 1 )
   20       CONTINUE
         END IF
         IF( ABSTOL.GT.0 )
     $      ABSTLL = ABSTOL*SIGMA
         IF( VALEIG ) THEN
            VLL = VL*SIGMA
            VUU = VU*SIGMA
         END IF
      END IF
*
*     CALL DSYTRD TO REDUCE SYMMETRIC MATRIX TO TRIDIAGONAL FORM.
*
      INDTAU = 1
      INDE = INDTAU + N
      INDD = INDE + N
      INDWRK = INDD + N
      LLWORK = LWORK - INDWRK + 1
      CALL DSYTRD( UPLO, N, A, LDA, WORK( INDD ), WORK( INDE ),
     $             WORK( INDTAU ), WORK( INDWRK ), LLWORK, IINFO )
      LOPT = 3*N + WORK( INDWRK )
*
*     IF ALL EIGENVALUES ARE DESIRED AND ABSTOL IS LESS THAN OR EQUAL TO
*     ZERO, THEN CALL DSTERF OR DORGTR AND SSTEQR.  IF THIS FAILS FOR
*     SOME EIGENVALUE, THEN TRY DSTEBZ.
*
      IF( ( ALLEIG .OR. ( INDEIG .AND. IL.EQ.1 .AND. IU.EQ.N ) ) .AND.
     $    ( ABSTOL.LE.ZERO ) ) THEN
         CALL DCOPY( N, WORK( INDD ), 1, W, 1 )
         INDEE = INDWRK + 2*N
         IF( .NOT.WANTZ ) THEN
            CALL DCOPY( N-1, WORK( INDE ), 1, WORK( INDEE ), 1 )
            CALL DSTERF( N, W, WORK( INDEE ), INFO )
         ELSE
            CALL DLACPY( 'A', N, N, A, LDA, Z, LDZ )
            CALL DORGTR( UPLO, N, Z, LDZ, WORK( INDTAU ),
     $                   WORK( INDWRK ), LLWORK, IINFO )
            CALL DCOPY( N-1, WORK( INDE ), 1, WORK( INDEE ), 1 )
            CALL DSTEQR( JOBZ, N, W, WORK( INDEE ), Z, LDZ,
     $                   WORK( INDWRK ), INFO )
            IF( INFO.EQ.0 ) THEN
               DO 30 I = 1, N
                  IFAIL( I ) = 0
   30          CONTINUE
            END IF
         END IF
         IF( INFO.EQ.0 ) THEN
            M = N
            GO TO 40
         END IF
         INFO = 0
      END IF
*
*     OTHERWISE, CALL DSTEBZ AND, IF EIGENVECTORS ARE DESIRED, SSTEIN.
*
      IF( WANTZ ) THEN
         ORDER = 'B'
      ELSE
         ORDER = 'E'
      END IF
      INDIBL = 1
      INDISP = INDIBL + N
      INDIWO = INDISP + N
      CALL DSTEBZ( RANGE, ORDER, N, VLL, VUU, IL, IU, ABSTLL,
     $             WORK( INDD ), WORK( INDE ), M, NSPLIT, W,
     $             IWORK( INDIBL ), IWORK( INDISP ), WORK( INDWRK ),
     $             IWORK( INDIWO ), INFO )
*
      IF( WANTZ ) THEN
         CALL DSTEIN( N, WORK( INDD ), WORK( INDE ), M, W,
     $                IWORK( INDIBL ), IWORK( INDISP ), Z, LDZ,
     $                WORK( INDWRK ), IWORK( INDIWO ), IFAIL, INFO )
*
*        APPLY ORTHOGONAL MATRIX USED IN REDUCTION TO TRIDIAGONAL
*        FORM TO EIGENVECTORS RETURNED BY DSTEIN.
*
         INDWKN = INDE
         LLWRKN = LWORK - INDWKN + 1
         CALL DORMTR( 'L', UPLO, 'N', N, M, A, LDA, WORK( INDTAU ), Z,
     $                LDZ, WORK( INDWKN ), LLWRKN, IINFO )
      END IF
*
*     IF MATRIX WAS SCALED, THEN RESCALE EIGENVALUES APPROPRIATELY.
*
   40 CONTINUE
      IF( ISCALE.EQ.1 ) THEN
         IF( INFO.EQ.0 ) THEN
            IMAX = M
         ELSE
            IMAX = INFO - 1
         END IF
         CALL DSCAL( IMAX, ONE / SIGMA, W, 1 )
      END IF
*
*     IF EIGENVALUES ARE NOT IN ORDER, THEN SORT THEM, ALONG WITH
*     EIGENVECTORS.
*
      IF( WANTZ ) THEN
         DO 60 J = 1, M - 1
            I = 0
            TMP1 = W( J )
            DO 50 JJ = J + 1, M
               IF( W( JJ ).LT.TMP1 ) THEN
                  I = JJ
                  TMP1 = W( JJ )
               END IF
   50       CONTINUE
*
            IF( I.NE.0 ) THEN
               ITMP1 = IWORK( INDIBL+I-1 )
               W( I ) = W( J )
               IWORK( INDIBL+I-1 ) = IWORK( INDIBL+J-1 )
               W( J ) = TMP1
               IWORK( INDIBL+J-1 ) = ITMP1
               CALL DSWAP( N, Z( 1, I ), 1, Z( 1, J ), 1 )
               IF( INFO.NE.0 ) THEN
                  ITMP1 = IFAIL( I )
                  IFAIL( I ) = IFAIL( J )
                  IFAIL( J ) = ITMP1
               END IF
            END IF
   60    CONTINUE
      END IF
*
*     SET WORK(1) TO OPTIMAL WORKSPACE SIZE.
*
      WORK( 1 ) = LWKOPT
*
      RETURN
*
*     END OF DSYEVX
*
      END
      SUBROUTINE DLACPY( UPLO, M, N, A, LDA, B, LDB )
*
*  -- LAPACK AUXILIARY ROUTINE (VERSION 3.0) --
*     UNIV. OF TENNESSEE, UNIV. OF CALIFORNIA BERKELEY, NAG LTD.,
*     COURANT INSTITUTE, ARGONNE NATIONAL LAB, AND RICE UNIVERSITY
*     FEBRUARY 29, 1992
*
*     .. SCALAR ARGUMENTS ..
      CHARACTER          UPLO
      INTEGER            LDA, LDB, M, N
*     ..
*     .. ARRAY ARGUMENTS ..
      DOUBLE PRECISION   A( LDA, * ), B( LDB, * )
*     ..
*
*  PURPOSE
*  =======
*
*  DLACPY COPIES ALL OR PART OF A TWO-DIMENSIONAL MATRIX A TO ANOTHER
*  MATRIX B.
*
*  ARGUMENTS
*  =========
*
*  UPLO    (INPUT) CHARACTER*1
*          SPECIFIES THE PART OF THE MATRIX A TO BE COPIED TO B.
*          = 'U':      UPPER TRIANGULAR PART
*          = 'L':      LOWER TRIANGULAR PART
*          OTHERWISE:  ALL OF THE MATRIX A
*
*  M       (INPUT) INTEGER
*          THE NUMBER OF ROWS OF THE MATRIX A.  M >= 0.
*
*  N       (INPUT) INTEGER
*          THE NUMBER OF COLUMNS OF THE MATRIX A.  N >= 0.
*
*  A       (INPUT) DOUBLE PRECISION ARRAY, DIMENSION (LDA,N)
*          THE M BY N MATRIX A.  IF UPLO = 'U', ONLY THE UPPER TRIANGLE
*          OR TRAPEZOID IS ACCESSED; IF UPLO = 'L', ONLY THE LOWER
*          TRIANGLE OR TRAPEZOID IS ACCESSED.
*
*  LDA     (INPUT) INTEGER
*          THE LEADING DIMENSION OF THE ARRAY A.  LDA >= MAX(1,M).
*
*  B       (OUTPUT) DOUBLE PRECISION ARRAY, DIMENSION (LDB,N)
*          ON EXIT, B = A IN THE LOCATIONS SPECIFIED BY UPLO.
*
*  LDB     (INPUT) INTEGER
*          THE LEADING DIMENSION OF THE ARRAY B.  LDB >= MAX(1,M).
*
*  =====================================================================
*
*     .. LOCAL SCALARS ..
      INTEGER            I, J
*     ..
*     .. EXTERNAL FUNCTIONS ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     ..
*     .. INTRINSIC FUNCTIONS ..
      INTRINSIC          MIN
*     ..
*     .. EXECUTABLE STATEMENTS ..
*
      IF( LSAME( UPLO, 'U' ) ) THEN
         DO 20 J = 1, N
            DO 10 I = 1, MIN( J, M )
               B( I, J ) = A( I, J )
   10       CONTINUE
   20    CONTINUE
      ELSE IF( LSAME( UPLO, 'L' ) ) THEN
         DO 40 J = 1, N
            DO 30 I = J, M
               B( I, J ) = A( I, J )
   30       CONTINUE
   40    CONTINUE
      ELSE
         DO 60 J = 1, N
            DO 50 I = 1, M
               B( I, J ) = A( I, J )
   50       CONTINUE
   60    CONTINUE
      END IF
      RETURN
*
*     END OF DLACPY
*
      END
