C   OPTIM: A PROGRAM FOR OPTIMIZING GEOMETRIES AND CALCULATING REACTION PATHWAYS
C   COPYRIGHT (C) 1999-2006 DAVID J. WALES
C   THIS FILE IS PART OF OPTIM.
C
C   OPTIM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C   IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C   THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C   (AT YOUR OPTION) ANY LATER VERSION.
C
C   OPTIM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
C   BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
C   GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C   YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C   ALONG WITH THIS PROGRAM; IF NOT, WRITE TO THE FREE SOFTWARE
C   FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330, BOSTON, MA  02111-1307  USA
C
C ROUTINE TO ASSESS SIMILARITY BETWEEN INTERNAL COORDINATES FOR PASSED CARTESIAN ARRAY QLOCAL
C AND A STORED REFERENCE ARRAY (FIN) BASED ON SOME ANGLE TOLERANCE (SEE BELOW)
C
      SUBROUTINE UNRESCALCDIHESEC(DIHE,ALLANG,QLOCAL,ORDERSTOP)
      USE COMMONS
      USE KEY, ONLY: DEBUG
      USE MODUNRES
      IMPLICIT NONE

C     REAL*8 REFCOORD(3*NATOMS),REFPPSANGLE(3*NATOMS) NOW IN MODUNRES.F90
C     COMMON /CHREF/ REFCOORD,REFPPSANGLE

C     LOGICAL CONSECT ALL NOW IN MODUNRES.F90
C     INTEGER STARTRES(10),ENDRES(10),NUMSEC
C     COMMON /CONNECTSECTION/ CONSECT,STARTRES,ENDRES,NUMSEC, DIHETOL, POLARTOL
C
      DOUBLE PRECISION DIHETOL, POLARTOL
      INTEGER I1,J1
      REAL*8 DIFFPP,DIHE, SUMD2,ALLDIFFPP, ALLANG, ALLSUMD2
      REAL*8 QPPSANGLE(4*NRES-9),QLOCAL(3*NATOMS)
      LOGICAL ORDERSTOP
      DOUBLE PRECISION PI
      PARAMETER (PI=3.141592653589793D0)

      PRINT *,'UNRESCALCDIHESEC HERE'

      DIHETOL=0.25D0 ! 14.32 DEGREES
      POLARTOL=0.2D0 ! 11.45 DEGREES

      DO I1=1,NRES
         C(1,I1)=QLOCAL(6*(I1-1)+1)
         C(2,I1)=QLOCAL(6*(I1-1)+2)
         C(3,I1)=QLOCAL(6*(I1-1)+3)
         C(1,I1+NRES)=QLOCAL(6*(I1-1)+4)
         C(2,I1+NRES)=QLOCAL(6*(I1-1)+5)
         C(3,I1+NRES)=QLOCAL(6*(I1-1)+6)
      END DO
      CALL UPDATEDC
!CALL INT_FROM_CART(.TRUE.,.FALSE.)

C USE UNRES GEOMETRY ARRAYS PHI (BB DIHEDRALS) AND OMEG (SC DIHEDRALS)
C TAKE CARE WITH NUMBERING - SEE /UNRES/SRC/READPDB.F (SUBROUTINE INT_FROM_CART)
C FOR SIDE CHAIN DIHEDRALS, HAVE ZERO ELEMENTS FOR PROPER (I.E. NOT CAPPING) GLYCINES.
C NEED TO REMEMBER NOT TO TRY TO TWIST THEM THOUGH!
C NO ENTRIES IN QPPSANGLE FOR CAPPING 'RESIDUES'.
      DO I1=1,NRES-3
        QPPSANGLE(I1)=PHI(I1+3)
      END DO
      DO I1=1,NRES-2
        QPPSANGLE(I1+NRES-3)=OMEG(I1+1)
C JMC 30/4/03 TRY ADDING BACKBONE AND SIDE CHAIN POLAR ANGLES
C THIS SHOULD BE MORE IMPORTANT FOR UNRES THAN FOR CHARMM...
C ORDER IS BB DIHEDRALS, SC DIHEDRALS, BB POLARS, SC POLARS.
        QPPSANGLE(I1+2*NRES-5)=THETA(I1+2)
        QPPSANGLE(I1+3*NRES-7)=ALPH(I1+1)
      END DO
C
      DO J1=1,NUMSEC
         PRINT *,'NUMSEC ',J1
         SUMD2=0.D0
C BACKBONE DIHEDRALS
         DO I1=STARTRES(J1)-2,ENDRES(J1)-1
            DIFFPP = QPPSANGLE(I1) - UREFPPSANGLE(I1)
            IF (DIFFPP.LT.-PI) DIFFPP = DIFFPP+2.0D0*PI
            IF (DIFFPP.GT.PI) DIFFPP = DIFFPP-2.0D0*PI
            SUMD2=SUMD2+DIFFPP*DIFFPP
            IF (ABS(DIFFPP).GT.DIHETOL) THEN
               ORDERSTOP=.FALSE.
               RETURN
            END IF
C           PRINT *,'BB DIHE ',I1
         ENDDO
C SIDE CHAIN DIHEDRALS
         DO I1=NPHI+STARTRES(J1)-1,NPHI+ENDRES(J1)-1
            DIFFPP = QPPSANGLE(I1) - UREFPPSANGLE(I1)
            IF (DIFFPP.LT.-PI) DIFFPP = DIFFPP+2.0D0*PI
            IF (DIFFPP.GT.PI) DIFFPP = DIFFPP-2.0D0*PI
            SUMD2=SUMD2+DIFFPP*DIFFPP
            IF (ABS(DIFFPP).GT.DIHETOL) THEN
               ORDERSTOP=.FALSE.
               RETURN
            END IF
C           PRINT *,'SC DIHE ',I1
         ENDDO
C BACKBONE POLARS
         DO I1=NPHI+NRES-2+STARTRES(J1)-1,NPHI+NRES-2+ENDRES(J1)-1
            DIFFPP = QPPSANGLE(I1) - UREFPPSANGLE(I1)
            SUMD2=SUMD2+DIFFPP*DIFFPP
            IF (ABS(DIFFPP).GT.POLARTOL) THEN
               ORDERSTOP=.FALSE.
               RETURN
            END IF
C           PRINT *,'BB POLAR ',I1
         ENDDO
C SIDE CHAIN POLARS
         DO I1=NPHI+NTHETA+NRES-2+STARTRES(J1)-1,NPHI+NTHETA+NRES-2+ENDRES(J1)-1
            DIFFPP = QPPSANGLE(I1) - UREFPPSANGLE(I1)
            SUMD2=SUMD2+DIFFPP*DIFFPP
            IF (ABS(DIFFPP).GT.POLARTOL) THEN
               ORDERSTOP=.FALSE.
               RETURN
            END IF
C           PRINT *,'SC POLAR ',I1
         ENDDO
      END DO
 
C JMC REMEMBER IF SUMD IS IN RADIANS, THEN DIHE WILL HAVE DIFFERENT
C RANGE OF VALUES FOR CHARMM VS UNRES...
      ALLANG=DSQRT(SUMD2/(NPHI+NTHETA+2.0D0*NSIDE))
      PRINT *,'ALLANG ',ALLANG

      RETURN

      END

C
C ROUTINE TO GUESS TRANSITION STATES FOR UNRES 
C BY INTERPOLATING BETWEEN DIFFERENT INTERNAL COORDINATES 
C OVER SECTIONS OF THE MOLECULE DEFINED BY RESIDUE NUMBERS VIA ODATA FILE.
C NOT SURPRISINGLY, WORKS WELL FOR SOME REARRANGEMENTS BUT NOT FOR OTHERS! 
C DESIGNED TO REPLACE NEB ROUTINE (WHICH IS CALLED FROM CONNECT).
C
      SUBROUTINE UNRESGUESSTSSEC(Q,ITEST,PTEST,TWISTTYPE,TWISTFRAC,GUESSFAIL,DISTPF)
      USE COMMONS
      USE KEY
      USE MODTWOEND
      USE MODUNRES
      IMPLICIT NONE
C
      DOUBLE PRECISION ANGLE,TWISTFRAC,Q(3*NATOMS)
      REAL*8 DIFFPP,SAVEDIFFPP,MAXDIFF2, DUMMYA, RAND, SUMDIFF, DPRAND
C JMC CHANGED DIMENSION OF THE FOLLOWING THREE ARRAYS... WAS MXATMS.
      REAL*8 FINPPSANGLE(4*NRES-9),QPPSANGLE(4*NRES-9),DIFFARRAY(4*NRES-9),DISTPF
      INTEGER IMIN1,IMIN2,IICD,TWISTMODE,TWISTTYPE,NM,NWRONG
      LOGICAL LINTCOOR,PTEST,ITEST,RANDOM,NORANDOM,GUESSFAIL
      CHARACTER(LEN=18) GUESSFNAME

      DOUBLE PRECISION PI
      PARAMETER (PI=3.141592653589793D0)
      INTEGER NANGLE,I1,J1
      DOUBLE PRECISION ENERGY,RMS,GRAD(3*NATOMS)
      INTEGER NWRONGPOL,TWISTMODEPOL,SAVEDIFFPPPOL

      IF (TWISTTYPE.NE.10) THEN
         PRINT *,'CONSEC CAN ONLY BE USED WITH TWISTTYPE 10 AT PRESENT.'
         PRINT *,'TWISTTYPE IS INPUT AS ',TWISTTYPE,'; PLEASE CHANGE IT AND START AGAIN!'
         STOP
      END IF

      IF (FILTH.EQ.0) THEN
         GUESSFNAME='UNGUESSTS.XYZ'
      ELSE
         WRITE(GUESSFNAME,'(A)') 'UNGUESSTS.XYZ.'//TRIM(ADJUSTL(FILTHSTR))
      ENDIF

C     OPEN(78,FILE='CHGUESSTS.XYZ',STATUS='UNKNOWN')
      OPEN(78,FILE=GUESSFNAME,STATUS='UNKNOWN')

      CALL UNRESDUMP2(Q,78)

      DIFFARRAY=0.0D0 ! JMC INITIALISING

      DO I1=1,NRES
         C(1,I1)=FIN(6*(I1-1)+1)
         C(2,I1)=FIN(6*(I1-1)+2)
         C(3,I1)=FIN(6*(I1-1)+3)
         C(1,I1+NRES)=FIN(6*(I1-1)+4)
         C(2,I1+NRES)=FIN(6*(I1-1)+5)
         C(3,I1+NRES)=FIN(6*(I1-1)+6)
      END DO
      CALL UPDATEDC
!CALL INT_FROM_CART(.TRUE.,.FALSE.)

      DO I1=1,NRES-3
        FINPPSANGLE(I1)=PHI(I1+3)
      END DO
      DO I1=1,NRES-2
        FINPPSANGLE(I1+NRES-3)=OMEG(I1+1)
C JMC 30/4/03 TRY ADDING BACKBONE AND SIDE CHAIN POLAR ANGLES TO THE INTERPOLATION PROCEDURE...
C THIS SHOULD BE MORE IMPORTANT FOR UNRES THAN FOR CHARMM...
C ORDER IS BB DIHEDRALS, SC DIHEDRALS, BB POLARS, SC POLARS.
        FINPPSANGLE(I1+2*NRES-5)=THETA(I1+2)
        FINPPSANGLE(I1+3*NRES-7)=ALPH(I1+1)
      END DO

      DO I1=1,NRES
         C(1,I1)=Q(6*(I1-1)+1)
         C(2,I1)=Q(6*(I1-1)+2)
         C(3,I1)=Q(6*(I1-1)+3)
         C(1,I1+NRES)=Q(6*(I1-1)+4)
         C(2,I1+NRES)=Q(6*(I1-1)+5)
         C(3,I1+NRES)=Q(6*(I1-1)+6)
      END DO
      CALL UPDATEDC
!CALL INT_FROM_CART(.TRUE.,.FALSE.)

C USE UNRES GEOMETRY ARRAYS PHI (BB DIHEDRALS) AND OMEG (SC DIHEDRALS)
C NOTE THAT ANGLES ARE IN RADIANS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
C TAKE CARE WITH NUMBERING - SEE /UNRES/SRC/READPDB.F (SUBROUTINE INT_FROM_CART)
C FOR SIDE CHAIN DIHEDRALS, THE ACTUAL STORED ARRAYS (ALPHA AND OMEG) CONTAIN ZERO ELEMENTS FOR
C PROPER (I.E. NOT CAPPING) GLYCINES BUT THE VARIABLE ARRAY FROM A CALL TO GEOM_TO_VAR DOES NOT
C CONTAIN THESE ELEMENTS.
C NEED TO REMEMBER NOT TO TRY TO TWIST THEM THOUGH!
C NO ENTRIES IN QPPSANGLE FOR CAPPING 'RESIDUES'.
      DO I1=1,NRES-3
        QPPSANGLE(I1)=PHI(I1+3)
      END DO
      DO I1=1,NRES-2
        QPPSANGLE(I1+NRES-3)=OMEG(I1+1)
        QPPSANGLE(I1+2*NRES-5)=THETA(I1+2)
        QPPSANGLE(I1+3*NRES-7)=ALPH(I1+1)
      END DO
C JMC NOTE THAT THE Q INTERNAL COORD SET IS NOW SAVED IN THE UNRES INT COOR COMMON BLOCK...
C PUT THE TS GUESS COORDS INTO COMMON BLOCK BEFORE EXITING THIS SUBROUTINE.

C NOW DECIDE WHICH PHI/PSI OR SIDECHAIN ANGLE TO TWIST
C
C BASED ON TWISTTYPE
C TWISTTYPE = 1  MEANS TAKE ONE WITH BIGGEST DIFFERENCE AND INTERPOLATE BETWEEN
C      THE TWO VALUES USING TWISTFRAC AS THE FRACTION

C TWISTTYPE = 2; INTERPOLATES LIKE 1 BUT SETS CHOSEN ANGLE TO THE NEAREST OF -120, 0, 120 DEGREES
C I.E. MAXIMA OF THE DIHEDRAL POTENTIAL (WHICH IS K(1+COS(3*PHI)) FOR PHI AND PSI ANGLES. ! CHARMM
C IN FACT K = 0 FOR PSI, SO THIS METHOD MAY BE A BIT FUTILE FOR PSI ANGLES, BUT IT MAY GIVE SENSIBLE ! CHARMM
C GEOMETRIES ANYWAY) ! CHARMM
C
C TWISTTYPE =3; LIKE 1, BUT ALSO INTERPOLATES THE DIHEDRAL EITHER SIDE OF THE MAXIMUM
C
C TWISTTYPE =4; DOES ON ONE DIHEDRAL, CHOSEN WITH PROBABILITY BASED ON SIZE OF DISPLACEMENT
C
C TWISTTYPE =5; IF ONLY ONE DIHEDRAL DIFFERS BY >60DEG THEN INTERPOLATES ON ONE DIHEDRAL,
C               IF MORE THAN ONES DIFFERS THEN PROCEEDS LIKE RANDOM MODE (TWISTTYPE =4)
C
C TWISTTYPE =6; IF ONLY ONE DIHEDRAL DIFFERS BY >60DEG THEN INTERPOLATES THAT DIHEDRAL,
C               AND THE DIHEDRALS EITHER SIDE (LIKE TT=3)
C               IF MORE THAN ONES DIFFERS THEN PROCEEDS LIKE RANDOM MODE (TWISTTYPE =4)
C
C TWISTTYPE =7; JUST INTERPOLATE ALL DIHEDRALS
C JMC
C TWISTTYPE =8; INTERPOLATE ALL BACKBONE ANGLES
C TWISTTYPE =9; INTERPOLATE LARGEST DIHEDRAL AND LARGEST POLAR ANGLE
C TWISTTYPE =10; JUST INTERPOLATE ALL ANGLES
C
      RANDOM=.FALSE.
      MAXDIFF2 = 0.0D0
      NWRONG=0
      NWRONGPOL=0

C
C TURN RANDOM DISPLACEMENTS OFF ONCE TWO MINIMA ARE CLOSE ENOUGH TOGETHER FOR NEB
C TO BE SUCCESSFUL
C
C     IF (DISTPF.LT.RANDOMCUTOFF) THEN
C        NORANDOM=.TRUE.
C     ELSE
         NORANDOM=.FALSE.
C     ENDIF

      DO I1=1,NPHI+NRES-2
         IF (I1.GT.NPHI) THEN
            IF (ITYPE(I1-NPHI+1).EQ.10) GOTO 100 ! GLYCINE
         END IF
C        WRITE(*,'(A,I6,2F15.10)') 'FINS QS',I1,FINPPSANGLE(I1),QPPSANGLE(I1)
         DIFFPP = FINPPSANGLE(I1) - QPPSANGLE(I1)
C
C NEXT TWO LINES ARE MEANT TO ENSURE THAT YOU ALWAYS INTERPOLATE
C ALONG THE SHORTEST DISTANCE BETWEEN THE DIHEDRAL ANGLES.
C
         IF (DIFFPP.GT.PI) DIFFPP = DIFFPP-2.0D0*PI
         IF (DIFFPP.LT.-PI) DIFFPP = DIFFPP+2.0D0*PI

         DIFFARRAY(I1)=DIFFPP

         IF ((DIFFPP*DIFFPP).GT.MAXDIFF2) THEN
            MAXDIFF2=DIFFPP*DIFFPP
            TWISTMODE=I1
            SAVEDIFFPP=DIFFPP
         ENDIF

C JMC         IF (ABS(DIFFPP).GT.60.0D0) NWRONG=NWRONG+1
         IF (ABS(DIFFPP).GT.PI/3.0D0) NWRONG=NWRONG+1

100   CONTINUE 
      ENDDO

C JMC DON'T DUPLICATE WORK FROM ABOVE DO LOOP...
C REMEMBER THE POLAR ANGLES RUN FROM 0 TO PI, WHEREAS DIHEDRALS GO FROM -PI TO PI.
      DO I1=NPHI+NRES-1,NPHI+NTHETA+2*NRES-4
         IF (I1.GT.NPHI+NRES-2+NTHETA) THEN
            IF (ITYPE(I1-NPHI-NRES+2-NTHETA+1).EQ.10) GOTO 200 ! GLYCINE
         END IF
C        WRITE(*,'(A,I6,2F15.10)') 'FINS QS',I1,FINPPSANGLE(I1),QPPSANGLE(I1)
         DIFFPP = FINPPSANGLE(I1) - QPPSANGLE(I1)
         DIFFARRAY(I1)=DIFFPP
         IF ((DIFFPP*DIFFPP).GT.MAXDIFF2) THEN
            MAXDIFF2=DIFFPP*DIFFPP
            TWISTMODEPOL=I1
            SAVEDIFFPPPOL=DIFFPP
         ENDIF

C JMC         IF (ABS(DIFFPP).GT.60.0D0) NWRONG=NWRONG+1
         IF (ABS(DIFFPP).GT.PI/3.0D0) NWRONGPOL=NWRONGPOL+1

200   CONTINUE
      ENDDO

C
C NOW DO TWISTING 

      IF (TWISTTYPE.EQ.7) THEN
         DO I1=1,NPHI
            ANGLE=TWISTFRAC*DIFFARRAY(I1)
C JMC            IF (TWISTFRAC.LT.0.D0) ANGLE = 0.5D0*(2.0D0*PI-DIFFARRAY(I1))
            IF (TWISTFRAC.LT.0.D0) THEN
               ANGLE = 0.5D0*(2.0D0*PI-ABS(DIFFARRAY(I1))) ! SO ANGLE WILL ALWAYS BE BETWEEN PI/2 AND PI (ALWAYS > 0)
               IF (DIFFARRAY(I1).GT.0.0D0) ANGLE = -ANGLE ! JMC NEED TO TEST THIS!! OR DO WE NEED -1.0D0*ANGLE??
            ENDIF
            PHI(I1+3)=PHI(I1+3)+ANGLE
         ENDDO
         DO I1=NPHI+1,NPHI+NRES-2
            ANGLE=TWISTFRAC*DIFFARRAY(I1)
C JMC            IF (TWISTFRAC.LT.0.D0) ANGLE = 0.5D0*(2.0D0*PI-DIFFARRAY(I1))
            IF (TWISTFRAC.LT.0.D0) THEN
               ANGLE = 0.5D0*(2.0D0*PI-ABS(DIFFARRAY(I1))) ! SO ANGLE WILL ALWAYS BE BETWEEN PI/2 AND PI (ALWAYS > 0)
               IF (DIFFARRAY(I1).GT.0.0D0) ANGLE = -ANGLE ! JMC NEED TO TEST THIS!! OR DO WE NEED -1.0D0*ANGLE??
            ENDIF
            OMEG(I1+1-NPHI)=OMEG(I1+1-NPHI)+ANGLE
         ENDDO
         GOTO 20
      ENDIF

      IF (TWISTTYPE.EQ.10) THEN
C JMC NEW CONNECT SECTION STUFF ONLY WORKS WITH TT10 AT PRESENT.
         DO J1=1,NUMSEC
            PRINT *,'CHGUESSTS3 NUMSEC ',J1
            DO I1=STARTRES(J1)-2,ENDRES(J1)-1
               ANGLE=TWISTFRAC*DIFFARRAY(I1)
C JMC               IF (TWISTFRAC.LT.0.D0) ANGLE = 0.5D0*(2.0D0*PI-DIFFARRAY(I1))
               IF (TWISTFRAC.LT.0.D0) THEN
                  ANGLE = 0.5D0*(2.0D0*PI-ABS(DIFFARRAY(I1))) ! SO ANGLE WILL ALWAYS BE BETWEEN PI/2 AND PI (ALWAYS > 0)
                  IF (DIFFARRAY(I1).GT.0.0D0) ANGLE = -ANGLE ! JMC NEED TO TEST THIS!! OR DO WE NEED -1.0D0*ANGLE??
               ENDIF
               PHI(I1+3)=PHI(I1+3)+ANGLE
C              PRINT *,'BB DIHEDRALS ',I1
            ENDDO
            DO I1=NPHI+STARTRES(J1)-1,NPHI+ENDRES(J1)-1
               ANGLE=TWISTFRAC*DIFFARRAY(I1)
C JMC               IF (TWISTFRAC.LT.0.D0) ANGLE = 0.5D0*(2.0D0*PI-DIFFARRAY(I1))
               IF (TWISTFRAC.LT.0.D0) THEN
                  ANGLE = 0.5D0*(2.0D0*PI-ABS(DIFFARRAY(I1))) ! SO ANGLE WILL ALWAYS BE BETWEEN PI/2 AND PI (ALWAYS > 0)
                  IF (DIFFARRAY(I1).GT.0.0D0) ANGLE = -ANGLE ! JMC NEED TO TEST THIS!! OR DO WE NEED -1.0D0*ANGLE??
               ENDIF
               OMEG(I1+1-NPHI)=OMEG(I1+1-NPHI)+ANGLE
C              PRINT *,'SC DIHEDRALS ',I1
            ENDDO
            DO I1=NPHI+NRES-2+STARTRES(J1)-1,NPHI+NRES-2+ENDRES(J1)-1
               ANGLE=TWISTFRAC*DIFFARRAY(I1)
C JMC               IF (TWISTFRAC.LT.0.D0) ANGLE = 0.5D0*(2.0D0*PI-DIFFARRAY(I1))
               IF (TWISTFRAC.LT.0.D0) ANGLE = 0.5D0*DIFFARRAY(I1) ! 'GOING THE LONG WAY ROUND' DOESN'T APPLY FOR BOND ANGLES
               THETA(I1-NPHI-NRES+4)=THETA(I1-NPHI-NRES+4)+ANGLE
C              PRINT *,'BB POLARS ',I1
            ENDDO
            DO I1=NPHI+NTHETA+NRES-2+STARTRES(J1)-1,NPHI+NTHETA+NRES-2+ENDRES(J1)-1
               ANGLE=TWISTFRAC*DIFFARRAY(I1)
               IF (TWISTFRAC.LT.0.D0) ANGLE = 0.5D0*DIFFARRAY(I1) ! 'GOING THE LONG WAY ROUND' DOESN'T APPLY FOR BOND ANGLES
               ALPH(I1-NPHI-NTHETA-NRES+3)=ALPH(I1-NPHI-NTHETA-NRES+3)+ANGLE
C              PRINT *,'SC POLARS ',I1
            ENDDO
         END DO
         GOTO 20
      ENDIF

      IF (TWISTTYPE.EQ.8) THEN
C JMC BACKBONE ANGLES ONLY
         DO I1=1,NPHI
            ANGLE=TWISTFRAC*DIFFARRAY(I1)
C JMC            IF (TWISTFRAC.LT.0.D0) ANGLE = 0.5D0*(2.0D0*PI-DIFFARRAY(I1))
            IF (TWISTFRAC.LT.0.D0) THEN
               ANGLE = 0.5D0*(2.0D0*PI-ABS(DIFFARRAY(I1))) ! SO ANGLE WILL ALWAYS BE BETWEEN PI/2 AND PI (ALWAYS > 0)
               IF (DIFFARRAY(I1).GT.0.0D0) ANGLE = -ANGLE ! JMC NEED TO TEST THIS!! OR DO WE NEED -1.0D0*ANGLE??
            ENDIF
            PHI(I1+3)=PHI(I1+3)+ANGLE
         ENDDO
         DO I1=NPHI+NRES-1,NPHI+NRES-2+NTHETA
            ANGLE=TWISTFRAC*DIFFARRAY(I1)
            IF (TWISTFRAC.LT.0.D0) ANGLE = 0.5D0*DIFFARRAY(I1) ! 'GOING THE LONG WAY ROUND' DOESN'T APPLY FOR BOND ANGLES
            THETA(I1-NPHI-NRES+4)=THETA(I1-NPHI-NRES+4)+ANGLE
         ENDDO
         GOTO 20
      ENDIF

      IF (TWISTTYPE.EQ.9) THEN
            ANGLE=TWISTFRAC*DIFFARRAY(TWISTMODE)
C JMC            IF (TWISTFRAC.LT.0.D0) ANGLE = 0.5D0*(2.0D0*PI-DIFFARRAY(TWISTMODE))
            IF (TWISTFRAC.LT.0.D0) THEN
               ANGLE = 0.5D0*(2.0D0*PI-ABS(DIFFARRAY(TWISTMODE))) ! SO ANGLE WILL ALWAYS BE BETWEEN PI/2 AND PI (ALWAYS > 0)
               IF (DIFFARRAY(TWISTMODE).GT.0.0D0) ANGLE = -ANGLE ! JMC NEED TO TEST THIS!! OR DO WE NEED -1.0D0*ANGLE??
            ENDIF
            PHI(TWISTMODE+3)=PHI(TWISTMODE+3)+ANGLE
            ANGLE=TWISTFRAC*DIFFARRAY(TWISTMODE+NPHI+NRES-2)
C JMC            IF (TWISTFRAC.LT.0.D0) ANGLE = 0.5D0*(2.0D0*PI-DIFFARRAY(TWISTMODE))
            IF (TWISTFRAC.LT.0.D0) ANGLE = 0.5D0*DIFFARRAY(TWISTMODE+NPHI+NRES-2) ! 'GOING THE LONG WAY ROUND' DOESN'T APPLY FOR BOND ANGLES
            THETA(TWISTMODE-NPHI-NRES+4)=THETA(TWISTMODE-NPHI-NRES+4)+ANGLE
            ANGLE=TWISTFRAC*DIFFARRAY(TWISTMODE+1+NPHI+NRES-2)
            IF (TWISTFRAC.LT.0.D0) ANGLE = 0.5D0*DIFFARRAY(TWISTMODE+1+NPHI+NRES-2) ! 'GOING THE LONG WAY ROUND' DOESN'T APPLY FOR BOND ANGLES
            THETA(TWISTMODE+1-NPHI-NRES+4)=THETA(TWISTMODE+1-NPHI-NRES+4)+ANGLE
         GOTO 20
      ENDIF

      IF ((TWISTTYPE.EQ.5).OR.(TWISTTYPE.EQ.6)) THEN
         IF (NWRONG.GT.2) THEN
C            WRITE (*,'(A)') 'MORE THAN ONE DIHEDRAL DISPLACED - UNLIKELY TO BE A DIRECT CONNECTION'
            WRITE (*,'(A)') 'MORE THAN TWO DIHEDRALS DISPLACED - UNLIKELY TO BE A DIRECT CONNECTION'
            IF (NORANDOM) THEN
               WRITE (*,'(A)') 'SWITCHING TO NEB'
               GUESSFAIL=.TRUE.
               RETURN
            ELSE
               WRITE (*,'(A)') 'CHOOSING A MODE TO TWIST AT RANDOM'
               RANDOM=.TRUE.
C              STOP
            ENDIF
         ENDIF
      ENDIF

      ANGLE=TWISTFRAC*SAVEDIFFPP
C JMC WHAT IF SAVEDIFFPP IS LT 0?
      IF (TWISTFRAC.LT.0.D0) ANGLE = 0.5D0*(2.0D0*PI-SAVEDIFFPP)
      IF (TWISTTYPE.EQ.2) THEN
         DUMMYA=QPPSANGLE(TWISTMODE)+ANGLE
C JMC         IF ((DUMMYA.GT.-180.0D0).AND.(DUMMYA.LT.-60.0D0)) DUMMYA=-120.0D0
C JMC         IF ((DUMMYA.GT.-60.0D0).AND.(DUMMYA.LT.60.0D0)) DUMMYA=0.0D0
C JMC         IF ((DUMMYA.GT.60.0D0).AND.(DUMMYA.LT.180.0D0)) DUMMYA=120.0D0
         IF ((DUMMYA.GT.-PI).AND.(DUMMYA.LT.-PI/3.0D0)) DUMMYA=-2.0D0*PI/3.0D0
         IF ((DUMMYA.GE.-PI/3.0D0).AND.(DUMMYA.LT.PI/3.0D0)) DUMMYA=0.0D0
         IF ((DUMMYA.GE.PI/3.0D0).AND.(DUMMYA.LE.PI)) DUMMYA=2.0D0*PI/3.0D0
         ANGLE=DUMMYA-QPPSANGLE(TWISTMODE)
      ENDIF
      
      IF ((TWISTTYPE.EQ.4).OR.RANDOM) THEN
         SUMDIFF=0.D0
         DO I1=1,NPHI+NRES-2
            SUMDIFF=SUMDIFF+ABS(DIFFARRAY(I1))
         ENDDO
         RAND=DPRAND()*SUMDIFF
         PRINT *,'RAND',RAND
         SUMDIFF=0.D0
         DO I1=1,NPHI+NRES-2
            SUMDIFF=SUMDIFF+ABS(DIFFARRAY(I1))
C              PRINT *,'DIFFARRAY ',DIFFARRAY(I1)
            IF (SUMDIFF.GT.RAND) THEN 
               TWISTMODE=I1
               ANGLE=TWISTFRAC*DIFFARRAY(I1)
               PRINT *,'ANGLE ',ANGLE
               IF (TWISTFRAC.LT.0.D0) ANGLE = 0.5*(2.0D0*PI-SAVEDIFFPP)
               GOTO 10
            ENDIF
         ENDDO
10      CONTINUE
C JMC HUH?
C       IF (RANDOM) THEN
C JMC           ANGLE=DPRAND()*60.D0
C          ANGLE=DPRAND()*PI/3.0D0
C          IF (DIFFARRAY(TWISTMODE).LT.0.D0) ANGLE=-1.D0*ANGLE
C       ENDIF
      ENDIF

C JMC      WRITE (*,'(A20,I3,A2,1X,F10.5,1X,A8)') 'TWISTING PHI/PSI DIHEDRAL ',TWISTMODE,' BY ',ANGLE,' DEGREES'
      WRITE (*,'(A20,I3,A2,1X,F10.5,1X,A8)') 'TWISTING PHI/PSI DIHEDRAL ',TWISTMODE,' BY ',ANGLE,' RADIANS'

      IF (TWISTMODE.LE.NPHI) THEN
         PHI(TWISTMODE+3)=PHI(TWISTMODE+3)+ANGLE
      ELSE
         OMEG(TWISTMODE+1-NPHI)=OMEG(TWISTMODE+1-NPHI)+ANGLE
      END IF

      IF ((TWISTTYPE.EQ.3).OR.((TWISTTYPE.EQ.6).AND.(.NOT.RANDOM))) THEN
         NM=TWISTMODE-1
         IF (NM.GE.1) THEN
            DIFFPP = FINPPSANGLE(NM) - QPPSANGLE(NM)
C JMC            IF (DIFFPP.GT.180.0) DIFFPP = DIFFPP-360.D0
C JMC            IF (DIFFPP.GT.180.0) DIFFPP = DIFFPP-360.D0
            IF (DIFFPP.LT.-PI) DIFFPP = DIFFPP+2.0D0*PI
            IF (DIFFPP.GT.PI) DIFFPP = DIFFPP-2.0D0*PI
            ANGLE=TWISTFRAC*DIFFPP
            IF (TWISTFRAC.LT.0.D0) ANGLE = 0.5D0*(2.0D0*PI-SAVEDIFFPP)
C JMC            IICD=PHIPSI(NM)
C JMC            CALL TWISTCH(IICD,ANGLE)
            PHI(NM+3)=PHI(NM+3)+ANGLE
         ENDIF
         NM=TWISTMODE+1
C JMC         IF (NM.LE.NPHIPSI) THEN
         IF (NM.LE.NPHI) THEN
            DIFFPP = FINPPSANGLE(NM) - QPPSANGLE(NM)
            IF (DIFFPP.GT.PI) DIFFPP = DIFFPP-2.0D0*PI
            IF (DIFFPP.LT.-PI) DIFFPP = DIFFPP+2.0D0*PI
            ANGLE=TWISTFRAC*DIFFPP
            IF (TWISTFRAC.LT.0.D0) ANGLE = 0.5D0*(2.0D0*PI-SAVEDIFFPP)
C JMC            IICD=PHIPSI(NM)
C JMC            CALL TWISTCH(IICD,ANGLE)
            PHI(NM+3)=PHI(NM+3)+ANGLE
         ENDIF
       ENDIF
C
20    CONTINUE

!CALL CHAINBUILD

      DO J1=1,NRES
         Q(6*(J1-1)+1)=C(1,J1)
         Q(6*(J1-1)+2)=C(2,J1)
         Q(6*(J1-1)+3)=C(3,J1)
         Q(6*(J1-1)+4)=C(1,J1+NRES)
         Q(6*(J1-1)+5)=C(2,J1+NRES)
         Q(6*(J1-1)+6)=C(3,J1+NRES)
      END DO

      CALL UNRESDUMP2(Q,78)
      CALL UNRESDUMP2(FIN,78)

      CLOSE(78)

      RETURN

      END

C JMC I DON'T REALLY USE THIS - HAVEN'T TESTED IT YET...
      SUBROUTINE UNRESGUESSMINSEC(Q,PTEST,TWISTTYPE,NGUESS)
      USE VARS
      USE COMMONS
      USE KEY
      USE MODTWOEND
      USE MODUNRES
      IMPLICIT NONE

      DOUBLE PRECISION Q(3*NATOMS),TWISTFRAC,DISTPF,TMPQ(3*NATOMS)
      LOGICAL PTEST,GUESSFAIL
      INTEGER TWISTTYPE,I1,NGUESS,J1,K1
      CHARACTER*5 ZSYMSAVE
      COMMON /SYS/ ZSYMSAVE
      DOUBLE PRECISION DIHEPS,ALLANGPS
      DOUBLE PRECISION Q1(3*NATOMS),Q2(3*NATOMS),Q3(3*NATOMS)

C     LOGICAL CONSECT ! NOW IN MODUNRES.F90
C     INTEGER STARTRES(10),ENDRES(10)
C     COMMON /CONNECTSECTION/ CONSECT,STARTRES,ENDRES

      CALL NEWMINDIST(Q,FIN,NATOMS,DISTPF,.FALSE.,.FALSE.,ZSYMSAVE,.FALSE.,RIGIDBODY,DEBUG,RMAT)
      CALL UNRESCALCDIHE(DIHEPS,ALLANGPS,Q,FIN)
      PRINT *,'Q, FIN DISTPF ',DISTPF
      PRINT *,'Q, FIN DIHEPS, ALLANGPS ',DIHEPS,ALLANGPS

      TMPQ=Q

      COUNTER=0
      DO I1=1,NGUESS
         TWISTFRAC=1.0D0*I1/(NGUESS+1)
         PRINT *,'TWISTFRAC ',TWISTFRAC
         CALL UNRESGUESSTSSEC(Q,.FALSE.,PTEST,TWISTTYPE,TWISTFRAC,GUESSFAIL,DISTPF)
         Q=TMPQ
         PRINT *,'GUESSFAIL ',GUESSFAIL
      END DO

C NOW DO SOME FUNKY MIND STUFF ON MYQMINSAVE...
      DO I1=1,COUNTER
         DO K1=1,3*NATOMS
            Q1(K1)=MYQMINSAVE(K1,I1)
            Q2(K1)=TMPQ(K1)
            Q3(K1)=FIN(K1)
         END DO
         CALL NEWMINDIST(Q1,Q2,NATOMS,DISTPF,.FALSE.,.FALSE.,ZSYMSAVE,.FALSE.,RIGIDBODY,DEBUG,RMAT)
         CALL UNRESCALCDIHE(DIHEPS,ALLANGPS,Q1,Q2)
         PRINT *,'DISTPF ',DISTPF,I1,' START'
         PRINT *,'DIHE,ALLANG ',DIHEPS,ALLANGPS,I1,' START'
         CALL NEWMINDIST(Q1,Q3,NATOMS,DISTPF,.FALSE.,.FALSE.,ZSYMSAVE,.FALSE.,RIGIDBODY,DEBUG,RMAT)
         CALL UNRESCALCDIHE(DIHEPS,ALLANGPS,Q1,Q3)
         PRINT *,'DISTPF ',DISTPF,I1,' FIN'
         PRINT *,'DIHE,ALLANG ',DIHEPS,ALLANGPS,I1,' FIN'
         DO J1=I1+1,COUNTER
            DO K1=1,3*NATOMS
               Q1(K1)=MYQMINSAVE(K1,I1)
               Q2(K1)=MYQMINSAVE(K1,J1)
            END DO
            CALL NEWMINDIST(Q1,Q2,NATOMS,DISTPF,.FALSE.,.FALSE.,ZSYMSAVE,.FALSE.,RIGIDBODY,DEBUG,RMAT)
            CALL UNRESCALCDIHE(DIHEPS,ALLANGPS,Q1,Q2)
            PRINT *,'DISTPF ',DISTPF,I1,J1
            PRINT *,'DIHE,ALLANG ',DIHEPS,ALLANGPS,I1,J1
         END DO
      END DO

      STOP

      END SUBROUTINE
