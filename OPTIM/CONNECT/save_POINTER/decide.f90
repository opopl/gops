!   CONNECT MODULE IS AN IMPLEMENTATION OF A CONNECTION ALGORITHM FOR FINDING REARRANGEMENT PATHWAYS.
!   COPYRIGHT (C) 2003-2006 SEMEN A. TRYGUBENKO AND DAVID J. WALES
!   THIS FILE IS PART OF CONNECT MODULE. CONNECT MODULE IS PART OF OPTIM.
!
!   OPTIM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
!   IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
!   THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
!   (AT YOUR OPTION) ANY LATER VERSION.
!
!   OPTIM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
!   BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
!   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
!   GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
!
!   YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
!   ALONG WITH THIS PROGRAM; IF NOT, WRITE TO THE FREE SOFTWARE
!   FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330, BOSTON, MA  02111-1307  USA
!
MODULE DECIDEWHATTOCONNECT
     IMPLICIT NONE

     CONTAINS

     SUBROUTINE DECIDE
          USE PORFUNCS
          USE CONNECTDATA
          USE CONNECTUTILS,ONLY: GETDISTANCE,SETDISTANCE,GETINTERP
          USE KEYDECIDE
          IMPLICIT NONE

          ! USE DIJKSTRA'S ALGORITHM TO FIND THE SHORTEST PATH BETWEEN THE ORIGINAL TWO ENDPOINTS.
          ! THE EDGE WEIGHTS ARE ZERO FOR MINIMA CONNECTED BY A SINGLE TS, INFINITY FOR PAIRS
          ! WHERE WE HAVE ALREADY TRIED THE MAXIMUM ALLOWED CONNECTIONS, AND THE MINIMUM DISTANCE FROM
          ! MIND (POSSIBLY SQUARED) OTHERWISE.
          ! DIJKSTRA SHOULD RETURN THE NUMBER OF CONNECTIONS TO TRY FROM THIS SHORTEST PATH, AND THE
          ! CORRESPONDING PAIRS OF MINIMA.
          ! IMPLEMENTATION OF DIJKSTRA'S ALGORITHM FOR FINDING SHORTEST PATHS IN AN UNCONNECTED DATABASE
          ! WEIGHTS EDGES OF GRAPH ACCORDING TO MI(I)%DATA%D(J) OR MI(I)%DATA%INTERP(J) (I>J)
          ! WEIGHT=0 IF CONNECTED BY A SINGLE TS
          ! WEIGHT=INFINITY IF THE MAXIMUM TRYCONNECT ATTEMPTS HAVE BEEN DONE FOR THIS PAIR
          ! WEIGHT=MIND(I,J) OTHERWISE
INTEGER :: I, NDUMMY, BEGIN, END, NSTEP, J
TYPE MINIMUM
   INTEGER :: PREVMIN                             ! PREVIOUS MIN/TS IN SHORTEST PATH
   DOUBLE PRECISION :: D                          ! DISTANCE FROM STARTING POINT
   LOGICAL :: PERMANENT                           ! ONCE IN PERMANENT SET, THE MINIMUM'S
                                                  ! LABEL CANNOT BE CHANGED
END TYPE MINIMUM
TYPE(MINIMUM), DIMENSION(:), ALLOCATABLE :: DIJMIN
TYPE PATHWAY
   INTEGER :: DIJMIN, DIJTS
END TYPE PATHWAY
DOUBLE PRECISION :: WEIGHT, MINWEIGHT, DUMMYDJW

! INITIALISE CONNECTIONS
   ALLOCATE(DIJMIN(NMIN))
   DIJMIN(1:NMIN)%PREVMIN=0
   DIJMIN(1:NMIN)%D=HUGE(1.0D0)
   DIJMIN(1:NMIN)%PERMANENT=.FALSE.

! START ALGORITHM AT 'BEGIN' MINIMUM

   I=1
   DIJMIN(I)%D=0.0D0
   DIJMIN(I)%PERMANENT=.TRUE.
      
   MAIN: DO
      DO J=2, NMIN    ! LOOP OVER ALL MINIMA 
         IF (DIJMIN(J)%PERMANENT) CYCLE          ! ONLY CONSIDER TEMPORARY MINIMA
         IF (GETDISTANCE(I,J)>HUGE(1.0D0)/2) THEN ! DON'T RAISE A HUGE NUMBER TO ANY POWER > 1!!
            WEIGHT=GETDISTANCE(I,J)
         ELSE
               IF (EXPCOSTFUNCTION) THEN ! SAVES MEMORY AND CPU WHEN ENDPOINT SEPARATION IS VERY LARGE SAT
                    WEIGHT=GETDISTANCE(I,J)
                    IF (WEIGHT.GT.0.0D0) WEIGHT=EXP(WEIGHT)
               ELSEIF (INTERPCOSTFUNCTION) THEN 
                    WEIGHT=GETINTERP(I,J)**COSTFUNCTIONPOWER
               ELSE ! COMPARE SQUARES TO FAVOUR MORE SMALL JUMPS OVER BIG ONES DJW
                    WEIGHT=GETDISTANCE(I,J)**COSTFUNCTIONPOWER
               ENDIF
         ENDIF

         IF ((DIJMIN(I)%D + WEIGHT) < DIJMIN(J)%D) THEN    ! UPDATE D FOR EACH CONNECTED MINIMUM
!           PRINT '(A,2I8,3G20.10)','DECIDE> I,J,DIJMIN(J)%D,DIJMIN(I)%D,WEIGHT=',I,J,DIJMIN(J)%D,DIJMIN(I)%D,WEIGHT
            DIJMIN(J)%D=DIJMIN(I)%D + WEIGHT
            DIJMIN(J)%PREVMIN=I
         ENDIF
      ENDDO
            
      MINWEIGHT=HUGE(MINWEIGHT)
      NDUMMY=I ! SAT: IF THIS IS THE FIRST CYCLE OF THE MAIN DO LOOP AND ALL MINIMA HAVE
      ! HUGE WEIGHT NDUMMY WILL NEVER BE SET WHICH IS A BIT UNFORTUNATE GIVEN
      ! THAT WE USE IT IMMEDIATELY AFTERWARDS IN THE IF TEST ...
      DO J=2,NMIN                           ! FIND TEMPORARY MINIMUM WITH LOWEST D
         IF (DIJMIN(J)%PERMANENT) CYCLE     ! ONLY CONSIDER TEMPORARY MINIMA
         IF (DIJMIN(J)%D < MINWEIGHT) THEN  ! FIND MINIMUM WEIGHT 
            MINWEIGHT=DIJMIN(J)%D
            NDUMMY=J
         ENDIF
      ENDDO

! IF NO TEMPORARY MINIMA WITH TOTAL WEIGHT LESS THAN HUGE ARE PRESENT, WE WILL NEVER EXIT THE OUTER DO LOOP!
      IF (NDUMMY==I) THEN
         WRITE(*,'(A)') ' THERE APPEAR TO BE NO CONNECTIONS LEFT TO TRY IN DIJKSTRA - QUIT'
         CALL TSUMMARY
         CALL EXIT(10)
      ENDIF

      I=NDUMMY
      DIJMIN(I)%PERMANENT=.TRUE.
      IF (I==2) EXIT   
   ENDDO MAIN

   IF (MINWEIGHT.GT.HUGE(MINWEIGHT)/2) THEN
      WRITE(*,'(A)') ' THERE APPEAR TO BE NO CONNECTIONS LEFT TO TRY IN DIJKSTRA - QUIT'
      CALL TSUMMARY
      CALL EXIT(10)
   ENDIF

   IF (ABS(MINWEIGHT).LT.1.0D-5) THEN
      WRITE(*,'(A)') ' WARNING - CONNECTED PATH APPEARS TO EXIST ALREADY IN DIJKSTRA!'
   ENDIF

! SHOULD HAVE FOUND SHORTEST PATH NOW. GET IT, BACKWARDS FROM END

  BEGIN=1
  END=2
  I=END
  NSTEP=0
  NDIJPAIRS=0
  DO 
     IF (I==BEGIN) EXIT
     NSTEP=NSTEP + 1
     IF (GETDISTANCE(I,DIJMIN(I)%PREVMIN)>0.0D0) THEN
        NDIJPAIRS=NDIJPAIRS+1
     ENDIF
     I=DIJMIN(I)%PREVMIN
  ENDDO

     ALLOCATE(DIJPAIR(NDIJPAIRS,2))
     ALLOCATE(DIJPAIRDIST(NDIJPAIRS))
     IF (EXPCOSTFUNCTION) THEN ! SAT
          MINWEIGHT=LOG(MINWEIGHT)
     ELSEIF (INTERPCOSTFUNCTION) THEN 
          MINWEIGHT=MINWEIGHT
     ELSE
          MINWEIGHT=MINWEIGHT**(1.0D0/COSTFUNCTIONPOWER)
     ENDIF
     WRITE(*,'(A,I6,A,I6,A,G15.5)') ' SHORTEST PATH IN DIJKSTRA HAS ',NSTEP,' STEPS WITH ',NDIJPAIRS, &
                                 ' MISSING CONNECTIONS, LENGTH=',MINWEIGHT
!    WRITE(*,'(A)') ' THE MINIMA IN THE CHAIN AND INTERVENING WEIGHTS ARE:'
     WRITE(*,'(A)') ' THE UNCONNECTED MINIMA IN THE CHAIN AND THEIR DISTANCES ARE:'
  I=END
  NSTEP=0
  NDIJPAIRS=0
  DO 
     IF (I==BEGIN) EXIT
     NSTEP=NSTEP + 1
     DUMMYDJW=GETDISTANCE(I,DIJMIN(I)%PREVMIN)
!    WRITE(*,'(I6,F12.2)',ADVANCE="NO") I,DUMMYDJW
     IF (DUMMYDJW>0.0D0) THEN
        WRITE(*,'(I6,F12.2,I6)',ADVANCE="NO") I,DUMMYDJW,DIJMIN(I)%PREVMIN
        NDIJPAIRS=NDIJPAIRS+1
        DIJPAIR(NDIJPAIRS,1)=I
        DIJPAIR(NDIJPAIRS,2)=DIJMIN(I)%PREVMIN
        DIJPAIRDIST(NDIJPAIRS)=DUMMYDJW
     ENDIF
     I=DIJMIN(I)%PREVMIN
  ENDDO
! WRITE(*,'(I6)') BEGIN
  WRITE(*,'(A)') ' '

  DEALLOCATE(DIJMIN)

     END SUBROUTINE DECIDE

END MODULE DECIDEWHATTOCONNECT
