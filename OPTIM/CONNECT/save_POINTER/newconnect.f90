!   CONNECT MODULE IS AN IMPLEMENTATION OF A CONNECTION ALGORITHM FOR FINDING REARRANGEMENT PATHWAYS.
!   COPYRIGHT (C) 2003-2006 SEMEN A. TRYGUBENKO AND DAVID J. WALES
!   THIS FILE IS PART OF CONNECT MODULE. CONNECT MODULE IS PART OF OPTIM.
!
!   OPTIM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
!   IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
!   THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
!   (AT YOUR OPTION) ANY LATER VERSION.
!
!   OPTIM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
!   BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
!   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
!   GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
!
!   YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
!   ALONG WITH THIS PROGRAM; IF NOT, WRITE TO THE FREE SOFTWARE
!   FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330, BOSTON, MA  02111-1307  USA
!
MODULE NEWCONNECTMODULE
     IMPLICIT NONE
     CONTAINS

     SUBROUTINE NEWCONNECT(NA,EII,QQ,EFF,FINFIN,ENDPOINTSEP,PTEST,REDOPATH,REDOPATHXYZ)
          USE CONNECTDATA
          USE KEYCONNECT
          USE CONNECTUTILS
          USE DECIDEWHATTOCONNECT
          USE TRYCONNECTMODULE
          USE IDOMODULE
          USE KEY,ONLY : BHDISTTHRESH, BHINTERPT, BHDEBUG
          IMPLICIT NONE

          INTEGER,INTENT(IN)              :: NA
          DOUBLE PRECISION,INTENT(IN)           :: ENDPOINTSEP,EII,EFF,QQ(3*NA),FINFIN(3*NA)
          LOGICAL,INTENT(IN)              :: PTEST
          DOUBLE PRECISION,POINTER              :: EI,EF
          DOUBLE PRECISION,POINTER,DIMENSION(:) :: Q,FIN

          INTEGER :: JS,JF,JS2,J1,J2,NSTART,POSITION
          CHARACTER(LEN=132) :: STR
          LOGICAL REDOPATH, REDOPATHXYZ, YESNO, SUCCESS, MINNEW, PERMUTE
          DOUBLE PRECISION TSREDO(3*NA), DSTART, DFINISH
          DOUBLE PRECISION, POINTER :: PINTERPCOORDS(:), PENERGY
          DOUBLE PRECISION INTERPCOORDS(3*NA), ENERGY
          DOUBLE PRECISION CSTART(3*NA), CFINISH(3*NA)
          INTEGER, ALLOCATABLE :: TEMPDIJPAIR(:,:)
          DOUBLE PRECISION, ALLOCATABLE :: TEMPDIJPAIRDIST(:)
          INTEGER INVERT, INDEX(NA), IMATCH

          FINISHED=.FALSE.
          ALLOCATE(EI,EF,Q(3*NA),FIN(3*NA))
          EI=EII;EF=EFF;Q=QQ;FIN=FINFIN;

          MOREPRINTING=PTEST
          IF (MOREPRINTING) THEN
               CALL ALLKEYCONNECTPRINT
               PRINT*
          ENDIF
          CALL INITIALISE(NA,EI,Q,EF,FIN,ENDPOINTSEP)
          INQUIRE(FILE='REDOPOINTS',EXIST=YESNO)
          IF (YESNO) THEN
             IF (REDOPATH.AND.(.NOT.REDOPATHXYZ)) THEN
                PRINT '(A)',' NEWCONNECT> TRANSITION STATE COORDINATES WILL BE READ FROM FILE REDOPOINTS'
!            ELSE
!               PRINT '(A)',' NEWCONNECT> WARNING - REDOPOINTS FILE PRESENT, BUT NO REDOPATH KEYWORD'
             ENDIF
          ELSE
             IF (REDOPATH.AND.(.NOT.REDOPATHXYZ)) THEN
                PRINT '(A)',' NEWCONNECT> WARNING - REDOPATH KEYWORD WAS SPECIFIED, BUT NO REDOPOINTS FILE'
                REDOPATH=.FALSE.
             ENDIF
          ENDIF

          IF (REDOPATHXYZ) PRINT '(A)',' NEWCONNECT> REDO RUN WILL USE AVAILABLE PATH.<N>.XYZ FILES'
          IF (REDOPATH.AND.(.NOT.REDOPATHXYZ)) OPEN(99,FILE='REDOPOINTS',STATUS='OLD')

          DO NCONDONE=1,NCONMAX
               WRITE(CHR,'(I5)') NCONDONE
               WRITE(STR,'(3A)') '>>>>>>>>>>>>>>>>>>>>> CONNECT CYCLE ',TRIM(ADJUSTL(CHR)),' >>>>>>>>>>>>>>>>>>>>>'
               WRITE(CHR,'(I5)') NMIN
               WRITE(STR,'(A)')  TRIM(STR)//' '//TRIM(ADJUSTL(CHR))//' MINIMA AND'
               WRITE(CHR,'(I5)') NTS
               WRITE(STR,'(A)')  TRIM(STR)//' '//TRIM(ADJUSTL(CHR))//' TS ARE KNOWN'
               WRITE(*,'(1X,A)') TRIM(STR)//' '//REPEAT('>',107-LEN_TRIM(STR))
!
!  READ IN TRANSITION STATE COORDINATES FROM REDOPOINTS IF AVAILABLE.
!
               IF (REDOPATH.AND.(.NOT.REDOPATHXYZ)) THEN
                  READ(99,*,END=32) (TSREDO(J1),J1=1,3*NA)
                  WRITE(*,'(A)') ' NEWCONNECT> TRANSITION STATE COORDINATES READ FROM FILE REDOPOINTS'
                  GOTO 33
32                WRITE(*,'(A)') ' NEWCONNECT> NO MORE TRANSITION STATE COORDINATES IN REDOPOINTS'
                  REDOPATH=.FALSE.
                  CLOSE(99)
33                CONTINUE
               ENDIF

               IF (REDOPATH) THEN
                  CALL TRYCONNECT(1,2,TSREDO,REDOPATH,REDOPATHXYZ)
               ELSE
                  CALL DECIDE

!    CALL TRYCONNECT FOR EACH PAIR OF MINIMA SPECIFIED IN THE SHORTEST PATH RETURNED BY DIJKSTRA
!    CALL BHINTERP TO FILL IN ADDTIONAL MINIMA IF REQUIRED.

                  IF (BHINTERPT) THEN
                     NSTART=1
34                   CONTINUE
                     DO J1=NSTART,NDIJPAIRS
!                       PRINT '(A)',' NEWCONNECT> DIJPAIR DISTANCES AND MINIMA:'
!                       PRINT '(I8,G20.10,2I8)',(J2,DIJPAIRDIST(J2),DIJPAIR(J2,1),DIJPAIR(J2,2),J2=1,NDIJPAIRS)
                        PRINT '(A,I8,A,I8,A,I8,A,G20.10)',' NEWCONNECT> GAP ',J1,' BH INTERPOLATION FOR MINIMA   ',DIJPAIR(J1,1), &
  &                                    ' AND ',DIJPAIR(J1,2),' DIST=',DIJPAIRDIST(J1)
                        IF (DIJPAIRDIST(J1).GT.BHDISTTHRESH) THEN
                           CSTART(1:3*NA)=MI(DIJPAIR(J1,1))%DATA%X(1:3*NA)
                           CFINISH(1:3*NA)=MI(DIJPAIR(J1,2))%DATA%X(1:3*NA)
                           CALL BHINTERP(CSTART,CFINISH,3*NA,NA,INTERPCOORDS,SUCCESS,DSTART,DFINISH,ENERGY)
                           IF ((DSTART.GT.DIJPAIRDIST(J1)).OR.(DFINISH.GT.DIJPAIRDIST(J1))) THEN
                              IF (SUCCESS.AND.BHDEBUG) PRINT '(A)',' NEWCONNECT> BH INTERPOLATED DISTANCE IS LARGER - REJECT'
                              SUCCESS=.FALSE.
                           ENDIF
                           IF (SUCCESS) THEN
!
! IF THE EXTRA MINIMUM IS NEW ADD IT TO THE STACK ALONG WITH ALL ITS DISTANCES.
! MUST ALSO ADD IT TO THE DIJPAIR LIST.
!
                              NULLIFY(PINTERPCOORDS,PENERGY)
                              ALLOCATE(PINTERPCOORDS(3*NA),PENERGY)
!
! HERE WE ARE READING DATA INTO THE POINTERS PENERGY AND PINTERPCOORDS SO THAT WHEN
! THEY ARE SUBSEQUENTLY NULLIFIED THE DATA IN MI%DATA IS PRESERVED. 
! THIS IS A TRULY HORRIBLE HACK CAUSED BY THE INAPPROPRIATE POINTER ATTRIBUTE FOR STATIC DATA.
!
                              OPEN(UNIT=781,FILE='BHSCRATCH',STATUS='UNKNOWN')
                              WRITE(781,*) ENERGY,INTERPCOORDS
                              REWIND(781)
                              READ(781,*) PENERGY,PINTERPCOORDS
                              CLOSE(781)

                              CALL ISNEWMIN(PENERGY,PINTERPCOORDS,POSITION,MINNEW,REDOPATH,PERMUTE,INVERT,INDEX,IMATCH)
                              IF (MINNEW) THEN
                                 WRITE(*,'(A,I7)') ' NEWCONNECT> INTERPOLATED MINIMUM IS NEW MINIMUM ',POSITION
                                 CALL ADDNEWMIN(PENERGY,PINTERPCOORDS)
                              ELSE
                                 WRITE(*,'(A,I7)') ' NEWCONNECT> INTERPOLATED MINIMUM IS OLD MINIMUM ',POSITION
                              ENDIF
                              NULLIFY(PINTERPCOORDS,PENERGY) 

                              ALLOCATE(TEMPDIJPAIR(NDIJPAIRS,2),TEMPDIJPAIRDIST(NDIJPAIRS))
                              TEMPDIJPAIR(1:NDIJPAIRS,1:2)=DIJPAIR(1:NDIJPAIRS,1:2)
                              TEMPDIJPAIRDIST(1:NDIJPAIRS)=DIJPAIRDIST(1:NDIJPAIRS)
                              DEALLOCATE(DIJPAIR,DIJPAIRDIST)
                              NDIJPAIRS=NDIJPAIRS+1
                              ALLOCATE(DIJPAIR(NDIJPAIRS,2),DIJPAIRDIST(NDIJPAIRS))
                              DO J2=1,J1-1
                                 DIJPAIR(J2,1:2)=TEMPDIJPAIR(J2,1:2)
                                 DIJPAIRDIST(J2)=TEMPDIJPAIRDIST(J2)
                              ENDDO
                              DIJPAIR(J1,1)=TEMPDIJPAIR(J1,1)
                              DIJPAIR(J1,2)=POSITION
                              DIJPAIRDIST(J1)=DSTART
                              DIJPAIR(J1+1,1)=POSITION
                              DIJPAIR(J1+1,2)=TEMPDIJPAIR(J1,2)
                              DIJPAIRDIST(J1+1)=DFINISH
                              DO J2=J1+1,NDIJPAIRS-1
                                 DIJPAIR(J2+1,1:2)=TEMPDIJPAIR(J2,1:2)
                                 DIJPAIRDIST(J2+1)=TEMPDIJPAIRDIST(J2)
                              ENDDO
                              NSTART=J1
                              DEALLOCATE(TEMPDIJPAIR,TEMPDIJPAIRDIST)
                              GOTO 34 ! GO BACK, SINCE NDIJPAIRS HAS INCREASED BY ONE
                           ELSE
                              NSTART=J1+1 ! TO AVOID AN INFINITE LOOP
                           ENDIF
                        ENDIF
                     ENDDO
                     WRITE(*,'(A)') ' NEWCONNECT> THE UNCONNECTED MINIMA IN THE CHAIN AND THEIR DISTANCES ARE NOW:'
                     DO J1=1,NDIJPAIRS
                        WRITE(*,'(I6,F12.2,I6)',ADVANCE="NO") DIJPAIR(J1,1),DIJPAIRDIST(J1),DIJPAIR(J1,2)
                     ENDDO
                  ENDIF
                  WRITE(*,'(A)') ' ' ! TO ADVANCE TO THE NEXT LINE

                  DO J1=1,NDIJPAIRS
                     JS=MAX(DIJPAIR(J1,1),DIJPAIR(J1,2))
                     JF=MIN(DIJPAIR(J1,1),DIJPAIR(J1,2))
                     WRITE(*,'(A,I5,A,2I5)') ' NEWCONNECT> TRYING DIJKSTRA PAIR NUMBER ',J1,' MINIMA ',JS,JF
                     MI(JS)%DATA%NTRIES(JF) = MI(JS)%DATA%NTRIES(JF) + 1
!    SET EDGE WEIGHT TO INFINITY IF WE HAVE REACHED THE MAXIMUM NUMBER OF TRIES FOR THIS PAIR.
                     CALL TRYCONNECT(JF,JS,TSREDO,REDOPATH,REDOPATHXYZ)
                     IF ((MI(JS)%DATA%NTRIES(JF).GE.NTRIESMAX).AND.  &
                         (MI(JS)%DATA%D(JF).GT.1.0D-5)) MI(JS)%DATA%D(JF) = HUGE(MI(JS)%DATA%D(JF))
                  ENDDO

                  DEALLOCATE(DIJPAIR,DIJPAIRDIST)
               ENDIF

               IF (FINISHED) EXIT
          ENDDO

          CALL OUTPUT
          CALL DEINITIALISE
          DEALLOCATE(Q,FIN,EI,EF)
     END SUBROUTINE NEWCONNECT

END MODULE NEWCONNECTMODULE
