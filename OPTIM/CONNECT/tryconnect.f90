!   CONNECT MODULE IS AN IMPLEMENTATION OF A CONNECTION ALGORITHM FOR FINDING REARRANGEMENT PATHWAYS.
!   COPYRIGHT (C) 2003-2006 SEMEN A. TRYGUBENKO AND DAVID J. WALES
!   THIS FILE IS PART OF CONNECT MODULE. CONNECT MODULE IS PART OF OPTIM.
!
!   OPTIM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
!   IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
!   THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
!   (AT YOUR OPTION) ANY LATER VERSION.
!
!   OPTIM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
!   BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
!   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
!   GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
!
!   YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
!   ALONG WITH THIS PROGRAM; IF NOT, WRITE TO THE FREE SOFTWARE
!   FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330, BOSTON, MA  02111-1307  USA
!
MODULE TRYCONNECTMODULE
     IMPLICIT NONE
     CONTAINS

     SUBROUTINE TRYCONNECT(JS,JF,TSREDO,REDOPATH,REDOPATHXYZ,USEINT,USEINTLJ)
          USE NEWNEBMODULE
          USE CONNECTDATA
          USE KEYCONNECT
          USE CONNECTUTILS
          USE NEBTOCONNECT
          USE KEYNEB, ONLY: NIMAGE, NITERMAX
          USE KEY, ONLY: UNRST, DEBUG, FILTH, FILTHSTR, DUMPALLPATHS, TWOD, MAXTSENERGY, RIGIDBODY, &
  &                   MAXMAXBARRIER, DIJKSTRALOCAL, &
  &                   PERMDIST, MAXBARRIER, GROWSTRINGT, BULKT, AMBERT, NABT, FREEZE, FROZEN, NFREEZE, &
  &                   PUSHOFF, MAXBFGS, MIN1REDO, MIN2REDO, REDOKADD, D1INIT, D2INIT, REDOE1, REDOE2, &
  &                   AMHT, SEQ, INTIMAGE
          USE MODGUESS
          USE MODUNRES
          USE MODCHARMM, ONLY : CHRMMT,NCHENCALLS,CHECKOMEGAT,CHECKCHIRALT,NOCISTRANS,MINOMEGA
          USE MODAMBER9, ONLY : NOCISTRANSRNA, NOCISTRANSDNA, GOODSTRUCTURE1, GOODSTRUCTURE2, CISARRAY1, CISARRAY2
          USE MODMEC
          USE KEYUTILS
          USE COMMONS, ONLY : NINTS, PARAM1, PARAM2, PARAM3, ZSYM, EVDISTTHRESH, REDOPATHNEB
          USE PORFUNCS
          USE AMHGLOBALS, ONLY : NMRES
          USE GSDATA, ONLY : GSITERDENSITY, GSCURITERD=>ITERD
          IMPLICIT NONE
          DOUBLE PRECISION RMAT(3,3), DISTFAC

          INTEGER,INTENT(IN) :: JS,JF
          LOGICAL,INTENT(IN) :: USEINT, USEINTLJ
          
          INTEGER         :: I,UNIQUE=0,MINPLUSPOS,MINMINUSPOS,J1,NC1,NC2,GLY_COUNT
          DOUBLE PRECISION         :: EDUMMY,EDUMMY2,TMPTS(3*NATOMS),SAVEPUSHOFF,SAVEMAXBFGS
          DOUBLE PRECISION,POINTER :: QPLUS(:),QMINUS(:),EPLUS,EMINUS
          LOGICAL         :: PLUSNEW,MINUSNEW,PATHFAILT,AMIDEFAIL,CHIRALFAIL,RERUN
          CHARACTER       :: ITSTRING*80, EOFSSTRING*80
          DOUBLE PRECISION :: STARTINT(NINTS), FINISHINT(NINTS),DUM, LDUMMY
          LOGICAL REDOPATH, REDOPATHXYZ, PERMUTE, EXISTS, NORERUN, PERMTEST
          DOUBLE PRECISION TSREDO(3*NATOMS), ETSPREV, ETSDUM, DIST2, QP(3*NATOMS), QM(3*NATOMS), LGDUMMY(3*NATOMS)
          INTEGER INVERT, INDEX(NATOMS), J2, IMATCH
          CHARACTER(LEN=2) ZDUM
          CHARACTER(LEN=10) DUMMYS          
          CHARACTER(LEN=80) TRYFNAME          
          DOUBLE PRECISION, POINTER :: PINTERPCOORDS(:), PENERGY
          LOGICAL MINNEW
          INTEGER POSITION, NMINSAVE, NMINORIG
          DOUBLE PRECISION DIST1P, DIST1M, DIST2P, DIST2M
          LOGICAL PATHFAILED
          INTEGER :: NREDOPATHTRIES1=1
          INTEGER :: NREDOPATHTRIES2=1
          DOUBLE PRECISION :: REDOSTRETCH=5.0D0
!
!  WE WANT TO RETURN HERE TO RERUN THE PATH FOR TRANSITION STATES READ IN WITH REDOPATH
!  IN CASE THE CONNECTION FAILS.
!
          NC1=0 ! COUNTER FOR CHANGES OF PUSHOFF VALUE
          NC2=0 ! COUNTER FOR CHANGES OF BFGSSTEP VALUE
          SAVEPUSHOFF=PUSHOFF
          SAVEMAXBFGS=MAXBFGS
          NMINORIG=NMIN
          RERUN=.FALSE.
10        CONTINUE

          IF (GROWSTRINGT) THEN
             IF (NCONDONE.EQ.1.AND.FCD) THEN
                GSCURITERD = GSITERDENSITY
             ELSE
                GSCURITERD = ITERDENSITY
             ENDIF
          ENDIF

          IF (CHRMMT) NCHENCALLS = 999 ! UPDATE NON-BONDED LIST ON NEXT CALL TO POTENTIAL.
!
!  SUBROUTINE CHECKPAIR PUTS THE ENDPOINTS INTO OPTIMAL ALIGNMENT.
!
          IF (.NOT.REDOPATH) THEN
             CALL CHECKPAIR(JS,JF,PERMTEST)
          ELSE
            PERMTEST=.FALSE.
            IF (ABS(MI(JS)%DATA%E-MI(JF)%DATA%E) < EDIFFTOL) PERMTEST=.TRUE. ! MUST INITIALISE THIS LOGICAL
            CALL MINPERMDIST(TSREDO,MIN1REDO,NATOMS,DEBUG,PARAM1,PARAM2,PARAM3,BULKT,TWOD,D,DIST2,RIGIDBODY,RMAT)
            D1INIT=D
            CALL MINPERMDIST(TSREDO,MIN2REDO,NATOMS,DEBUG,PARAM1,PARAM2,PARAM3,BULKT,TWOD,D,DIST2,RIGIDBODY,RMAT)
            D2INIT=D

             IF (DEBUG) PRINT '(A,2F20.10)',' TRYCONNECT> INITIAL DISTANCES OF TRANSITION STATE TO MINIMA ARE :',D1INIT,D2INIT
          ENDIF

          IF (GUESSPATHT) THEN
            IF (UNRST) THEN
               DO J1=1,NRES
                  C(1,J1)=MI(JS)%DATA%X(6*(J1-1)+1)
                  C(2,J1)=MI(JS)%DATA%X(6*(J1-1)+2)
                  C(3,J1)=MI(JS)%DATA%X(6*(J1-1)+3)
                  C(1,J1+NRES)=MI(JS)%DATA%X(6*(J1-1)+4)
                  C(2,J1+NRES)=MI(JS)%DATA%X(6*(J1-1)+5)
                  C(3,J1+NRES)=MI(JS)%DATA%X(6*(J1-1)+6)
               ENDDO
               CALL UPDATEDC
!CALL INT_FROM_CART(.TRUE.,.FALSE.)
!CALL GEOM_TO_VAR(NINTS,STARTINT(1:NINTS)) 
               DO J1=1,NRES
                  C(1,J1)=MI(JF)%DATA%X(6*(J1-1)+1)
                  C(2,J1)=MI(JF)%DATA%X(6*(J1-1)+2)
                  C(3,J1)=MI(JF)%DATA%X(6*(J1-1)+3)
                  C(1,J1+NRES)=MI(JF)%DATA%X(6*(J1-1)+4)
                  C(2,J1+NRES)=MI(JF)%DATA%X(6*(J1-1)+5)
                  C(3,J1+NRES)=MI(JF)%DATA%X(6*(J1-1)+6)
               ENDDO
               CALL UPDATEDC
!CALL INT_FROM_CART(.TRUE.,.FALSE.)
!CALL GEOM_TO_VAR(NINTS,FINISHINT(1:NINTS))
               CALL GUESSPATH(STARTINT,FINISHINT,NINTS,EDIFFTOL,NATOMS)
            ELSE
               CALL GUESSPATH(MI(JS)%DATA%X,MI(JF)%DATA%X,3*NATOMS,EDIFFTOL,NATOMS)
            ENDIF
          ! HOW MANY IMAGES TO USE?
            IF (NIMAGE > IMAGEMAX) PRINT*,'WARNING - NIMAGE IS GREATER THAN IMAGEMAX'
            IF (NIMAGE < 2       ) PRINT*,'WARNING - NIMAGE IS < 2'
            NIMAGE=NINTERP
!           NITERMAX = NIMAGE*ITERDENSITY ! TRY ZERO NEB ITERATIONS IF WE HAVE A GUESSPATH PATH
            NITERMAX = 0
            IF (NINTERP.LT.2) THEN ! NO IMAGES FROM GUESSPATH - REVERT TO USUAL SCHEME
               IF (.NOT.(NCONDONE==1 .AND. FCD)) THEN
!                   NIMAGE=IMAGEDENSITY*MI(JF)%DATA%D(JS) &
!                       +IMAGEINCR*IMAGEDENSITY*MI(JF)%DATA%D(JS)*(MI(JF)%DATA%NTRIES(JS)-1)
                  DISTFAC=MI(JF)%DATA%D(JS)
                  IF (DIJKSTRALOCAL.NE.1.0D0) THEN
                     CALL MINPERMDIST(MI(JS)%DATA%X,MI(JF)%DATA%X,NATOMS,DEBUG,PARAM1,PARAM2,PARAM3,BULKT,TWOD, &
     &                                   DISTFAC,DIST2,RIGIDBODY,RMAT)
                  ENDIF
                  NIMAGE=DISTFAC*(IMAGEDENSITY+IMAGEINCR*(MI(JF)%DATA%NTRIES(JS)-1))
                  IF (NIMAGE >= IMAGEMAX) THEN
                     NIMAGE = IMAGEMAX
!                    MI(JF)%DATA%NTRIES(JS)=NTRIESMAX ! NO POINT TRYING AGAIN WITH THE SAME NUMBER OF IMAGES
                  ENDIF
                  IF (NIMAGE < 2       ) NIMAGE = 2
                  NITERMAX = NIMAGE*ITERDENSITY
               ENDIF

            ENDIF
          ELSEIF (MECCANOT) THEN
          ! HOW MANY IMAGES TO USE?
            NIMAGE=NINT(MIN(MECIMDENS*MI(JF)%DATA%D(JS),MECMAXIMAGES*1.0D0)) ! IMAGE DENSITY TIMES DISTANCE
!           IF (NIMAGE > IMAGEMAX) PRINT*,'WARNING - NIMAGE IS GREATER THAN IMAGEMAX'
            IF (NIMAGE < 1       ) NIMAGE=1
            NITERMAX=NINT(MIN(NIMAGE*MECITDENS,MECMAXIT*1.0D0)) ! NUMBER OF IMAGES TIMES ITERATION DENSITY
            IF (UNRST) THEN
               DO J1=1,NRES
                  C(1,J1)=MI(JS)%DATA%X(6*(J1-1)+1)
                  C(2,J1)=MI(JS)%DATA%X(6*(J1-1)+2)
                  C(3,J1)=MI(JS)%DATA%X(6*(J1-1)+3)
                  C(1,J1+NRES)=MI(JS)%DATA%X(6*(J1-1)+4)
                  C(2,J1+NRES)=MI(JS)%DATA%X(6*(J1-1)+5)
                  C(3,J1+NRES)=MI(JS)%DATA%X(6*(J1-1)+6)
               ENDDO
               CALL UPDATEDC
!CALL INT_FROM_CART(.TRUE.,.FALSE.)
!CALL GEOM_TO_VAR(NINTS,STARTINT(1:NINTS))
               DO J1=1,NRES
                  C(1,J1)=MI(JF)%DATA%X(6*(J1-1)+1)
                  C(2,J1)=MI(JF)%DATA%X(6*(J1-1)+2)
                  C(3,J1)=MI(JF)%DATA%X(6*(J1-1)+3)
                  C(1,J1+NRES)=MI(JF)%DATA%X(6*(J1-1)+4)
                  C(2,J1+NRES)=MI(JF)%DATA%X(6*(J1-1)+5)
                  C(3,J1+NRES)=MI(JF)%DATA%X(6*(J1-1)+6)
               ENDDO
               CALL UPDATEDC
!CALL INT_FROM_CART(.TRUE.,.FALSE.)
!CALL GEOM_TO_VAR(NINTS,FINISHINT(1:NINTS))
               CALL UNMECCANO(.TRUE.,DEBUG,DUM,.FALSE.,STARTINT,FINISHINT,DUM,DUM,DUM,DUM)
            ELSE
               CALL MECCANO(.TRUE.,DEBUG,DUM,.FALSE.,MI(JS)%DATA%X,MI(JF)%DATA%X,DUM,DUM,DUM,DUM)
            ENDIF
            NITERMAX = 0 ! TRY ZERO NEB ITERATIONS IF WE HAVE A MECCANO PATH

          ELSEIF (REDOPATH.AND.(.NOT.REDOPATHNEB)) THEN
            NIMAGE=1
            NITERMAX = 0 ! TRY ZERO NEB ITERATIONS IF WE HAVE POINTS IN TSREDO
          ELSEIF (NCONDONE==1 .AND. FCD) THEN ! FIRST CYCLE DIFFERENT - PARAMETERS SUPPLIED USING NEWNEB
                                          ! KEYWORD OR NEWNEB DEFAULTS WILL BE USED INSTEAD
               PRINT '(A)'," TRYCONNECT> FIRST DNEB CALCULATION WILL USE PARAMETERS FROM THE NEWNEB LINE IN ODATA"
          ELSE
            IF (REDOPATHNEB) THEN
               NIMAGE=(D1INIT+D2INIT)*IMAGEDENSITY
            ELSE
               NIMAGE=MI(JF)%DATA%D(JS)*(IMAGEDENSITY+IMAGEINCR*(MI(JF)%DATA%NTRIES(JS)-1))
            ENDIF
!           PRINT '(A,F10.2,G20.10,F10.2,2I8)',' TRYCONNECT> IMAGEDENSITY,DIST,IMAGEINCR,TRIES,NIMAGE=', &
! &                    IMAGEDENSITY,MI(JF)%DATA%D(JS), &
! &                    IMAGEINCR,MI(JF)%DATA%NTRIES(JS),NIMAGE
               IF (NIMAGE >= IMAGEMAX) THEN
                  NIMAGE = IMAGEMAX
!                 MI(JF)%DATA%NTRIES(JS)=NTRIESMAX ! NO POINT TRYING AGAIN WITH THE SAME NUMBER OF IMAGES
               ENDIF
               IF (NIMAGE < 2       ) NIMAGE = 2
               NITERMAX = NIMAGE*ITERDENSITY
          ENDIF
         
          ! BOOK-KEEPING :-)
          IF (.NOT.(MECCANOT.OR.(REDOPATH.AND.(.NOT.REDOPATHNEB)))) THEN             
             IF (GROWSTRINGT) THEN
                WRITE(CHR,'(I7)') INT(NIMAGE*GSCURITERD)
                WRITE(*,'(/A)',ADVANCE='NO') ' TRYCONNECT> '//TRIM(ADJUSTL(CHR))//'-ITERATION GS RUN FOR MINIMA '
             ELSE IF (USEINT) THEN
                WRITE(*,'(/A)',ADVANCE='NO') ' TRYCONNECT> INTERPOLATION WITH CONSTRAINT POTENTIAL FOR MINIMA '
             ELSE IF (USEINTLJ) THEN
                WRITE(*,'(/A)',ADVANCE='NO') ' TRYCONNECT> INTERPOLATION WITH INTERPLJ POTENTIAL FOR MINIMA '
             ELSE
                WRITE(CHR,'(I7)') NITERMAX
                WRITE(*,'(/A)',ADVANCE='NO') ' TRYCONNECT> '//TRIM(ADJUSTL(CHR))//'-ITERATION DNEB RUN FOR MINIMA '
             ENDIF
             WRITE(CHR,'(I5)') JS
             WRITE(*,'(A)',ADVANCE='NO') TRIM(ADJUSTL(CHR))
          
             IF (MI(JS)%DATA%S) THEN
                  WRITE(*,'(A)',ADVANCE='NO') '_S'
             ELSEIF (MI(JS)%DATA%F) THEN
                  WRITE(*,'(A)',ADVANCE='NO') '_F'
             ELSE
                  WRITE(*,'(A)',ADVANCE='NO') '_U'
             ENDIF
             WRITE(CHR,'(I5)') JF
             WRITE(*,'(A)',ADVANCE='NO') ' AND '//TRIM(ADJUSTL(CHR))
             IF (MI(JF)%DATA%S) THEN
                  WRITE(*,'(A)',ADVANCE='NO') '_S'
             ELSEIF (MI(JF)%DATA%F) THEN
                  WRITE(*,'(A)',ADVANCE='NO') '_F'
             ELSE
                  WRITE(*,'(A)',ADVANCE='NO') '_U'
             ENDIF
          
             ! GETTING TS CANDIDATES FROM NEB

             IF (USEINT.OR.USEINTLJ) THEN
                WRITE(CHR,'(I5)') INTIMAGE
             ELSE
                WRITE(CHR,'(I5)') NIMAGE
             ENDIF
             WRITE(*,'(A)',ADVANCE='NO') ' USING '//TRIM(ADJUSTL(CHR))//' IMAGES '
             IF (MI(JF)%DATA%NTRIES(JS) > 1) THEN
                  WRITE(CHR,'(I5)') MI(JF)%DATA%NTRIES(JS)
                  WRITE(*,'(A)',ADVANCE='NO') '(ATTEMPT #'//TRIM(ADJUSTL(CHR))//') '
             ENDIF
             WRITE(*,'(A)') ' ...'
          ENDIF

          EVDISTTHRESH=-0.2D0 ! DJW ! NOT BEING USED AT THE MOMENT

          IF (EVDISTTHRESH.GT.0.0D0) THEN
             NFREEZE=0
             DO J1=1,NATOMS
                LDUMMY=(MI(JS)%DATA%X(3*(J1-1)+1)-MI(JF)%DATA%X(3*(J1-1)+1))**2 &
     &             +(MI(JS)%DATA%X(3*(J1-1)+2)-MI(JF)%DATA%X(3*(J1-1)+2))**2 &
     &             +(MI(JS)%DATA%X(3*(J1-1)+3)-MI(JF)%DATA%X(3*(J1-1)+3))**2
                IF (LDUMMY.GE.EVDISTTHRESH) THEN
                   PRINT '(A,I8,A,F20.10)',' TRYCONNECT> DISPLACEMENT OF ATOM ',J1,' BETWEEN END POINTS IS ',SQRT(LDUMMY)
                ELSE
                   FROZEN(J1)=.TRUE.
                   NFREEZE=NFREEZE+1
                ENDIF
             ENDDO
             IF (NFREEZE.GT.0) THEN
                FREEZE=.TRUE.
                PRINT '(A,I8,A)',' TRYCONNECT> INITIALLY FREEZING ',NFREEZE,' ATOMS'
             ENDIF
          ENDIF

          IF ((.NOT.(USEINT.OR.USEINTLJ)).AND.(NIMAGE>=IMAGEMAX)) MI(JF)%DATA%NTRIES(JS)=NTRIESMAX ! NO POINT TRYING AGAIN WITH THE SAME NUMBER 
          IF (REDOPATHXYZ) THEN
             NORERUN=.FALSE.
!
! NCONDONE SHOULD BE NTS+1, OTHERWISE ONE PREVIOUS RUN HAS FAILED TO GET A NEW TS FROM THE PATH.<N>.XYZ FILE,
! WHICH SHOULD NEVER HAPPEN?!
!
             IF (NCONDONE.NE.NTS+1) THEN
                PRINT '(2(A,I8))',' TRYCONNECT> ERROR - NCONDONE=',NCONDONE,' NTS=',NTS
                STOP
             ENDIF
             CALL MKFNAMES(NTS+1,FILTH,FILTHSTR,ITSTRING,EOFSSTRING)
             INQUIRE(FILE=TRIM(ADJUSTL(ITSTRING)),EXIST=EXISTS)
             IF (EXISTS) THEN ! ALLOWS FOR RERUN WITH DIFFERENT ENERGY DIFFERENCE CRITERION FOR
                              ! CONSECUTIVE FRAMES IN PATH WITHOUT REDOING ORIGINAL PATH
                PRINT '(2A)',' TRYCONNECT> READING DATA FOR TS FROM EXISTING FILE ',TRIM(ADJUSTL(ITSTRING))
                NORERUN=.TRUE.
             ELSE
                PRINT '(3A)',' TRYCONNECT> NO FILE ',TRIM(ADJUSTL(ITSTRING)),' FOUND'
                REDOPATH=.FALSE.
                REDOPATHXYZ=.FALSE.
                STOP ! REDOPATHXYZ IS ONLY GOING TO WORK AFTER A RUN FROM REDOPOINTS, IN WHICH CASE
                     ! WE SHOULD FINISH AFTER READING THE LAST PATH.
             ENDIF
             IF (NORERUN) THEN
                NTSFOUND=1
                ALLOCATE(TSFOUND(NTSFOUND)%E,TSFOUND(NTSFOUND)%COORD(NOPT),&
   &                     TSFOUND(NTSFOUND)%EVALMIN,TSFOUND(NTSFOUND)%VECS(NOPT))
                OPEN(UNIT=89,FILE=ITSTRING,STATUS='OLD')
                ETSPREV=1.0D100
                TSFOUND(1)%E=-1.0D100
                DO
                   READ(89,*)
                   READ(89,*) DUMMYS, ETSDUM
                   IF ((TSFOUND(1)%E.GT.ETSDUM).AND.(TSFOUND(1)%E.GT.ETSPREV)) GOTO 111
                   DO J1=1,NATOMS
                      READ(89,*) ZDUM,TSFOUND(1)%COORD(3*(J1-1)+1),TSFOUND(1)%COORD(3*(J1-1)+2),TSFOUND(1)%COORD(3*(J1-1)+3)
                   ENDDO
                   ETSPREV=TSFOUND(1)%E
                   TSFOUND(1)%E=ETSDUM
                ENDDO
111             CONTINUE
                IF (DEBUG) PRINT *,'TSFOUND(1)%E=',TSFOUND(1)%E
                PRINT '(A,G20.10)',' TRYCONNECT> ETS=',TSFOUND(1)%E
                CLOSE(89)
             ELSE
                IF (PERMTEST.AND.(MOD(NIMAGE,2).NE.0).AND.(.NOT.REDOPATH)) THEN
                   PRINT '(A)',' TRYCONNECT> CHANGING TO AN EVEN NUMBER OF IMAGES FOR POSSIBLE PERMUTATIONAL ISOMER'
                   NIMAGE=NIMAGE+1
                ENDIF
                IF (UNRST) THEN 
                   CALL NEWNEB(REDOPATH,TSREDO,-1.0D100,MI(JS)%DATA%X,-1.0D100,MI(JF)%DATA%X,NINTSIN=NINTS)
                ELSEIF (USEINT) THEN
                   CALL INTLBFGS(MI(JS)%DATA%X,MI(JF)%DATA%X,NMINFOUND,NTSFOUND,MINFOUND,TSFOUND)
                ELSEIF (USEINTLJ) THEN
                   CALL INTLBFGSLJ(MI(JS)%DATA%X,MI(JF)%DATA%X,NMINFOUND,NTSFOUND,MINFOUND,TSFOUND)
                ELSE
                   CALL NEWNEB(REDOPATH,TSREDO,-1.0D100,MI(JS)%DATA%X,-1.0D100,MI(JF)%DATA%X)
                ENDIF
             ENDIF
          ELSE
             IF (PERMTEST.AND.(MOD(NIMAGE,2).NE.0).AND.(.NOT. REDOPATH)) THEN
                PRINT '(A)',' TRYCONNECT> CHANGING TO AN EVEN NUMBER OF IMAGES FOR POSSIBLE PERMUTATIONAL ISOMER'
                NIMAGE=NIMAGE+1
             ENDIF
             IF (UNRST) THEN 
                 CALL NEWNEB(REDOPATH,TSREDO,MI(JS)%DATA%E,MI(JS)%DATA%X,MI(JF)%DATA%E,MI(JF)%DATA%X,NINTSIN=NINTS)
             ELSEIF (USEINT) THEN
                CALL INTLBFGS(MI(JS)%DATA%X,MI(JF)%DATA%X,NMINFOUND,NTSFOUND,MINFOUND,TSFOUND)
             ELSEIF (USEINTLJ) THEN
                CALL INTLBFGSLJ(MI(JS)%DATA%X,MI(JF)%DATA%X,NMINFOUND,NTSFOUND,MINFOUND,TSFOUND)
             ELSE
                IF (REDOPATHNEB) THEN
                   IF (DEBUG) THEN
                      PRINT '(A,2F20.10)',' TRYCONNECT> CALLING NEWNEB WITH MIN-SAD-MIN DISTANCES:',D1INIT,D2INIT
                   ENDIF
                   CALL NEWNEB(REDOPATH,TSREDO,REDOE1,MIN1REDO,REDOE2,MIN2REDO)
                ELSE
                   CALL NEWNEB(REDOPATH,TSREDO,MI(JS)%DATA%E,MI(JS)%DATA%X,MI(JF)%DATA%E,MI(JF)%DATA%X)
                ENDIF
             ENDIF
          ENDIF
!
!  WE MAY HAVE NEW MINIMA RATHER THAN NEW TS. 
!  DEAL WITH THIS FIRST.
!
          IF (NMINFOUND.GT.0) THEN
!
! CHECK IF IT;S A NEW MIN - FOLLOW WHAT WE DO IN NEWCONNECT.F90
! SAVE DATA FOR NEW MIN USING HORRIBLE WRITE/READ TRICK TO SAVE IN STATIC POINTER VARIABLES
! CREATE DISTANCES - FUDGING NEB NEIGHBOUR VALUES 
! 
             NMINSAVE=NMIN
             DO I=1,NMINFOUND
                NULLIFY(PINTERPCOORDS,PENERGY)
                ALLOCATE(PINTERPCOORDS(NOPT),PENERGY)
                OPEN(UNIT=781,FILE='MINSCRATCH',STATUS='UNKNOWN')
                WRITE(781,*) MINFOUND(I)%E,MINFOUND(I)%COORD(1:NOPT)
                REWIND(781)
                READ(781,*) PENERGY,PINTERPCOORDS
                CLOSE(781)
                CALL ISNEWMIN(PENERGY,PINTERPCOORDS,POSITION,MINNEW,REDOPATH,PERMUTE,INVERT,INDEX,IMATCH)
                IF (MINNEW) THEN
                   CALL ADDNEWMIN(PENERGY,PINTERPCOORDS)
!                  PRINT*, PINTERPCOORDS(:)
                   WRITE(*,'(A,I7,A,G20.10)') ' TRYCONNECT> ADDED NEW MINIMUM ',NMIN,' ENERGY=',PENERGY
                   IF (USEINT.OR.USEINTLJ) THEN ! WRITE MINIMUM TO FILE MIN<N> TO ENABLE DEBUGGING
                      WRITE(TRYFNAME,'(I6)') NMIN
                      TRYFNAME='MIN' // TRIM(ADJUSTL(TRYFNAME))
                      OPEN(UNIT=89,FILE=TRYFNAME,STATUS='UNKNOWN')
                      IF (AMHT) THEN
                         GLY_COUNT=0
                         DO J2=1,NMRES
                            IF (SEQ(J2).EQ.8) THEN
                               WRITE(89,'(3G25.15)') PINTERPCOORDS(9*(J2-1)+1-GLY_COUNT*3), &
     &                                               PINTERPCOORDS(9*(J2-1)+2-GLY_COUNT*3), &
     &                                               PINTERPCOORDS(9*(J2-1)+3-GLY_COUNT*3)
                               WRITE(89,'(3G25.15)') PINTERPCOORDS(9*(J2-1)+1-GLY_COUNT*3), &
     &                                               PINTERPCOORDS(9*(J2-1)+2-GLY_COUNT*3), &
     &                                               PINTERPCOORDS(9*(J2-1)+3-GLY_COUNT*3)
                               WRITE(89,'(3G25.15)') PINTERPCOORDS(9*(J2-1)+4-GLY_COUNT*3), &
     &                                               PINTERPCOORDS(9*(J2-1)+5-GLY_COUNT*3), &
     &                                               PINTERPCOORDS(9*(J2-1)+6-GLY_COUNT*3)
                               GLY_COUNT=GLY_COUNT +1
                            ELSE
                               WRITE(89,'(3G25.15)') PINTERPCOORDS(9*(J2-1)+1-GLY_COUNT*3), &
     &                                               PINTERPCOORDS(9*(J2-1)+2-GLY_COUNT*3), &
     &                                               PINTERPCOORDS(9*(J2-1)+3-GLY_COUNT*3)
                               WRITE(89,'(3G25.15)') PINTERPCOORDS(9*(J2-1)+4-GLY_COUNT*3), &
     &                                               PINTERPCOORDS(9*(J2-1)+5-GLY_COUNT*3), &
     &                                               PINTERPCOORDS(9*(J2-1)+6-GLY_COUNT*3)
                               WRITE(89,'(3G25.15)') PINTERPCOORDS(9*(J2-1)+7-GLY_COUNT*3), &
     &                                               PINTERPCOORDS(9*(J2-1)+8-GLY_COUNT*3), &
     &                                               PINTERPCOORDS(9*(J2-1)+9-GLY_COUNT*3)
                            ENDIF
                         ENDDO
                      ELSE
                         WRITE(89,'(3G25.15)') PINTERPCOORDS(1:NOPT)
                      ENDIF
                      CLOSE(89)
                   ENDIF
!                  DO J2=1,NMIN-1
!                     PRINT '(A,2I8,G20.10)','MIN1 MIN2 D=',NMIN,J2,MI(NMIN)%DATA%D(J2)
!                  ENDDO
                ELSE
                   WRITE(*,'(A,I7)') ' TRYCONNECT> FOUND OLD MINIMUM ',POSITION
                ENDIF
                NULLIFY(PINTERPCOORDS,PENERGY)
                DEALLOCATE(MINFOUND(I)%E,MINFOUND(I)%COORD)
             ENDDO
             RETURN ! ASSUMES THAT WE HAVE NO TS IF WE HAVE NEW MINIMA. PROBABLY OK.
          ENDIF

! SAVING NEW TS INTO TS RACK; OTHERWISE - FREE MEMORY IMMEDIATELY

          NTSOLD=NTS
          UNIQUE=0
          DO I=1,NTSFOUND
!              PRINT '(A,2G20.10)',' TRYCONNECT> TSFOUND(I)%E, MAXTSENERGY=',TSFOUND(I)%E, MAXTSENERGY
               AMIDEFAIL=.FALSE.
               IF (CHRMMT .AND. CHECKOMEGAT) &
                  CALL CHECKOMEGA(TSFOUND(I)%COORD,AMIDEFAIL)
                  CHIRALFAIL=.FALSE.
               IF (CHRMMT .AND. CHECKCHIRALT) &
                  CALL CHECKCHIRAL(TSFOUND(I)%COORD,CHIRALFAIL)
               IF (CHRMMT .AND. AMIDEFAIL) THEN
                  PRINT '(A,G20.10,A)',' TRYCONNECT> TRANSITION STATE WITH ENERGY ',TSFOUND(I)%E, &
  &                                   ' IGNORED, CIS-TRANS ISOMERISATION OF AN AMIDE BOND DETECTED.'
                  DEALLOCATE(TSFOUND(I)%E,TSFOUND(I)%COORD,TSFOUND(I)%EVALMIN,TSFOUND(I)%VECS)
               ELSEIF (CHRMMT .AND. CHIRALFAIL) THEN
                  PRINT '(A,G20.10,A)',' TRYCONNECT> TRANSITION STATE WITH ENERGY ',TSFOUND(I)%E, &
  &                                    ' IGNORED, INVERSION OF A CHIRAL CA CENTER DETECTED.'
                  DEALLOCATE(TSFOUND(I)%E,TSFOUND(I)%COORD,TSFOUND(I)%EVALMIN,TSFOUND(I)%VECS)
               ELSEIF (TSFOUND(I)%E.GT.MAXTSENERGY) THEN
                  PRINT '(A,G20.10,A)',' TRYCONNECT> TRANSITION STATE WITH ENERGY ',TSFOUND(I)%E,' IGNORED'
                  DEALLOCATE(TSFOUND(I)%E,TSFOUND(I)%COORD,TSFOUND(I)%EVALMIN,TSFOUND(I)%VECS)
!
! ALLOW REDOPATH TO ADD THE SAME TRANSITION STATE MORE THAN ONCE.
! FOR USE WITH DIFFERENT PUSHOFF AND BFGSSTEP VALUES IN CASE THE CONNECTION FAILS
! TO GIVE THE MINIMA PAIR THAT WE ACTUALLY WANT.
!
               ELSEIF ( ISNEWTS(TSFOUND(I)).OR.REDOPATH ) THEN
                  IF (NTS==TSRACKSIZE) CALL REALLOCATETSRACK
                  NTS=NTS+1; UNIQUE=UNIQUE+1
                  TS(NTS)%DATA%E => TSFOUND(I)%E
                  TS(NTS)%DATA%X => TSFOUND(I)%COORD
                  TS(NTS)%DATA%EVALMIN => TSFOUND(I)%EVALMIN
                  TS(NTS)%DATA%VECS => TSFOUND(I)%VECS
                  TS(NTS)%DATA%BAD=.FALSE.
                  NULLIFY(TSFOUND(I)%E,TSFOUND(I)%COORD,TSFOUND(I)%EVALMIN,TSFOUND(I)%VECS)
               ELSE
                  IF (NCONDONE==1) PRINT *, 'DISCARDED TS #',I
                  DEALLOCATE(TSFOUND(I)%E,TSFOUND(I)%COORD,TSFOUND(I)%EVALMIN,TSFOUND(I)%VECS)
               ENDIF
          ENDDO

!         CALL DUMPTS ! TS.XYZ FILE IS NOT USED FOR ANYTHING?

          ! PRINT INFO AS TO HOW MANY TS ARE ACTUALLY USEFUL
          IF (UNIQUE==NTSFOUND.AND..NOT.UNIQUE==0) THEN
               IF (NTSFOUND==1) THEN
                  IF (RERUN) THEN
                    WRITE(*,'(A)') ' TRYCONNECT> RERUNNING PATH FOR THIS TS'
                  ELSE
                    WRITE(*,'(A)') ' TRYCONNECT> TS APPEARS TO BE NEW'
                  ENDIF
               ELSE
                    WRITE(*,'(A)') ' TRYCONNECT> ALL OF TS FOUND APPEAR TO BE NEW'
               ENDIF
          ELSEIF (UNIQUE < NTSFOUND) THEN
               WRITE(CHR,'(I7)') UNIQUE 
               WRITE(*,'(1X,A)') TRIM(ADJUSTL(CHR))//' OF TS FOUND APPEAR TO BE NEW.'
          ELSEIF (UNIQUE ==0 .AND..NOT.NTSFOUND==0) THEN
               WRITE(*,'(1X,A)') ' TRYCONNECT> ALL OF TS FOUND ARE ALREADY KNOWN'
          ENDIF

          ! PATH RUN FOR ALL UNIQUE TS
          DO I=NTS-UNIQUE+1,NTS
               WRITE(CHR,'(I5)') I
               PRINT '(/1X,A)', '>>>>>  PATH RUN FOR TS '//TRIM(ADJUSTL(CHR))//' ...'
               ALLOCATE( QPLUS(NOPT),QMINUS(NOPT),EPLUS,EMINUS )
               CALL MKFNAMES(I,FILTH,FILTHSTR,ITSTRING,EOFSSTRING)
               EDUMMY=TS(I)%DATA%E
               TMPTS=TS(I)%DATA%X
               ! STRUCTURE IN TS(I)%DATA%X IS A STATIONARY POINT WHICH IS WHY WE DON'T NEED TO STORE G AND RMS FOR IT
               LGDUMMY(1:3*NATOMS)=0.0D0; RMS=0.0D0 ! WE MUST INITIALIZE THEM HERE, HOWEVER 
               NORERUN=.FALSE.
               IF (REDOPATH) THEN
!                 CALL MKFNAMES(NCONDONE,FILTH,FILTHSTR,ITSTRING,EOFSSTRING)
                  IF (REDOPATHXYZ) THEN
                     INQUIRE(FILE=TRIM(ADJUSTL(ITSTRING)),EXIST=EXISTS)
                     IF (EXISTS) THEN ! ALLOWS FOR RERUN WITH DIFFERENT ENERGY DIFFERENCE CRITERION FOR
                                      ! CONSECUTIVE FRAMES IN PATH WITHOUT REDOING ORIGINAL PATH
                        PRINT '(2A)',' TRYCONNECT> READING DATA FOR MINIMA FROM EXISTING FILE ',TRIM(ADJUSTL(ITSTRING))
                        NORERUN=.TRUE.
                     ENDIF
                  ENDIF
               ENDIF
               IF (.NOT.NORERUN) THEN
                 REDOKADD=.TRUE.
                 CALL PATH(TMPTS,EDUMMY,LGDUMMY,RMS,TS(I)%DATA%EVALMIN,TS(I)%DATA%VECS,  &
                    & .FALSE.,QPLUS,QMINUS,DEBUG,EDUMMY2,EPLUS,EMINUS, &
                    & TS(I)%DATA%SLENGTH,TS(I)%DATA%DISP,TS(I)%DATA%GAMMA,TS(I)%DATA%NTILDE,FRQSTS,FRQSPLUS, &
                    & FRQSMINUS,ITSTRING,EOFSSTRING,PATHFAILT)
                 QP(1:3*NATOMS)=QPLUS(1:3*NATOMS)
                 QM(1:3*NATOMS)=QMINUS(1:3*NATOMS)
                 REDOKADD=.FALSE.
               ELSE
                  OPEN(UNIT=89,FILE=ITSTRING,STATUS='OLD')
                  READ(89,*)
                  READ(89,*) DUMMYS, EPLUS
                  DO J1=1,NATOMS
                     READ(89,*) ZDUM,QPLUS(3*(J1-1)+1),QPLUS(3*(J1-1)+2),QPLUS(3*(J1-1)+3)
                  ENDDO
                  DO
                     READ(89,*,END=99)
                     READ(89,*) DUMMYS, EMINUS
                     DO J1=1,NATOMS
                        READ(89,*) ZDUM,QMINUS(3*(J1-1)+1),QMINUS(3*(J1-1)+2),QMINUS(3*(J1-1)+3)
                     ENDDO
                  ENDDO
99                CONTINUE
                  IF (DEBUG) PRINT '(A,G20.10)','EPLUS=',EPLUS
                  IF (DEBUG) PRINT '(A,G20.10)','EMINUS=',EMINUS
                  PRINT '(A,G20.10,A,G20.10)',' TRYCONNECT> E+=',EPLUS,'                      E-=',EMINUS
                  CLOSE(89)
               ENDIF
               DEALLOCATE(TS(I)%DATA%VECS)
               IF ((AMBERT.OR.NABT).AND.NOCISTRANS) THEN
                 IF(NOCISTRANSRNA) THEN
                   CALL CHECK_CISTRANS_RNA(QPLUS,NATOMS,ZSYM,GOODSTRUCTURE1)
                   CALL CHECK_CISTRANS_RNA(QMINUS,NATOMS,ZSYM,GOODSTRUCTURE2)
                   IF(.NOT.GOODSTRUCTURE1.OR..NOT.GOODSTRUCTURE2) THEN
                    PRINT '(A,G20.10,A)',' TRYCONNECT> TRANSITION STATE WITH ENERGY ',TS(I)%DATA%E, &
  &                                     ' IGNORED, CIS-TRANS ISOMERISATION DETECTED IN THE RNA RIBOSE RING.'
                    DEALLOCATE(TS(I)%DATA%EVALMIN)
                    DEALLOCATE(QPLUS,QMINUS,EPLUS,EMINUS)
                    TS(I)%DATA%BAD=.TRUE.
                    CYCLE
                   END IF
                 ELSE IF(NOCISTRANSDNA) THEN
                   CALL CHECK_CISTRANS_DNA(QPLUS,NATOMS,ZSYM,GOODSTRUCTURE1)
                   CALL CHECK_CISTRANS_DNA(QMINUS,NATOMS,ZSYM,GOODSTRUCTURE2)
                   IF(.NOT.GOODSTRUCTURE1.OR..NOT.GOODSTRUCTURE2) THEN
                    PRINT '(A,G20.10,A)',' TRYCONNECT> TRANSITION STATE WITH ENERGY ',TS(I)%DATA%E, &
  &                                     ' IGNORED, CIS-TRANS ISOMERISATION DETECTED IN THE DNA DEOXYRIBOSE RING.'
                    DEALLOCATE(TS(I)%DATA%EVALMIN)
                    DEALLOCATE(QPLUS,QMINUS,EPLUS,EMINUS)
                    TS(I)%DATA%BAD=.TRUE.
                    CYCLE
                   END IF
                 ELSE
                   CALL CHECK_CISTRANS_PROTEIN(MI(1)%DATA%X(1:3*NATOMS),NATOMS,GOODSTRUCTURE1,MINOMEGA,CISARRAY2)
                   CALL CHECK_CISTRANS_PROTEIN(QMINUS,NATOMS,GOODSTRUCTURE2,MINOMEGA,CISARRAY1)
                   CISARRAY1=CISARRAY1-CISARRAY2
                   GOODSTRUCTURE1=.TRUE.
                   DO J1=1,NATOMS
                    IF(CISARRAY1(J1)/=0) THEN
                      GOODSTRUCTURE1=.FALSE.
                      WRITE(*,'(A,I6)') ' TRYCONNECT> MINUS MINIMUM: CIS-TRANS ISOMERISATION '// &
  &                                                   'OF A PEPTIDE BOND DETECTED INVOLVING ATOM ', J1
                    END IF
                   END DO

                   CALL CHECK_CISTRANS_PROTEIN(QPLUS,NATOMS,GOODSTRUCTURE2,MINOMEGA,CISARRAY1)
                   CISARRAY1=CISARRAY1-CISARRAY2
                   GOODSTRUCTURE2=.TRUE.
                   DO J1=1,NATOMS
                    IF(CISARRAY1(J1)/=0) THEN
                      GOODSTRUCTURE2=.FALSE.
                      WRITE(*,'(A,I6)') ' TRYCONNECT> PLUS MINIMUM: CIS-TRANS ISOMERISATION '// &
  &                                                   'OF A PEPTIDE BOND DETECTED INVOLVING ATOM ', J1
                    END IF
                   END DO
                   IF(.NOT.GOODSTRUCTURE1.OR..NOT.GOODSTRUCTURE2) THEN
                      WRITE(*,'(A)') ' TRYCONNECT> CIS-TRANS ISOMERISATION OF A PEPTIDE BOND DETECTED '//&
  &                                                '(WRT. THE ORIGINAL STRUCTURE), REJECTING'
                    PRINT '(A,G20.10,A)',' TRYCONNECT> TRANSITION STATE WITH ENERGY ',TS(I)%DATA%E, &
  &                                     ' IGNORED, CIS-TRANS ISOMERISATION DETECTED IN ONE OR MORE PEPTIDE BONDS.'
                    DEALLOCATE(TS(I)%DATA%EVALMIN)
                    DEALLOCATE(QPLUS,QMINUS,EPLUS,EMINUS)
                    TS(I)%DATA%BAD=.TRUE.
                    CYCLE
                   END IF
                 END IF
               END IF
               IF (CHECKCHIRALT.AND.(AMBERT.OR.NABT)) THEN
                  CALL CHECK_CHIRALITY(QMINUS,NATOMS,GOODSTRUCTURE1)
                  CALL CHECK_CHIRALITY(QPLUS,NATOMS,GOODSTRUCTURE2)
                  IF (.NOT.GOODSTRUCTURE1.OR..NOT.GOODSTRUCTURE2) THEN
                    WRITE(*,'(A)') ' CONNECT> CHIRALITY INVERSION DETECTED IN AT LEAST ONE OF THE CARBON CENTRES, REJECTING'
                    DEALLOCATE(TS(I)%DATA%EVALMIN)
                    DEALLOCATE(QPLUS,QMINUS,EPLUS,EMINUS)
                    TS(I)%DATA%BAD=.TRUE.
                    CYCLE
                  ENDIF
               ENDIF

               AMIDEFAIL=.FALSE.
               IF (CHRMMT .AND. CHECKOMEGAT) &
                  CALL CHECKOMEGA(QPLUS,AMIDEFAIL)
               IF (CHRMMT .AND. CHECKOMEGAT .AND. .NOT.AMIDEFAIL) &
                  CALL CHECKOMEGA(QMINUS,AMIDEFAIL)
               CHIRALFAIL=.FALSE.
               IF (CHRMMT .AND. CHECKCHIRALT) &
                  CALL CHECKCHIRAL(QPLUS,CHIRALFAIL)
               IF (CHRMMT .AND. CHECKCHIRALT .AND. .NOT.CHIRALFAIL) &
                  CALL CHECKCHIRAL(QMINUS,CHIRALFAIL)
               IF (CHRMMT .AND. AMIDEFAIL) THEN
                  PRINT '(A,G20.10,A)',' TRYCONNECT> TRANSITION STATE WITH ENERGY ',TS(I)%DATA%E, &
  &                                     ' IGNORED, CIS-TRANS ISOMERISATION OF AN AMIDE-BOND DETECTED.'
                  DEALLOCATE(TS(I)%DATA%EVALMIN)
                  DEALLOCATE(QPLUS,QMINUS,EPLUS,EMINUS)
                  TS(I)%DATA%BAD=.TRUE.
                  CYCLE
               ELSEIF (CHRMMT .AND. CHIRALFAIL) THEN
                  PRINT '(A,G20.10,A)',' TRYCONNECT> TRANSITION STATE WITH ENERGY ',TS(I)%DATA%E, &
  &                                        ' IGNORED, INVERSION OF A CHIRAL CA CENTER DETECTED.'
                  DEALLOCATE(TS(I)%DATA%EVALMIN)
                  DEALLOCATE(QPLUS,QMINUS,EPLUS,EMINUS)
                  TS(I)%DATA%BAD=.TRUE.
                  CYCLE
               ELSEIF (PATHFAILT) THEN
                    DEALLOCATE(TS(I)%DATA%EVALMIN)
                    DEALLOCATE(QPLUS,QMINUS,EPLUS,EMINUS)
                    TS(I)%DATA%BAD=.TRUE.
                    CYCLE
               ELSEIF (TS(I)%DATA%E-MIN(EPLUS,EMINUS).GT.MAXMAXBARRIER) THEN
                  PRINT '(2(A,G20.10))',' TRYCONNECT> TRANSITION STATE WITH ENERGY ',TS(I)%DATA%E,' IGNORED, MAXIMUM BARRIER=', &
  &                                      TS(I)%DATA%E-MIN(EPLUS,EMINUS)
                  DEALLOCATE(TS(I)%DATA%EVALMIN)
                  DEALLOCATE(QPLUS,QMINUS,EPLUS,EMINUS)
                  TS(I)%DATA%BAD=.TRUE.
!                 STOP !!! DJW
                  CYCLE
               ELSEIF (TS(I)%DATA%E-MAX(EPLUS,EMINUS).GT.MAXBARRIER) THEN
                  PRINT '(2(A,G20.10))',' TRYCONNECT> TRANSITION STATE WITH ENERGY ',TS(I)%DATA%E,' IGNORED, MINIMUM BARRIER=', &
  &                                      TS(I)%DATA%E-MAX(EPLUS,EMINUS)
                  DEALLOCATE(TS(I)%DATA%EVALMIN)
                  DEALLOCATE(QPLUS,QMINUS,EPLUS,EMINUS)
                  TS(I)%DATA%BAD=.TRUE.
                  CYCLE
               ELSE
                  IF (UNRST) CALL TESTSAMEMIN(EPLUS,QPLUS,EMINUS,QMINUS,PATHFAILT)
                  IF (PATHFAILT) THEN
                      DEALLOCATE(TS(I)%DATA%EVALMIN)
                      DEALLOCATE(QPLUS,QMINUS,EPLUS,EMINUS)
                      TS(I)%DATA%BAD=.TRUE.
                      CYCLE 
                  ENDIF
               ENDIF

333            CONTINUE
!              IF (I.EQ.195) DEBUG=.TRUE.
!              PRINT *,'TRYCONNECT>  HERE I=',I
!              PRINT *,'TRYCONNECT>  PLUS MIN'
               CALL ISNEWMIN(EPLUS,QPLUS,MINPLUSPOS,PLUSNEW,REDOPATH,PERMUTE,INVERT,INDEX,IMATCH)
!              PRINT *,'TRYCONNECT>  MINUS MIN'
               CALL ISNEWMIN(EMINUS,QMINUS,MINMINUSPOS,MINUSNEW,REDOPATH,PERMUTE,INVERT,INDEX,IMATCH)
!              IF (I.EQ.195) THEN
!                 PRINT *,'CALLING ISNEWMIN AGAIN FOR BOTH MINIMA:'
!                 PRINT *,'TRYCONNECT>  PLUS MIN'
!                 CALL ISNEWMIN(EPLUS,QPLUS,MINPLUSPOS,PLUSNEW,REDOPATH,PERMUTE,INVERT,INDEX,IMATCH)
!                 PRINT *,'TRYCONNECT>  MINUS MIN'
!                 CALL ISNEWMIN(EMINUS,QMINUS,MINMINUSPOS,MINUSNEW,REDOPATH,PERMUTE,INVERT,INDEX,IMATCH)
!                 STOP
!              ENDIF
!
! THE ABOVE CHECK WILL NOT DISCOVER THE CASE WHEN THE PLUS MINIMUM IS NEW, AND IS THE SAME
! AS THE MINUS MINIMUM.
!
               IF (PLUSNEW.AND.MINUSNEW) THEN
                  IF (ABS(EMINUS-EPLUS) < EDIFFTOL) THEN
                     CALL MINPERMDIST(QMINUS,QPLUS,NATOMS,DEBUG,PARAM1,PARAM2,PARAM3,BULKT,TWOD,D,DIST2,RIGIDBODY,RMAT)
                     IF (D<GEOMDIFFTOL) THEN
                        MINUSNEW=.FALSE.
                        MINMINUSPOS=MINPLUSPOS
                     ENDIF
                  ENDIF
               ENDIF

               EDUMMY=TS(I)%DATA%E
               TMPTS=TS(I)%DATA%X
               IF (DUMPALLPATHS) CALL MAKEALLPATHINFO(TMPTS,QPLUS,QMINUS,EDUMMY,EPLUS,EMINUS,FRQSTS,FRQSPLUS,FRQSMINUS)
               
               WRITE(CHR,'(I7)') MINPLUSPOS
               WRITE(CHR2,'(I7)') MINMINUSPOS
               100 FORMAT (8X,A,T65,A)
               IF ( .NOT.PLUSNEW .AND. .NOT.MINUSNEW ) THEN
                    WRITE(*,100) 'KNOWN (#'//TRIM(ADJUSTL(CHR))//')','KNOWN (#'//TRIM(ADJUSTL(CHR2))//')'
                    CALL NEWCONNECTION(MINPLUSPOS,MINMINUSPOS,I)
                    DEALLOCATE(QPLUS,QMINUS,EPLUS,EMINUS)
                    CALL SETDISTANCE(MINPLUSPOS,MINMINUSPOS,0.0D0)
                    IF (INTERPCOSTFUNCTION) CALL SETINTERP(MINPLUSPOS,MINMINUSPOS,0.0D0)
               ELSE IF ( PLUSNEW .AND. MINUSNEW ) THEN
                    WRITE(CHR2,'(I7)') MINPLUSPOS+1
                    WRITE(*,100) '*NEW* (PLACED IN '//TRIM(ADJUSTL(CHR))//')','*NEW* (PLACED IN '//TRIM(ADJUSTL(CHR2))//')'

                    CALL ADDNEWMIN(EPLUS,QPLUS)
                    CALL ADDNEWMIN(EMINUS,QMINUS)
                    CALL NEWCONNECTION(MINPLUSPOS,MINPLUSPOS+1,I)
                    MI(MINPLUSPOS+1)%DATA%D(MINPLUSPOS)=0.0D0
                    IF (INTERPCOSTFUNCTION) MI(MINPLUSPOS+1)%DATA%INTERP(MINPLUSPOS)=0.0D0
               ELSE IF ( PLUSNEW .OR. MINUSNEW ) THEN
                    IF ( PLUSNEW ) THEN
                         WRITE(*,100) '*NEW* (PLACED IN '//TRIM(ADJUSTL(CHR))//')','KNOWN (#'//TRIM(ADJUSTL(CHR2))//')'
                         CALL ADDNEWMIN(EPLUS,QPLUS)
                         DEALLOCATE(EMINUS,QMINUS)
                    ELSE
                         WRITE(*,100) 'KNOWN (#'//TRIM(ADJUSTL(CHR))//')','*NEW* (PLACED IN '//TRIM(ADJUSTL(CHR2))//')'
                         DEALLOCATE(EPLUS,QPLUS)
                         CALL ADDNEWMIN(EMINUS,QMINUS)
                    ENDIF
                    CALL NEWCONNECTION(MINPLUSPOS,MINMINUSPOS,I)
                    CALL SETDISTANCE(MINPLUSPOS,MINMINUSPOS,0.0D0)
                    IF (INTERPCOSTFUNCTION) CALL SETINTERP(MINPLUSPOS,MINMINUSPOS,0.0D0)
               ENDIF
          ENDDO
!
! ALLOW FOR NEW PATHWAY CALCULATION WITH DIFFERENT PUSHOFF AND MAXBFGS
!
         IF (REDOPATH) THEN
            CALL MINPERMDIST(QP,MIN1REDO,NATOMS,DEBUG,PARAM1,PARAM2,PARAM3,BULKT,TWOD,D,DIST2,RIGIDBODY,RMAT)
            DIST1P=D

            CALL MINPERMDIST(QM,MIN1REDO,NATOMS,DEBUG,PARAM1,PARAM2,PARAM3,BULKT,TWOD,D,DIST2,RIGIDBODY,RMAT)
            DIST1M=D

            CALL MINPERMDIST(QM,MIN2REDO,NATOMS,DEBUG,PARAM1,PARAM2,PARAM3,BULKT,TWOD,D,DIST2,RIGIDBODY,RMAT)
            DIST2M=D

            CALL MINPERMDIST(QP,MIN2REDO,NATOMS,DEBUG,PARAM1,PARAM2,PARAM3,BULKT,TWOD,D,DIST2,RIGIDBODY,RMAT)
            DIST2P=D

            PATHFAILED=.FALSE.
            IF ((DIST1P.GT.GEOMDIFFTOL).AND.(DIST1M.GT.GEOMDIFFTOL)) THEN
               PRINT '(A)',' TRYCONNECT> PATH FAILED TO MATCH FIRST MINIMUM'
               PATHFAILED=.TRUE.
            ENDIF
            IF ((DIST2P.GT.GEOMDIFFTOL).AND.(DIST2M.GT.GEOMDIFFTOL)) THEN
               PRINT '(A)',' TRYCONNECT> PATH FAILED TO MATCH SECOND MINIMUM'
               PATHFAILED=.TRUE.
            ENDIF
            IF (PATHFAILED) THEN
               NC1=NC1+1
               IF (NC1.GT.2*NREDOPATHTRIES1) THEN
                  NC2=NC2+1
                  NC1=0
               ENDIF
               IF (NREDOPATHTRIES1.EQ.0) THEN
                  PUSHOFF=SAVEPUSHOFF
               ELSEIF (NC1.GT.NREDOPATHTRIES1) THEN
                  PUSHOFF=SAVEPUSHOFF+(NC1-NREDOPATHTRIES1)*(REDOSTRETCH*SAVEPUSHOFF-SAVEPUSHOFF)/NREDOPATHTRIES1
               ELSE
                  PUSHOFF=SAVEPUSHOFF-NC1*(SAVEPUSHOFF-SAVEPUSHOFF/REDOSTRETCH)/NREDOPATHTRIES1
               ENDIF
               IF (NREDOPATHTRIES2.EQ.0) THEN
                  MAXBFGS=SAVEMAXBFGS
               ELSEIF (NC2.GT.NREDOPATHTRIES2) THEN
                  MAXBFGS=SAVEMAXBFGS+(NC2-NREDOPATHTRIES2)*(REDOSTRETCH*SAVEMAXBFGS-SAVEMAXBFGS)/NREDOPATHTRIES2
               ELSE
                  MAXBFGS=SAVEMAXBFGS-NC2*(SAVEMAXBFGS-SAVEMAXBFGS/REDOSTRETCH)/NREDOPATHTRIES2
               ENDIF
               IF (NC2.LE.2*NREDOPATHTRIES2) THEN
                  PRINT '(2(A,F15.5))',' TRYCONNECT> REDO PATH WITH PUSHOFF=',PUSHOFF,' MAXBFGS=',MAXBFGS
                  RERUN=.TRUE.
                  GOTO 10
               ENDIF
            ENDIF
          ENDIF

          RERUN=.FALSE.
          PUSHOFF=SAVEPUSHOFF
          MAXBFGS=SAVEMAXBFGS

     END SUBROUTINE TRYCONNECT

END MODULE TRYCONNECTMODULE
