C   OPTIM: A PROGRAM FOR OPTIMIZING GEOMETRIES AND CALCULATING REACTION PATHWAYS
C   COPYRIGHT (C) 1999-2006 DAVID J. WALES
C   THIS FILE IS PART OF OPTIM.
C
C   OPTIM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C   IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C   THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C   (AT YOUR OPTION) ANY LATER VERSION.
C
C   OPTIM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
C   BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
C   GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C   YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C   ALONG WITH THIS PROGRAM; IF NOT, WRITE TO THE FREE SOFTWARE
C   FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330, BOSTON, MA  02111-1307  USA
C
C JMC HACKED TO WORK IN INTERNAL COORDINATES (WITH UNRES)
C NOPT WILL BE SET TO THE VALUE FOR CARTESIANS, NINTS IS FOR INTERNALS
C DUMMY3, COORDS, VEC WILL BE IN INTERNALS
C GRAD1,GRAD2 WILL BE RETURNED FROM POTENTIAL IN INTERNALS
C THEREFORE ONLY THING THAT SHOULD REALLY BE AFFECTED IS THE CALL TO POTENTIAL 

      SUBROUTINE INTSECDIAG(VEC,COORDS,ENERGY,GL,DIAG,GTEST,XRMS)
      USE COMMONS
      USE KEY
      IMPLICIT NONE

      INTEGER J1
      LOGICAL GTEST, FPLUS, FMINUS
      DOUBLE PRECISION DUMMY3(NINTS), DIFF, VEC(3*NATOMS), COORDS(3*NATOMS), DIAG2, DIAG3,
     1                 EPLUS,EMINUS,ENERGY,GRAD1(3*NATOMS),LOCALV(NINTS),PROJ,
     2                 RMS,DIAG,XRMS,GL(3*NATOMS),GRAD2(3*NATOMS), VECL, ZETA, DUMCART(3*NATOMS)

      DIFF=1.0D-3
      IF (UNRST) DIFF=5.0D-4

      LOCALV(1:NINTS)=VEC(1:NINTS)
      CALL VECNORM(LOCALV(1:NINTS),NINTS)

C JMC      IF (NFREEZE.LT.3) CALL ORTHOGOPT(VEC,COORDS,.TRUE.)
C TO ORTHOGONALISE THE DISPLACEMENT TO TRANSLATIONS AND ROTATIONS

      DUMCART=1.0D0

C     VECL=0.0D0
C     DO J1=1,NINTS
C        VECL=VECL+VEC(J1)**2
C     ENDDO
C     ZETA=DIFF/SQRT(VECL)

      VECL=1.0D0
      ZETA=DIFF

      DUMMY3(1:NINTS)=COORDS(1:NINTS)+ZETA*LOCALV(1:NINTS)

C     WRITE(*,'(6F15.5)') (DUMMY3(J1),J1=1,NINTS)

      IF (UNRST) THEN
         CALL VAR_TO_GEOM(NINTS,DUMMY3)
         CALL CHAINBUILD
      END IF
      CALL POTENTIAL(DUMCART,EPLUS,GRAD1,GTEST,.FALSE.,RMS,.FALSE.,.FALSE.)

      DUMMY3(1:NINTS)=COORDS(1:NINTS)-ZETA*LOCALV(1:NINTS)

C     WRITE(*,'(6F15.5)') (DUMMY3(J1),J1=1,NINTS)

      IF (UNRST) THEN
         CALL VAR_TO_GEOM(NINTS,DUMMY3)
         CALL CHAINBUILD
      END IF
C JMC REMEMBER FOR UNRES, PASSING OF COORDS ARRAY (FIRST ARG) IS IRRELEVANT...
      CALL POTENTIAL(DUMCART,EMINUS,GRAD2,GTEST,.FALSE.,RMS,.FALSE.,.FALSE.)

      DIAG=(EPLUS+EMINUS-2.0D0*ENERGY)/((ZETA**2)*VECL) ! JMC DIAG IS LAMBDA*VECL (BUT VECL=1.0D0 ANYWAY...)

      DIAG2=0.0D0
      DO J1=1,NINTS
         DIAG2=DIAG2+(GRAD1(J1)-GRAD2(J1))*LOCALV(J1)
C        WRITE(*,'(A,I4,4F20.10)') 'J1,GRAD1,GRAD2,LOCALV,DIAG2=',J1,GRAD1(J1),GRAD2(J1),LOCALV(J1),DIAG2
      ENDDO
      DIAG2=DIAG2/(2.0D0*ZETA)
      DIAG3=2*(DIAG-DIAG2/2)
C     WRITE(*,'(A,6F20.10)') 'D,D2,D3,E+,E-,E=',DIAG,DIAG2,DIAG3,EPLUS,EMINUS,ENERGY
C     IF (.NOT.GTEST) WRITE(*,'(A,6F20.10)') 'D,D2,D3,E+,E-,E=',DIAG,DIAG2,DIAG3,EPLUS,EMINUS,ENERGY
C
C  ALTHOUGH DIAG3 IS A MORE ACCURATE ESTIMATE OF THE DIAGONAL SECOND DERIVATIVE, IT
C  CANNOT BE DIFFERENTIATED ANALYTICALLY.
C
      IF (GTEST) THEN
C        DO J1=1,NINTS
C THIS IS FROM EQN 6.20 IN CHAPTER 6 OF 'THE BOOK'...
C           GL(J1)=(GRAD1(J1)-GRAD2(J1))/(ZETA*VECL**2)-2.0D0*DIAG*LOCALV(J1)/VECL**2
C           WRITE(*,'(A,I4,4G16.7)') 'J1,GRAD1,GRAD2,VEC,GL=',J1,GRAD1(J1),GRAD2(J1),LOCALV(J1),GL(J1)
C        ENDDO
         GL(1:NINTS)=(GRAD1(1:NINTS)-GRAD2(1:NINTS))/(ZETA*VECL**2)-2.0D0*DIAG*LOCALV(1:NINTS)/VECL**2
C JMC SO GL IS VECL*DLAMBDA/DX...
C TO ORTHOGONALISE THE **GRADIENT** TO TRANSLATIONS AND ROTATIONS (OBVIOUSLY NOT NECESSARY...)
C        CALL ORTHOGOPT(GL,COORDS,.FALSE.)

C
C  PROJECT OUT ANY COMPONENT OF THE GRADIENT ALONG LOCALV (WHICH IS A UNIT VECTOR).
C
         PROJ=0.0D0
         DO J1=1,NINTS
            PROJ=PROJ+GL(J1)*LOCALV(J1)
         ENDDO
         DO J1=1,NINTS 
            GL(J1)=GL(J1)-PROJ*LOCALV(J1)
         ENDDO

         XRMS=0.0D0
         DO J1=1,NINTS
            XRMS=XRMS+GL(J1)**2
         ENDDO
         XRMS=DSQRT(XRMS/NINTS)
         IF (DEBUG) WRITE(*,'(A,3G15.5,3G20.12,G10.3)') 'D,D2,D3,E+,E-,E,RMS=',DIAG,DIAG2,DIAG3,EPLUS,EMINUS,ENERGY,XRMS
         IF (DEBUG) WRITE(*,'(A,G20.10)') 'PREDICTED GRADIENT COMPONENT=',(EPLUS-EMINUS)/(2*ZETA)
C        WRITE(*,'(A,5G20.10)') 'D,E+,E-,E,RMS=',DIAG,EPLUS,EMINUS,ENERGY,XRMS
      ENDIF
CC
CC  PROJECT OUT ANY COMPONENT OF THE GRADIENT ALONG LOCALV (WHICH IS A UNIT VECTOR).
CC
C      PROJ=0.0D0
C      DO J1=1,NINTS
C         PROJ=PROJ+GL(J1)*LOCALV(J1)
C      ENDDO
C      DO J1=1,NINTS
C         GL(J1)=GL(J1)-PROJ*LOCALV(J1)
C      ENDDO

      RETURN
      END
