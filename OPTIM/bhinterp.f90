!   OPTIM: A PROGRAM FOR OPTIMIZING GEOMETRIES AND CALCULATING REACTION PATHWAYS
!   COPYRIGHT (C) 1999-2006 DAVID J. WALES
!   THIS FILE IS PART OF OPTIM.
!   
!   OPTIM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
!   IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
!   THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
!   (AT YOUR OPTION) ANY LATER VERSION.
!   
!   OPTIM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
!   BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
!   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
!   GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
!   
!   YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
!   ALONG WITH THIS PROGRAM; IF NOT, WRITE TO THE FREE SOFTWARE
!   FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330, BOSTON, MA  02111-1307  USA
!
!  BHINTERP FINDS A LOCAL MINIMUM BETWEEN TWO END POINT MINIMA USING
!  BASIN-HOPPING GLOBAL OPTIMISATION BASED ON THE ACTUAL PE PLUS THE
!  ENERGY OF TWO SRINGS CONNECTED TO CSTART AND CFINISH
!  ASSUME WE ONLY USE THE LBFGS MINIMISER.
!  ALLOW A DIFFERENT FORCE CONSTANT, BHK, FROM NEB PHASE.
!
SUBROUTINE BHINTERP(CSTART,CFINISH,NCOORDS,NATOMS,INTERPCOORDS,SUCCESS,DSTART,DFINISH,FINALENERGY,ESTART,EFINISH,DENDPT)
USE KEY,ONLY : BHSTEPS, BHCONV, BHTEMP, BHACCREJ, DEBUG, MUPDATE, BULKT, TWOD, RIGIDBODY, AMBER, &
  &            BHK, BFGSSTEPS, BHMAXENERGY, GEOMDIFFTOL, EDIFFTOL, PERMDIST, GMAX, BHSFRAC, AMBERT, NABT, &
  &  BHINTERPUSELOWEST, BHCHECKENERGYT, BHSTEPSMIN, CLOSESTALIGNMENT, BHDEBUG, BHSTEPSIZE
USE MODCHARMM,ONLY : CHRMMT, ICINTERPT, CHECKOMEGAT,CHECKCHIRALT,INTMINT,NOCISTRANS,MINOMEGA
USE MODAMBER9, ONLY : NOCISTRANSRNA, NOCISTRANSDNA, GOODSTRUCTURE1,GOODSTRUCTURE2,CISARRAY1,&
CISARRAY2, LENIC, NICTOT, AMBERICT, AMBSTEPT, NPHIA, NPHIH, AMBPERTT
USE PORFUNCS
USE COMMONS,ONLY: PARAM1,PARAM2,PARAM3,ZSYM
USE MODEFOL
USE SPFUNCTS, ONLY : DUMPCOORDS
IMPLICIT NONE
INTEGER, INTENT(IN) :: NCOORDS
DOUBLE PRECISION CSTART(NCOORDS), CFINISH(NCOORDS)
DOUBLE PRECISION COORDS(NCOORDS), VNEW(NCOORDS), COORDSO(NCOORDS), DSTART, DFINISH, RMAT(3,3), ESTRING, ESPREV, RANDOM, DPRAND, &
  &              BESTCOORDS(NCOORDS), EREAL, RMS2, P0, ETOTAL, EBEST, EPREV, RMS, ENERGY, DELTAX(NCOORDS)
DOUBLE PRECISION INTERPCOORDS(NCOORDS), FINALENERGY, SFRAC, DSTARTSAVE, DFINISHSAVE, ESTART, EFINISH, SLIMIT, FLIMIT
DOUBLE PRECISION DIST, DIST2, GMAXSAVE, DENDPT
DOUBLE PRECISION,DIMENSION(:), ALLOCATABLE:: PHI_START, PHI_FINISH
INTEGER ITDONE, NSUCCESS, NFAIL, NSUCCESST, NFAILT, NATOMS, J1, J2, ISTAT, K, NSTEPS, NBISECT, MAXBISECT, NTRY, NCOUNT
LOGICAL MFLAG, ATEST, SUCCESS, PTEST, HITS, HITF, CHIRALFAIL, AMIDEFAIL, EXITBHRUN
LOGICAL KNOWE, KNOWG, KNOWH
COMMON /KNOWN/ KNOWE, KNOWG, KNOWH

! 
! CALCULATE INITIAL ENERGY
!
IF (CHRMMT.AND.INTMINT) THEN
   PRINT '(A)','BHINTERP> CHARMM INTERNAL COODINATE MINIMISATION NOT ALLOWED WITH BHINTERP'
   STOP
ENDIF
MAXBISECT=5
NBISECT=0
NTRY=0
NCOUNT=1
SLIMIT=1.0D0
FLIMIT=0.0D0
SFRAC=BHSFRAC ! BHSFRAC IS THE FIXED VALUE SPECIFIED ON THE BHINTERP LINE
HITS=.FALSE.
HITF=.FALSE.
1 CONTINUE
! NSTEPS=100
! DO J1=1,NSTEPS-1

IF (CLOSESTALIGNMENT) THEN

   WRITE(*,*) 'CSTART(1) BEFORE ALIGNMENT', CSTART(1)
   WRITE(*,*) 'CFINISH(1) BEFORE ALIGNMENT', CFINISH(1)
   CALL MINPERMDIST(CSTART,CFINISH,NATOMS,DEBUG,PARAM1,PARAM2,PARAM3,BULKT,TWOD,DIST,DIST2,RIGIDBODY,RMAT)
   DSTART=DIST
   WRITE(*,*) 'CSTART(1) AFTER ALIGNMENT', CSTART(1)
   WRITE(*,*) 'CFINISH(1) AFTER ALIGNMENT', CFINISH(1)
   WRITE(*,*) 'DISTANCE=', DIST

   STOP
ENDIF


! SFRAC=(J1*1.0D0)/NSTEPS
IF(BHDEBUG) PRINT '(A,F8.3)',' BHINTERP> START INTERPOLATION, SFRAC= ',SFRAC
10 CONTINUE
IF (BULKT) THEN
   DO K=1,NATOMS
      DELTAX(3*(K-1)+1)=CFINISH(3*(K-1)+1) - CSTART(3*(K-1)+1) &
  &       -PARAM1*NINT((CFINISH(3*(K-1)+1) - CSTART(3*(K-1)+1))/PARAM1)
      DELTAX(3*(K-1)+2)=CFINISH(3*(K-1)+2) - CSTART(3*(K-1)+2) &
  &       -PARAM2*NINT((CFINISH(3*(K-1)+2) - CSTART(3*(K-1)+2))/PARAM2)
      DELTAX(3*(K-1)+3)=CFINISH(3*(K-1)+3) - CSTART(3*(K-1)+3) &
  &       -PARAM3*NINT((CFINISH(3*(K-1)+3) - CSTART(3*(K-1)+3))/PARAM3)
   ENDDO
   COORDS(1:NCOORDS)=SFRAC*CSTART(1:NCOORDS)+(1.0D0-SFRAC)*DELTAX(1:NCOORDS)
ELSE
   COORDS(1:NCOORDS)=SFRAC*CSTART(1:NCOORDS)+(1.0D0-SFRAC)*CFINISH(1:NCOORDS)
   IF(CHRMMT.AND.ICINTERPT) CALL ICINTERPOL(COORDS,CSTART,CFINISH,SFRAC)
   IF ((AMBERT.OR.NABT).AND.AMBERICT) THEN
!   IF (AMBERT.AND.ICINTERPT) THEN
      PRINT*, "AMBER INTERNAL COORDINATE INTERPOLATION"
      IF (.NOT.ALLOCATED(NICTOT)) THEN
          CALL SETDIHEAM() 
      ENDIF
      CALL TAKESTEPAMDIHED(COORDS, CSTART, CFINISH,SFRAC) !MSB50
   ENDIF
ENDIF
IF(BHDEBUG) CALL DUMPCOORDS(COORDS, 'MIDPOINT.XYZ', .FALSE.)
!BS360
IF (CHRMMT) THEN
   AMIDEFAIL=.FALSE.
   IF (CHECKOMEGAT) THEN
      CALL CHECKOMEGA(COORDS,AMIDEFAIL)
      IF(BHDEBUG) PRINT '(A,L5)','           INTERPOLATED GEOMETRY: AMIDEFAIL  = ',AMIDEFAIL
   ENDIF
   CHIRALFAIL=.FALSE.
   IF (CHECKCHIRALT) THEN
      CALL CHECKCHIRAL(COORDS,CHIRALFAIL)
      IF(BHDEBUG) PRINT '(A,L5)','           INTERPOLATED GEOMETRY: CHIRALFAIL = ',CHIRALFAIL
   ENDIF
   IF (CHIRALFAIL.OR.AMIDEFAIL) THEN
       NTRY=NTRY+1
      SFRAC=BHSFRAC+(-1.D0)**NTRY*NCOUNT*0.05D0
      IF ((SFRAC.LE.0).OR.(SFRAC.GE.1.D0)) THEN
         PRINT *,' BHINTERP> COULD NOT FIND ACCEPTABLE INTERPOLATED MINIMUM'
         RETURN
      ENDIF
      IF(MOD(NTRY,2).EQ.0) NCOUNT=NCOUNT+1
      PRINT '(A,F8.3)','BHINTERP> RETRY INTERPOLATION, SFRAC= ',SFRAC
      GOTO 10
   ENDIF
ENDIF

KNOWE=.FALSE.
PTEST=DEBUG

! WRITE(99,*) NATOMS
! WRITE(99,'(A)') 'START:'
! DO K=1,NATOMS
!    WRITE(99,'(A,3G20.10)') 'LA ',CSTART(3*(K-1)+1),CSTART(3*(K-1)+2),CSTART(3*(K-1)+3)
! ENDDO
! WRITE(99,*) NATOMS
! WRITE(99,'(A)') 'FINISH:'
! DO K=1,NATOMS
!    WRITE(99,'(A,3G20.10)') 'LA ',CFINISH(3*(K-1)+1),CFINISH(3*(K-1)+2),CFINISH(3*(K-1)+3)
! ENDDO
! WRITE(99,*) NATOMS
! WRITE(99,'(A)') 'INTERP:'
! DO K=1,NATOMS
!    WRITE(99,'(A,3G20.10)') 'LA ',COORDS(3*(K-1)+1),COORDS(3*(K-1)+2),COORDS(3*(K-1)+3)
! ENDDO

GMAXSAVE=GMAX; GMAX=BHCONV ! MYLBFGS NOW USES GMAX SO THAT WE CAN CHANGE THIS PARAMETER VIA CHANGEP
CALL MYLBFGS(NCOORDS,MUPDATE,COORDS,.FALSE.,MFLAG,ENERGY,RMS2,EREAL,RMS,BFGSSTEPS, &
     &                   .TRUE.,ITDONE,PTEST,VNEW,.TRUE.,.FALSE.)
GMAX=GMAXSAVE
!BS360
IF (CHRMMT) THEN
   AMIDEFAIL=.FALSE.
   IF (CHECKOMEGAT) THEN
      CALL CHECKOMEGA(COORDS,AMIDEFAIL)
      IF(BHDEBUG) PRINT '(A,L5)','           MINIMISED INTERPOLATED GEOMETRY: AMIDEFAIL  = ',AMIDEFAIL
   ENDIF
   CHIRALFAIL=.FALSE.
   IF (CHECKCHIRALT) THEN
      CALL CHECKCHIRAL(COORDS,CHIRALFAIL)
      IF(BHDEBUG) PRINT '(A,L5)','           MINIMISED INTERPOLATED GEOMETRY: CHIRALFAIL = ',CHIRALFAIL
   ENDIF
   IF (CHIRALFAIL.OR.AMIDEFAIL) THEN
      NTRY=NTRY+1
      SFRAC=BHSFRAC+(-1.D0)**NTRY*NCOUNT*0.05D0
      IF ((SFRAC.LE.0).OR.(SFRAC.GE.1.D0)) THEN
         PRINT *,'BHINTERP> COULD NOT FIND ACCEPTABLE INTERPOLATED MINIMUM'
         RETURN
      ENDIF
      IF(MOD(NTRY,2).EQ.0) NCOUNT=NCOUNT+1
      PRINT '(A,F8.3)','BHINTERP> RETRY INTERPOLATION, SFRAC= ',SFRAC
      GOTO 10
   ENDIF
ENDIF

!MSB50 CHANGED ORDER CSTART, COORDS BECAUSE THIS IS ONLY FOR DISTANCE SO SHOULDN'T MATTER
CALL MINPERMDIST(CSTART,COORDS,NATOMS,DEBUG,PARAM1,PARAM2,PARAM3,BULKT,TWOD,DIST,DIST2,RIGIDBODY,RMAT)
DSTART=DIST
CALL MINPERMDIST(CFINISH,COORDS,NATOMS,DEBUG,PARAM1,PARAM2,PARAM3,BULKT,TWOD,DIST,DIST2,RIGIDBODY,RMAT)
DFINISH=DIST

ESPREV=0.5D0*BHK*(DSTART**2+DFINISH**2)
! PRINT '(A,5G18.8,I8)','EREAL,ESPREV,DS,DF,SFRAC,ITDONE=',EREAL,ESPREV,DSTART,DFINISH,SFRAC,ITDONE

IF (.NOT.MFLAG) THEN
   PRINT '(2(A,G20.10),A,I8)','BHINTERP> WARNING - INITIAL QUENCH FAILED TO CONVERGE, ENERGY=',EREAL, &
  &  ' SPRING ENERGY=',ESPREV,' LBFGS STEPS=',ITDONE
   PRINT '(A,2G15.5)',' BHINTERP> INITIAL DISTANCES: ',DSTART,DFINISH
ENDIF
IF (BHDEBUG) PRINT '(2(A,G20.10),A,I8)',' BHINTERP> INITIAL ENERGY=',EREAL,' SPRING ENERGY=',ESPREV,' LBFGS STEPS=',ITDONE
IF (BHDEBUG) PRINT '(A,2G15.5)',' BHINTERP> INITIAL DISTANCES: ',DSTART,DFINISH
!
! CHECK FOR SUSPICOUSLY SMALL DISTANCES, WHICH MIGHT CONVERGE TO AN END POINT IF FURTHER MINIMISED
!
IF (MIN(DSTART,DFINISH).LT.1.1D0) THEN
   IF (BHDEBUG) PRINT '(A,G20.10)',' BHINTERP> ONE OF THE INITIAL DISTANCES IS SUSPICIOUSLY SMALL: REOPTIMISE'
   DSTARTSAVE=DSTART; DFINISHSAVE=DFINISH
   GMAXSAVE=GMAX; GMAX=BHCONV
   NCOUNT=0
   DO WHILE (GMAX.GT.GMAXSAVE) 
      GMAX=GMAX/10.0D0
      CALL MYLBFGS(NCOORDS,MUPDATE,COORDS,.FALSE.,MFLAG,ENERGY,RMS2,EREAL,RMS,BFGSSTEPS, &
     &                      .TRUE.,ITDONE,PTEST,VNEW,.TRUE.,.FALSE.)
      CALL MINPERMDIST(COORDS,CSTART,NATOMS,DEBUG,PARAM1,PARAM2,PARAM3,BULKT,TWOD,DIST,DIST2,RIGIDBODY,RMAT)
      DSTART=DIST
      CALL MINPERMDIST(COORDS,CFINISH,NATOMS,DEBUG,PARAM1,PARAM2,PARAM3,BULKT,TWOD,DIST,DIST2,RIGIDBODY,RMAT)
      DFINISH=DIST
      IF (BHDEBUG) PRINT '(A,G20.10,A,2G15.5)',' BHINTERP> FOR RMS CONDITION ',GMAX,' DISTANCES: ',DSTART,DFINISH
      IF ((ABS(DSTARTSAVE-DSTART)*100/DSTARTSAVE.LT.10.0D0).AND. &
          (ABS(DFINISHSAVE-DFINISH)*100/DFINISHSAVE.LT.10.0D0)) EXIT ! GUESS THAT WE REALLY HAVE CONVERGED
      IF ((DSTART.LT.GEOMDIFFTOL).OR.(DFINISH.LT.GEOMDIFFTOL)) EXIT ! WE HAVE HIT AN END POINT
    
      DSTARTSAVE=DSTART; DFINISHSAVE=DFINISH
   END DO
   GMAX=GMAXSAVE
ENDIF
IF (DSTART.LT.GEOMDIFFTOL) THEN
   IF (NBISECT.EQ.MAXBISECT) THEN
      IF (BHDEBUG) PRINT '(A)',' BHINTERP> BISECTION LIMIT REACHED - ABANDON INTERPOLATION'
      CALL FLUSH(6,ISTAT)
      SUCCESS=.FALSE.
      RETURN
   ENDIF
   IF (HITF) THEN
      IF (BHDEBUG) PRINT '(A)',' BHINTERP> BOTH END POINTS HIT - ABANDON INTERPOLATION'
      CALL FLUSH(6,ISTAT)
      SUCCESS=.FALSE.
      RETURN
   ENDIF
   NBISECT=NBISECT+1
   SLIMIT=MIN(SFRAC,SLIMIT)
   SFRAC=(SFRAC+FLIMIT)/2.0D0
   IF (BHDEBUG) PRINT '(A,G20.10)',' BHINTERP> INITIAL GUESS MINIMISED TO STARTING END POINT - CHANGE SFRAC TO ',SFRAC
   HITS=.TRUE.
   GOTO 1
ENDIF
IF (DFINISH.LT.GEOMDIFFTOL) THEN
   IF (NBISECT.EQ.MAXBISECT) THEN
      IF (BHDEBUG) PRINT '(A)',' BHINTERP> BISECTION LIMIT REACHED - ABANDON INTERPOLATION'
      CALL FLUSH(6,ISTAT)
      SUCCESS=.FALSE.
      RETURN
   ENDIF
   IF (HITS) THEN
      IF (BHDEBUG) PRINT '(A)',' BHINTERP> BOTH END POINTS HIT - ABANDON INTERPOLATION'
      CALL FLUSH(6,ISTAT)
      SUCCESS=.FALSE.
      RETURN
   ENDIF
   NBISECT=NBISECT+1
   FLIMIT=MAX(SFRAC,FLIMIT)
   SFRAC=(SFRAC+SLIMIT)/2.0D0
   IF (BHDEBUG) PRINT '(A,G20.10)',' BHINTERP> INITIAL GUESS MINIMISED TO FINISH END POINT - CHANGE SFRAC TO ',SFRAC
   HITF=.TRUE.
   GOTO 1
ENDIF

EPREV=EREAL
COORDSO(1:NCOORDS)=COORDS(1:NCOORDS)
IF (BHINTERPUSELOWEST) THEN
   EBEST=EPREV ! IGNORE THE STRING ENERGY IN DETERMINING THE "BEST" INTERMEDIATE MINIMUM
ELSE
   EBEST=EPREV+ESPREV
ENDIF
BESTCOORDS(1:NCOORDS)=COORDS(1:NCOORDS)
NSUCCESS=0; NFAIL=0; NSUCCESST=0; NFAILT=0
EXITBHRUN=.FALSE.

DO J1=1,BHSTEPS
!
! PERTURB CURRENT GEOMETRY.
!
!  IF (AMBERT .AND. ICINTERPT) THEN
   IF ((AMBERT.OR.NABT) .AND. AMBSTEPT) THEN
      IF (.NOT.ALLOCATED(NICTOT)) THEN
          CALL SETDIHEAM() 
      ENDIF
      IF (AMBPERTT .AND. .NOT.AMBERICT) THEN
   !MSB50 - NOTE - HYDROGENS MAY HAVE BEEN SWAPPED AROUND SO ANGLES DON'T 
   ! CONFORM TO THE ONES FROM INTERNAL INTERPOLATION IN ALL CASES (SWAPPED)

          IF (.NOT.ALLOCATED(PHI_START)) ALLOCATE(PHI_START(NPHIA +NPHIH))
          IF (.NOT.ALLOCATED(PHI_FINISH)) ALLOCATE(PHI_FINISH(NPHIA+NPHIH))
          CALL CHGETICVAL(CSTART, PHI_START, PHI_START,PHI_START,PHI_START,PHI_START, .TRUE.)
          CALL CHGETICVAL(CFINISH, PHI_FINISH, PHI_FINISH,PHI_FINISH,PHI_FINISH,PHI_FINISH, .TRUE.)
          !DO K = 1, 104
          !   PRINT*,K,"START", PHI_START(K),"FINISH",PHI_FINISH(K)
          !ENDDO
          CALL GET_TWISTABLE(PHI_START, PHI_FINISH)
      ENDIF
     PRINT*, "AMBER TAKESTEP"
     CALL TAKESTEPAMM(COORDS,BHDEBUG, BHSTEPSIZE)
   ELSE IF (CHRMMT) THEN
      CALL TAKESTEPCH(COORDS) ! CHANGED BACK DUE TO PROBLEMS WITH CYPA!
!     DO J2=1,NCOORDS
!        COORDS(J2)=COORDS(J2)+BHSTEPSIZE*(DPRAND()-0.5D0)*2.0D0
!     ENDDO
   ELSE
      DO J2=1,NCOORDS
         COORDS(J2)=COORDS(J2)+BHSTEPSIZE*(DPRAND()-0.5D0)*2.0D0
      ENDDO
   ENDIF
   KNOWE=.FALSE.
   GMAXSAVE=GMAX; GMAX=BHCONV ! MYLBFGS NOW USES GMAX SO THAT WE CAN CHANGE THIS PARAMETER VIA CHANGEP
   CALL MYLBFGS(NCOORDS,MUPDATE,COORDS,.FALSE.,MFLAG,ENERGY,RMS2,EREAL,RMS,BFGSSTEPS, &
     &                     .TRUE.,ITDONE,PTEST,VNEW,.TRUE.,.FALSE.)
   GMAX=GMAXSAVE
   CALL MINPERMDIST(COORDS,CSTART,NATOMS,DEBUG,PARAM1,PARAM2,PARAM3,BULKT,TWOD,DIST,DIST2,RIGIDBODY,RMAT)
   DSTART=DIST
   CALL MINPERMDIST(COORDS,CFINISH,NATOMS,DEBUG,PARAM1,PARAM2,PARAM3,BULKT,TWOD,DIST,DIST2,RIGIDBODY,RMAT)
   DFINISH=DIST
   ESTRING=0.5D0*BHK*(DSTART**2+DFINISH**2)
   ETOTAL=EREAL+ESTRING
!  PRINT '(A,4G20.10)',' BHINTERP> E, E+ES, DISTANCES=',EREAL,ETOTAL,DSTART,DFINISH
! WRITE(99,*) 864
! WRITE(99,'(A,4G20.10)') 'INITIAL INTERP, E, E+ES, DISTS=',EREAL,ESPREV,DSTART,DFINISH
! DO K=1,NATOMS
!    WRITE(99,'(A,3G20.10)') 'LA ',COORDS(3*(K-1)+1),COORDS(3*(K-1)+2),COORDS(3*(K-1)+3)
! ENDDO
!
! ACCEPT/REJECT STEP. 
! DON;T ALLOW THE INTERPOLATED MINIMUM TO BE EITHER OF THE ENDPOINTS!
!
   IF ((DSTART.LT.GEOMDIFFTOL).OR.(DFINISH.LT.GEOMDIFFTOL)) THEN
      ATEST=.FALSE.
!  ELSEIF ((DSTART.GT.DSTARTSAVE).OR.(DFINISH.GT.DFINISHSAVE)) THEN
!     ATEST=.FALSE.
   ELSEIF (EREAL+ESTRING.LT.EPREV+ESPREV) THEN
      ATEST=.TRUE.
   ELSE
       RANDOM=DPRAND()
       IF (DEXP(-(EREAL+ESTRING-EPREV-ESPREV)/BHTEMP).GT.RANDOM) THEN
          ATEST=.TRUE.
       ELSE
          ATEST=.FALSE.
       ENDIF
   ENDIF
   IF (ATEST) THEN
      NSUCCESS=NSUCCESS+1
      EPREV=EREAL
      ESPREV=ESTRING
      COORDSO(1:NCOORDS)=COORDS(1:NCOORDS)
!
! RECORD BEST SOLUTION FOUND SO FAR.
!
      IF (BHINTERPUSELOWEST) THEN
         IF (EPREV.LT.EBEST) THEN
            EBEST=EPREV
            BESTCOORDS(1:NCOORDS)=COORDS(1:NCOORDS)
         ENDIF
      ELSE
         IF (EPREV+ESPREV.LT.EBEST) THEN
            EBEST=EPREV+ESPREV
            BESTCOORDS(1:NCOORDS)=COORDS(1:NCOORDS)
         ENDIF
      ENDIF
      IF (BHDEBUG) PRINT '(I6,4(A,G15.5),A,I6,A)',J1,' EN= ', EREAL, ' EO= ',EPREV,  &
  &            ' ETN=', ETOTAL,' ETO=',EPREV+ESPREV,' ITER ',ITDONE,' AC'
      IF (BHDEBUG) PRINT '(A,2G15.5)','       DISTANCES FROM START AND FINISH: ',DSTART,DFINISH
   ELSE 
      NFAIL=NFAIL+1
      IF (BHDEBUG) PRINT '(I6,4(A,G15.5),A,I6,A)',J1,' EN= ', EREAL, ' EO= ',EPREV,  &
  &            ' ETN=', ETOTAL,' ETO=',EPREV+ESPREV,' ITER ',ITDONE,' RJ'
      IF (BHDEBUG) PRINT '(A,2G15.5)','       DISTANCES FROM START AND FINISH: ',DSTART,DFINISH
      COORDS(1:NCOORDS)=COORDSO(1:NCOORDS)
   ENDIF
!
   IF (BHINTERPUSELOWEST.AND.BHCHECKENERGYT) THEN
      IF (EBEST.LT.BHMAXENERGY .AND. J1.GE.BHSTEPSMIN) EXITBHRUN=.TRUE.
   ENDIF
   IF (EXITBHRUN) EXIT
!
! ADJUST STEP SIZE.
!
   IF (MOD(J1,50).EQ.0) THEN
      P0=(1.D0*NSUCCESS)/(1.D0*(NSUCCESS+NFAIL))
      IF (P0.GT.BHACCREJ) BHSTEPSIZE=BHSTEPSIZE*1.05D0
      IF (P0.LT.BHACCREJ) BHSTEPSIZE=BHSTEPSIZE/1.05D0
      IF (BHDEBUG) PRINT '(A,G20.10,A,G20.10)',' BHINTERP> ACCEPTANCE RATIO=',P0,' MAXIMUM STEP SIZE=',BHSTEPSIZE
      NSUCCESST=NSUCCESST+NSUCCESS
      NFAILT=NFAILT+NFAIL
      NSUCCESS=0; NFAIL=0
   ENDIF

!  IF ((DSTART.LT.DENDPT).AND.(DFINISH.LT.DENDPT)) EXIT ! STOP IF BOTH DISTANCES ARE < END POINT DISTANCE
   
ENDDO ! MAIN LOOP OVER BH STEPS
!
!  REOPTIMISE BEST MINIMUM TO GLOBAL RMS TOLERANCE. HERE WE ACTUALLY USE GMAX NOT BHCONV!
!
KNOWE=.FALSE.
CALL MYLBFGS(NCOORDS,MUPDATE,BESTCOORDS,.FALSE.,MFLAG,ENERGY,RMS2,EREAL,RMS,BFGSSTEPS, &
  &          .TRUE.,ITDONE,PTEST,VNEW,.TRUE.,.FALSE.)
CALL MINPERMDIST(BESTCOORDS,CSTART,NATOMS,DEBUG,PARAM1,PARAM2,PARAM3,BULKT,TWOD,DIST,DIST2,RIGIDBODY,RMAT)
DSTART=DIST
CALL MINPERMDIST(BESTCOORDS,CFINISH,NATOMS,DEBUG,PARAM1,PARAM2,PARAM3,BULKT,TWOD,DIST,DIST2,RIGIDBODY,RMAT)
DFINISH=DIST
!
! DON'T ALLOW THE INTERPOLATED MINIMUM TO BE EITHER OF THE ENDPOINTS!
!
IF (BHDEBUG) PRINT '(A,2G20.10)',' BHINTERP> DSTART,DFINISH=',DSTART,DFINISH
IF ((DSTART.LT.GEOMDIFFTOL).OR.(DFINISH.LT.GEOMDIFFTOL)) THEN
   SUCCESS=.FALSE.
   IF (BHDEBUG) PRINT '(A)',' BHINTERP> TIGHT QUENCH OPTIMISED TO AN END POINT'
ELSE
! SF344> AMBER STUFF
   IF (NOCISTRANS.AND.(AMBERT.OR.NABT)) THEN
      GOODSTRUCTURE1=.TRUE.
      IF (NOCISTRANSRNA) THEN
         CALL CHECK_CISTRANS_RNA(BESTCOORDS,NATOMS,ZSYM,GOODSTRUCTURE1)
         IF (.NOT.GOODSTRUCTURE1) THEN
            SUCCESS=.FALSE.
            IF (BHDEBUG) PRINT '(A)', ' BHINTERP> CIS-TRANS ISOMERISATION IN RNA RIBOSE RING DETECTED, ABANDONING STRUCTURE'
         ELSE
            SUCCESS=.TRUE.
         ENDIF
      ELSE IF (NOCISTRANSDNA) THEN
         CALL CHECK_CISTRANS_DNA(BESTCOORDS,NATOMS,ZSYM,GOODSTRUCTURE1)
         IF (.NOT.GOODSTRUCTURE1) THEN
            SUCCESS=.FALSE.
            IF (BHDEBUG) PRINT '(A)', ' BHINTERP> CIS-TRANS ISOMERISATION IN DNA DEOXYRIBOSE RING DETECTED, ABANDONING STRUCTURE'
         ELSE
            SUCCESS=.TRUE.
         ENDIF
      ELSE
          CALL CHECK_CISTRANS_PROTEIN(CSTART,NATOMS,GOODSTRUCTURE1,MINOMEGA,CISARRAY1)
          CALL CHECK_CISTRANS_PROTEIN(BESTCOORDS,NATOMS,GOODSTRUCTURE2,MINOMEGA,CISARRAY2)
          CISARRAY1=CISARRAY1-CISARRAY2
          GOODSTRUCTURE1=.TRUE.
          DO J1=1,NATOMS
                IF(CISARRAY1(J1)/=0) THEN
                  GOODSTRUCTURE1=.FALSE.
                  WRITE(*,'(A,I6)') ' BHINTERP> CIS-TRANS ISOMERISATION OF A PEPTIDE BOND DETECTED INVOLVING ATOM ', J1
                END IF
          END DO
          IF(.NOT.GOODSTRUCTURE1) THEN
            SUCCESS=.FALSE.
            WRITE(*,'(A)') ' BHINTERP> CIS-TRANS ISOMERISATION OF A PEPTIDE BOND DETECTED, REJECTING'
          ELSE
            SUCCESS=.TRUE.
          END IF
      ENDIF
   ELSE
      SUCCESS=.TRUE.
   ENDIF
ENDIF
IF (.NOT.MFLAG) THEN
   PRINT '(A)',' BHINTERP> WARNING - FINAL TIGHT MINIMISATION FAILED TO CONVERGE'
   SUCCESS=.FALSE.
ELSE
   IF (BHDEBUG) PRINT '(A,G20.10,A,I8)',' BHINTERP> TIGHT QUENCH: POTENTIAL ENERGY= ',EREAL,' ITERATIONS ',ITDONE
   IF(BHDEBUG) CALL DUMPCOORDS(COORDS, 'BHPOINT.XYZ', .FALSE.)
ENDIF
IF (EREAL.GT.BHMAXENERGY) THEN
   SUCCESS=.FALSE.
   IF (BHDEBUG) PRINT '(A,G20.10)',' BHINTERP> MINIMUM EXCEEDS ENERGY THRESHOLD: ',BHMAXENERGY
ENDIF
INTERPCOORDS(1:NCOORDS)=BESTCOORDS(1:NCOORDS)
FINALENERGY=EREAL
CALL FLUSH(6,ISTAT)
END SUBROUTINE BHINTERP
