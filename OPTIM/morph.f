C   OPTIM: A PROGRAM FOR OPTIMIZING GEOMETRIES AND CALCULATING REACTION PATHWAYS
C   COPYRIGHT (C) 1999-2005 DAVID J. WALES
C   THIS FILE IS PART OF OPTIM.
C
C   OPTIM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C   IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C   THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C   (AT YOUR OPTION) ANY LATER VERSION.
C
C   OPTIM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
C   BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
C   GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C   YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C   ALONG WITH THIS PROGRAM; IF NOT, WRITE TO THE FREE SOFTWARE
C   FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330, BOSTON, MA  02111-1307  USA
C
C***********************************************************************
C
C  THIS SUBROUTINE IS DESIGNED TO MORPH AN INITIAL GEOMETRY INTO A FINAL 
C  ENDPOINT AVOIDING CLASHES. 
C
C***********************************************************************
C
      SUBROUTINE MORPH(ITMAX,COORDS,QFINISH,ENERGY,GRAD,MFLAG,RMS,ITER,POTCALL)
      USE COMMONS
      USE KEY
      USE ZWK
      USE MODTWOEND
      USE MODCHARMM
      USE PORFUNCS
      IMPLICIT NONE

      INTEGER J1, J, ITER, NBFGS, ITMAX, ITDONE, ISTAT, NREPEL, NPU
      INTEGER ::  REPMAX=10
      DOUBLE PRECISION GRAD(3*NATOMS),ENERGY,COORDS(3*NATOMS),RMS,PSTEP,DISTS,DISTF,
     &                 PROJF,PROJS,DUM,QSTART(3*NATOMS),QFINISH(1:3*NATOMS),EOLD,RMS2,EREAL,SVEC(3*NATOMS),
     &                 DSAVE(ITMAX),MNBFGSMAX1SAVE,MNBFGSMAX2SAVE,STARTTIME,FINISHTIME,RMAT(3,3),DIST2, GMAXSAVE
      LOGICAL MFLAG, PVFLAG, RESET, POTCALL, PTEST, PUSH, PULL, FINISHED
      COMMON /PVF/ PVFLAG
      CHARACTER(LEN=5) ZSYMSAVE
      COMMON /SYS/ ZSYMSAVE
      LOGICAL KNOWE, KNOWG, KNOWH
      COMMON /KNOWN/ KNOWE, KNOWG, KNOWH
      COMMON /MORPHDATA/ PUSH, PULL

      IF (DEBUG) OPEN(UNIT=995,FILE='MORPH.XYZ',STATUS='UNKNOWN')
      CALL MYCPU_TIME(STARTTIME,.TRUE.)
      IF (ZSYM(1)(1:1).EQ.'W') THEN
         PRINT*,'MORPH PROCEDURES HAVE NOT BEEN PROGRAMMED FOR TIP POTENTIALS'
         STOP
      ENDIF
      PRINT '(A,F8.2,A,F12.2,A,F10.2)',' MORPH> INTERPOLATION USING MAXIMUM STEP ',MORPHMXSTP,' ENERGY MAXIMUM ',
     &                                   MORPHEMAX,' MAXIMUM RISE ',MORPHERISE
      PULL=.TRUE.
      PUSH=.FALSE.
      NPU=0
      FINISHED=.FALSE.
      MNBFGSMAX1SAVE=MNBFGSMAX1
      MNBFGSMAX2SAVE=MNBFGSMAX2

      OPEN(UNIT=44,FILE='MORPH.POINTS',STATUS='UNKNOWN')

      NUP=1 ! MYLBFGS USES THIS FOR PROJECTION OF THE SEARCH DIRECTION
      QSTART(1:3*NATOMS)=COORDS(1:3*NATOMS)
      CALL MINPERMDIST(QSTART,QFINISH,NATOMS,DEBUG,PARAM1,PARAM2,PARAM3,BULKT,TWOD,DISTF,DIST2,RIGIDBODY,RMAT)
      IF (DEBUG) PRINT '(A,F20.10)',' MORPH> INITIAL DISTANCE BETWEEN START AND FINISH=',DISTF
!     QSTART(1:3*NATOMS)=COORDS(1:3*NATOMS)
      NREPEL=0
      PRINTPTS=.TRUE.
      ITER=1
      PTEST=.FALSE.
      IF (DEBUG) PTEST=.TRUE.
90    CONTINUE
      IF (POTCALL) THEN
         IF (PV) THEN
            IF (.NOT.KNOWE) CALL POTENTIAL(COORDS,ENERGY,GRAD,.FALSE.,.FALSE.,RMS,.FALSE.,.FALSE.)
            PVFLAG=.FALSE.
            CALL PVOPT(COORDS,ENERGY,GRAD)
         ENDIF
         IF (.NOT.KNOWG) CALL POTENTIAL(COORDS,ENERGY,GRAD,.TRUE.,.FALSE.,RMS,PTEST,.FALSE.)
      ENDIF
!     CALL DUMPP(COORDS,ENERGY)
      IF (DEBUG) WRITE(995,'(I6)') NATOMS
      IF (DEBUG) WRITE(995,'(G20.10)') ENERGY
      IF (DEBUG) WRITE(995,'(A3,3G20.10)') ('LA ',COORDS(3*(J1-1)+1),COORDS(3*(J1-1)+2),COORDS(3*(J1-1)+3),J1=1,NATOMS)

      CALL NEWMINDIST(COORDS,QFINISH,NATOMS,DISTF,BULKT,TWOD,ZSYMSAVE,.FALSE.,RIGIDBODY,DEBUG,RMAT)
      CALL NEWMINDIST(COORDS,QSTART,NATOMS,DISTS,BULKT,TWOD,ZSYMSAVE,.FALSE.,RIGIDBODY,DEBUG,RMAT)

      PROJF=0.0D0
      PROJS=0.0D0
      DO J1=1,NOPT
         IF (DISTF.GT.0.0D0) PROJF=PROJF+GRAD(J1)*(QFINISH(J1)-COORDS(J1))/DISTF
         IF (DISTS.GT.0.0D0) PROJS=PROJS+GRAD(J1)*(COORDS(J1)-QSTART(J1))/DISTS
      ENDDO
      IF (PULL.AND.(PROJF.GT.0.0D0).AND.(ENERGY.GT.MORPHEMAX)) THEN
         PUSH=.TRUE.
         PULL=.FALSE.
         NPU=0
      ELSEIF (PUSH.AND.(PROJS.GT.0.0D0).AND.(ENERGY.GT.MORPHEMAX)) THEN
         PUSH=.FALSE.
         PULL=.TRUE.
         NPU=0
      ENDIF
      IF (NPU.GT.100) THEN
         IF (ABS(DSAVE(NPU-100)-DISTF).LT.0.1D0) THEN
            PRINT '(A,2G20.10)',' MORPH> ATTEMPTING TO UNSTICK: DISTANCES=',DSAVE(NPU-100),DISTF
            NPU=0
            MNBFGSMAX1=MAX(1,MNBFGSMAX1-1)
            MNBFGSMAX2=MAX(1,MNBFGSMAX2-1)
         ENDIF
      ENDIF
      IF (PULL) THEN
         PSTEP=MIN(DISTF,MORPHMXSTP)
         DO J=1,NOPT
           IF (DISTF.NE.0.0D0) SVEC(J)=(QFINISH(J)-COORDS(J))/DISTF
         ENDDO
      ELSEIF (PUSH) THEN
         PSTEP=MIN(DISTF,MORPHMXSTP)
         DO J=1,NOPT
           IF (DISTS.NE.0.0D0) SVEC(J)=(COORDS(J)-QSTART(J))/DISTS
         ENDDO
      ENDIF
C
C  REGENERATE FULL Q VECTOR. 
C
      DO J=1,NOPT
         COORDS(J)=COORDS(J)+PSTEP*SVEC(J)
      ENDDO

      KNOWE=.FALSE.
      KNOWG=.FALSE.
      KNOWH=.FALSE.
      EOLD=ENERGY
77    CALL POTENTIAL(COORDS,ENERGY,GRAD,.TRUE.,.FALSE.,RMS,.FALSE.,.FALSE.)
      IF (ENERGY-EOLD.GT.MORPHERISE) THEN
         IF (PTEST) PRINT '(2(A,G20.10))',' MORPH> ENERGY ROSE BY ',ENERGY-EOLD,' REDUCING STEP SIZE TO ',PSTEP/2.0D0
         DO J=1,NOPT
           COORDS(J)=COORDS(J)-PSTEP*SVEC(J)/2.0D0
         ENDDO
         PSTEP=PSTEP/2.0D0
         KNOWE=.FALSE.
         KNOWG=.FALSE.
         KNOWH=.FALSE.
         GOTO 77
      ENDIF
      CALL FLUSH(6,ISTAT)
C
C SUMMARIZE
C
      IF (PUSH.AND.DEBUG) PRINT '(A,I8,A,F15.6,6(A,F8.2))', 'PUSH ',ITER,' E=',ENERGY,' STEP=',PSTEP,
     &     ' DS=',DISTS,' DF=',DISTF,' RMS=',RMS,' PF=',PROJF,' PS=',PROJS
      IF (PULL.AND.DEBUG) PRINT '(A,I8,A,F15.6,6(A,F8.2))', 'PULL ',ITER,' E=',ENERGY,' STEP=',PSTEP,
     &     ' DS=',DISTS,' DF=',DISTF,' RMS=',RMS,' PF=',PROJF,' PS=',PROJS
      NPU=NPU+1
      DSAVE(NPU)=DISTF
C
C  TANGENT SPACE MINIMIZATION NEXT.
C  STEP DIRECTION IS PROJECTED OUT OF THE STEP IN MYLBFGS
C  THE NEXT IF BLOCK ALLOWS FOR ZERO TANGENT SPACE STEPS IN THE INITIAL PHASE
C
      IF (DISTF.GT.CONVU) THEN
          NBFGS=MNBFGSMAX1
      ELSE
          NBFGS=MNBFGSMAX2
      ENDIF

      RESET=.FALSE.
      RESET=.TRUE.
      RMS2=RMS ! NEEDS TO BE SET BECAUSE MYLBFGS TESTS IT FOR CONVERGENCE !
      IF (ITER.EQ.1) RESET=.TRUE.
      ZWORK(1:3*NATOMS,1)=SVEC(1:3*NATOMS) ! USED FOR THE PROJECTION DIRECTION IN MYLBFGS
      GMAXSAVE=GMAX; GMAX=CONVR ! MYLBFGS NOW USES GMAX SO THAT WE CAN CHANGE THIS PARAMETER VIA CHANGEP
      IF (CHRMMT.AND.INTMINT) THEN
         CALL MYLBFGS(NINTS,MUPDATE,COORDS,.FALSE.,MFLAG,ENERGY,RMS2,EREAL,RMS,NBFGS,
     1                RESET,ITDONE,PTEST,GRAD,.TRUE.,.TRUE.)
      ELSE
         CALL MYLBFGS(NOPT,MUPDATE,COORDS,.FALSE.,MFLAG,ENERGY,RMS2,EREAL,RMS,NBFGS,
     1                RESET,ITDONE,PTEST,GRAD,.TRUE.,.TRUE.)
      ENDIF
      GMAX=GMAXSAVE
      WRITE(44,'(3G25.15)') COORDS(1:NOPT)
      IF (MFLAG) THEN
         IF (((RMS.GT.CONVR).OR.(PSTEP.GT.CONVU))) MFLAG=.FALSE.
         IF (MFLAG) THEN
            CLOSE(44)
            IF (DEBUG) CLOSE(995)
            MNBFGSMAX1=MNBFGSMAX1SAVE
            MNBFGSMAX2=MNBFGSMAX2SAVE
            FINISHED=.TRUE.
            CALL MYCPU_TIME(FINISHTIME,.FALSE.)
            PRINT '(A,I8,A,F12.2)',' MORPH> INTERPOLATION SUCCEEDED IN ',ITER,' STEPS, TIME=',FINISHTIME-STARTTIME
            RETURN
         ENDIF
      ENDIF
      ITER=ITER+1
      IF (ITER.GT.ITMAX) THEN
         CLOSE(44)
         IF (DEBUG) CLOSE(995)
         MNBFGSMAX1=MNBFGSMAX1SAVE
         MNBFGSMAX2=MNBFGSMAX2SAVE
         FINISHED=.FALSE.
         CALL MYCPU_TIME(FINISHTIME,.FALSE.)
         PRINT '(A,I8,A,F12.2)',' MORPH> INTERPOLATION FAILED TO CONVERGE IN ',ITER,' STEPS, TIME TAKEN=',FINISHTIME-STARTTIME
!        STOP
         RETURN
      ENDIF
      EOLD=ENERGY
      GOTO 90

      RETURN
      END
