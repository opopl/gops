!   Copyright (C) 2010- David J. Wales
!
!   OPTIM is free software; you can redistribute it and/or modify
!   it under the terms of the GNU General Public License as published by
!   the Free Software Foundation; either version 2 of the License, or
!   (at your option) any later version.
!
!   OPTIM is distributed in the hope that it will be useful,
!   but WITHOUT ANY WARRANTY; without even the implied warranty of
!   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!   GNU General Public License for more details.
!
!   You should have received a copy of the GNU General Public License
!   along with this program; if not, write to the Free Software
!   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
!
SUBROUTINE MAKE_CONPOT(NCPFIT,MINCOORDS)
USE KEY, ONLY : INTCONSEP, NREPMAX, NREPULSIVE, CONDISTREF, DEBUG, REPCON, INTCONSTRAINTREP, &
  & REPCUT, NCONSTRAINT, CONI, CONJ, CONDISTREF, CONDISTREFLOCAL, INTCONMAX, CONACTIVE, &
  & INTCONSTRAINREPCUT, INTREPSEP, REPI, REPJ, INTCONSTRAINTTOL, REPCUT, NREPI, NREPJ, NREPCUT, NNREPULSIVE
USE COMMONS, ONLY : NATOMS

IMPLICIT NONE 
DOUBLE PRECISION DMAX, DS, DF, DSHORT
DOUBLE PRECISION, ALLOCATABLE :: CPTEMP(:)
INTEGER, ALLOCATABLE :: ICPTEMP(:)
INTEGER :: J2,ISTAT,J1,J3,J4,NCPFIT,J5
INTEGER NCONFORNEWATOM, CONLIST(NATOMS), NCONATOM(NATOMS)
DOUBLE PRECISION :: DUMMY, NDIST, CONDIST(NATOMS), MINCOORDS(NCPFIT,3*NATOMS), DMIN, LINTCONSTRAINTTOL
LOGICAL CHANGED
INTEGER NDIST1(NATOMS), NCYCLE, DMIN1, DMAX1, NUNCON1

!
! Find distances that are conserved within tolerance between the NCPFIT, minima.
!
IF (.NOT.ALLOCATED(CONI)) THEN 
   ALLOCATE(CONI(INTCONMAX),CONJ(INTCONMAX),CONDISTREF(INTCONMAX))
   ALLOCATE(REPI(NREPMAX),REPJ(NREPMAX),NREPI(NREPMAX),NREPJ(NREPMAX),REPCUT(NREPMAX),NREPCUT(NREPMAX))
ENDIF
LINTCONSTRAINTTOL=INTCONSTRAINTTOL

51 NCONSTRAINT=0 
DSHORT=1.0D100
DO J2=1,NATOMS
   atom2: DO J3=J2+1,NATOMS
      IF (J3-J2.GT.INTCONSEP) CYCLE atom2 ! forbid constraints corresponding to atoms distant in sequence
      DUMMY=0.0D0
      DO J4=1,NCPFIT
         DO J5=J4+1,NCPFIT
!
!  Don;t consider constraints if either endpoint distance is > 5. 
!  Do we really need this? Turn it off?
!
            DS=SQRT((MINCOORDS(J4,3*(J2-1)+1)-MINCOORDS(J4,3*(J3-1)+1))**2 &
  &                +(MINCOORDS(J4,3*(J2-1)+2)-MINCOORDS(J4,3*(J3-1)+2))**2 &
  &                +(MINCOORDS(J4,3*(J2-1)+3)-MINCOORDS(J4,3*(J3-1)+3))**2) 
            IF (DS.GT.5.0D0) CYCLE atom2
            DF=SQRT((MINCOORDS(J5,3*(J2-1)+1)-MINCOORDS(J5,3*(J3-1)+1))**2 &
  &                +(MINCOORDS(J5,3*(J2-1)+2)-MINCOORDS(J5,3*(J3-1)+2))**2 &
  &                +(MINCOORDS(J5,3*(J2-1)+3)-MINCOORDS(J5,3*(J3-1)+3))**2) 
            IF (DF.GT.5.0D0) CYCLE atom2
            IF (ABS(DS-DF).GT.LINTCONSTRAINTTOL) CYCLE atom2
            DUMMY=DUMMY+(DS+DF)/2.0D0
         ENDDO
      ENDDO
!
!  Add constraint for this distance to the list.
!
      NCONSTRAINT=NCONSTRAINT+1
!     PRINT '(A,2I6,A,I6)','make_conpot> Adding constraint for atoms ',J2,J3,'  total=',NCONSTRAINT
      IF (NCONSTRAINT.GT.INTCONMAX) THEN
         ALLOCATE(ICPTEMP(INTCONMAX))
               
         ICPTEMP(1:INTCONMAX)=CONI(1:INTCONMAX)
         DEALLOCATE(CONI)
         ALLOCATE(CONI(2*INTCONMAX))
         CONI(1:INTCONMAX)=ICPTEMP(1:INTCONMAX)
               
         ICPTEMP(1:INTCONMAX)=CONJ(1:INTCONMAX)
         DEALLOCATE(CONJ)
         ALLOCATE(CONJ(2*INTCONMAX))
         CONJ(1:INTCONMAX)=ICPTEMP(1:INTCONMAX)
               
         DEALLOCATE(ICPTEMP)
         ALLOCATE(CPTEMP(1:INTCONMAX))
               
         CPTEMP(1:INTCONMAX)=CONDISTREF(1:INTCONMAX)
         DEALLOCATE(CONDISTREF)
         ALLOCATE(CONDISTREF(2*INTCONMAX))
         CONDISTREF(1:INTCONMAX)=CPTEMP(1:INTCONMAX)

         INTCONMAX=2*INTCONMAX
         DEALLOCATE(CPTEMP)
      ENDIF
      CONI(NCONSTRAINT)=J2
      CONJ(NCONSTRAINT)=J3
      CONDISTREF(NCONSTRAINT)=DUMMY/(NCPFIT*(NCPFIT-1)/2.0D0)
!     IF (DEBUG) PRINT '(A,2I6,A,2F12.2,A,F12.4,A,I8)',' make_conpot> constrain distance for atoms ',CONI(NCONSTRAINT), &
! &                     CONJ(NCONSTRAINT),' values are ',DS,DF,' fraction=',2*ABS(DS-DF)/(DS+DF), &
! &                    ' # constraints=',NCONSTRAINT
   ENDDO atom2
ENDDO
!
! Check that we have a percolating constraint network. If not, increase the tolerance and try again!
! Calculate minimum number of steps of each atom from number 1.
!
NDIST1(1:NATOMS)=1000000
NDIST1(1)=0
NCYCLE=0
5 CHANGED=.FALSE.
NCYCLE=NCYCLE+1
DMIN1=100000
DMAX1=0
NUNCON1=0
DO J1=1,NATOMS
   IF (NDIST1(J1).EQ.0) CYCLE ! minimum 1
   DO J2=1,NCONSTRAINT
      IF (CONI(J2).EQ.J1) THEN
         IF (NDIST1(CONJ(J2))+1.LT.NDIST1(J1)) THEN
            CHANGED=.TRUE.
            NDIST1(J1)=NDIST1(CONJ(J2))+1
         ENDIF
      ELSE IF (CONJ(J2).EQ.J1) THEN
         IF (NDIST1(CONI(J2))+1.LT.NDIST1(J1)) THEN
            CHANGED=.TRUE.
            NDIST1(J1)=NDIST1(CONI(J2))+1
         ENDIF
      ENDIF
   ENDDO
   IF ((NDIST1(J1).GT.DMAX1).AND.(NDIST1(J1).NE.1000000)) DMAX1=NDIST1(J1)
   IF (NDIST1(J1).LT.DMIN1) DMIN1=NDIST1(J1)
   IF (NDIST1(J1).EQ.1000000) NUNCON1=NUNCON1+1
ENDDO
IF (CHANGED) GOTO 5
! PRINT '(3(A,I8))',' make_conpot> steps to atom 1 converged in ',NCYCLE-1, &
!      &                    ' cycles; maximum=',DMAX1,' disconnected=',NUNCON1
IF (NUNCON1.GT.0) THEN
   LINTCONSTRAINTTOL=LINTCONSTRAINTTOL*1.1D0
   IF (DEBUG) PRINT '(A,F15.5)',' make_conpot> increasing the local constraint tolerance parameter to ',LINTCONSTRAINTTOL
   GOTO 51
ENDIF
NCONATOM(1:NATOMS)=0

! PRINT '(A,I6,2(A,F15.5))',' make_conpot> total distance constraints=',NCONSTRAINT
! REPCON=-INTCONSTRAINTREP/INTCONSTRAINREPCUT**6
REPCON=-INTCONSTRAINTREP/INTCONSTRAINREPCUT
IF (ALLOCATED(CONDISTREFLOCAL)) THEN
   DEALLOCATE(CONDISTREFLOCAL)
ENDIF
ALLOCATE(CONDISTREFLOCAL(NCONSTRAINT))
CONDISTREFLOCAL(1:NCONSTRAINT)=CONDISTREF(1:NCONSTRAINT)
DUMMY=1.0D100
NREPULSIVE=0
!
! Add repulsions to non-constrained atoms.
! Note that we do not limit the number of constraints per site in this
! routine, unlike NEB/lbfgs.f90, where the result will depend on the
! order in which the constraints are turned on. 
!
DO J1=1,NATOMS
   rep2: DO J2=J1+1,NATOMS
      IF (ABS(J1-J2).LE.INTREPSEP) CYCLE ! no repulsion for atoms too close in sequence
      DO J3=1,NCONSTRAINT
         IF ((CONI(J3).EQ.J1).AND.(CONJ(J3).EQ.J2)) CYCLE rep2
         IF ((CONI(J3).EQ.J2).AND.(CONJ(J3).EQ.J1)) CYCLE rep2
      ENDDO
      DMIN=1.0D100
      DMAX=-1.0D0
      DO J3=1,NCPFIT
         DF=SQRT((MINCOORDS(J3,3*(J1-1)+1)-MINCOORDS(J3,3*(J2-1)+1))**2+ &
  &              (MINCOORDS(J3,3*(J1-1)+2)-MINCOORDS(J3,3*(J2-1)+2))**2+ &
  &              (MINCOORDS(J3,3*(J1-1)+3)-MINCOORDS(J3,3*(J2-1)+3))**2)
         IF (DF.GT.DMAX) DMAX=DF
         IF (DF.LT.DMIN) DMIN=DF
      ENDDO
      
      NREPULSIVE=NREPULSIVE+1
      IF (NREPULSIVE.GT.NREPMAX) THEN
         ALLOCATE(ICPTEMP(NREPMAX),CPTEMP(NREPMAX))

         ICPTEMP(1:NREPMAX)=REPI(1:NREPMAX)
         DEALLOCATE(REPI)
         ALLOCATE(REPI(2*NREPMAX))
         REPI(1:NREPMAX)=ICPTEMP(1:NREPMAX)
         ICPTEMP(1:NREPMAX)=REPJ(1:NREPMAX)
         DEALLOCATE(REPJ)
         ALLOCATE(REPJ(2*NREPMAX))
         REPJ(1:NREPMAX)=ICPTEMP(1:NREPMAX)
         CPTEMP(1:NREPMAX)=REPCUT(1:NREPMAX)
         DEALLOCATE(REPCUT)
         ALLOCATE(REPCUT(2*NREPMAX))
         REPCUT(1:NREPMAX)=CPTEMP(1:NREPMAX)

         ICPTEMP(1:NREPMAX)=NREPI(1:NREPMAX)
         DEALLOCATE(NREPI)
         ALLOCATE(NREPI(2*NREPMAX))
         NREPI(1:NREPMAX)=ICPTEMP(1:NREPMAX)
         ICPTEMP(1:NREPMAX)=NREPJ(1:NREPMAX)
         DEALLOCATE(NREPJ)
         ALLOCATE(NREPJ(2*NREPMAX))
         NREPJ(1:NREPMAX)=ICPTEMP(1:NREPMAX)
         CPTEMP(1:NREPMAX)=NREPCUT(1:NREPMAX)
         DEALLOCATE(NREPCUT)
         ALLOCATE(NREPCUT(2*NREPMAX))
         NREPCUT(1:NREPMAX)=CPTEMP(1:NREPMAX)

         DEALLOCATE(ICPTEMP,CPTEMP)
         NREPMAX=2*NREPMAX
      ENDIF
      REPI(NREPULSIVE)=J1
      REPJ(NREPULSIVE)=J2
!
! Use the minimum of the end point distances and INTCONSTRAINREPCUT for each contact.
!
      REPCUT(NREPULSIVE)=MIN(DMIN-1.0D-3,INTCONSTRAINREPCUT)
!     IF (DEBUG) PRINT '(A,I6,A,I6,A,F15.5,A,I10)',' make_conpot> Adding repulsion for atom ',J1, &
! &              ' with atom ',J2,' cutoff=',DMIN,' # repulsions ',NREPULSIVE
   ENDDO rep2
ENDDO

IF (DEBUG) PRINT '(A,2I10,A,G20.10)',' make_conpot> Total number of constraints and repulsions=',NCONSTRAINT,NREPULSIVE, &
  & ' for tolerance parameter ',LINTCONSTRAINTTOL

IF (ALLOCATED(CONACTIVE)) DEALLOCATE(CONACTIVE)
ALLOCATE(CONACTIVE(NCONSTRAINT))
CONACTIVE(1:NCONSTRAINT)=.TRUE. 
!
! congrad routines actually use NREPI, NREPJ, etc., so we must assign these.
!
NREPI(1:NREPULSIVE)=REPI(1:NREPULSIVE)
NREPJ(1:NREPULSIVE)=REPJ(1:NREPULSIVE)
NNREPULSIVE=NREPULSIVE
NREPCUT(1:NREPULSIVE)=REPCUT(1:NREPULSIVE)

RETURN
END SUBROUTINE MAKE_CONPOT

SUBROUTINE CONPOT(COORDS1,COORDS2,ETOTAL)
USE KEY, ONLY : NREPMAX, NREPULSIVE, CONDISTREF, DEBUG, INTCONSTRAINTDEL, &
  & REPCUT, NCONSTRAINT, CONI, CONJ, INTCONMAX, INTCONSTRAINTREP, &
  & INTCONSTRAINREPCUT, REPI, REPJ, REPCUT, CONDISTREFLOCAL, NNREPULSIVE, NREPCUT, NREPI, NREPJ
USE COMMONS, ONLY : NATOMS
IMPLICIT NONE
           
INTEGER :: J1,J2,NI,NJ
DOUBLE PRECISION :: ECON, EREP, ETOTAL
DOUBLE PRECISION R1AX,R1AY,R1AZ,R2AX,R2AY,R2AZ,R1BX,R1BY,R1BZ,R2BX,R2BY,R2BZ,DMIN,DMAX
DOUBLE PRECISION G1MAX(3),G2MIN(3),CONCUT,DINT,G1INT(3),G2INT(3)
DOUBLE PRECISION DUMMY, REPGRAD(3), INtCONST, D12, DSQ0, DSQP, DSQI, COORDS1(3*NATOMS), COORDS2(3*NATOMS)
LOGICAL NOINT

ECON=0.0D0; EREP=0.0D0
!
!  Constraint potential energy and (optionally) forces.
!
DO J2=1,NCONSTRAINT
!
! We consider the line segment between COORDS1 and COORDS2
! A and B refer to atoms, 1 and 2 to COORDS1 and COORDS2
!
   NI=3*(CONI(J2)-1)
   NJ=3*(CONJ(J2)-1)
   R1AX=COORDS1(NI+1); R1AY=COORDS1(NI+2); R1AZ=COORDS1(NI+3)
   R1BX=COORDS1(NJ+1); R1BY=COORDS1(NJ+2); R1BZ=COORDS1(NJ+3)
   R2AX=COORDS2(NI+1); R2AY=COORDS2(NI+2); R2AZ=COORDS2(NI+3)
   R2BX=COORDS2(NJ+1); R2BY=COORDS2(NJ+2); R2BZ=COORDS2(NJ+3)
   CALL MINMAXD2(R1AX,R1AY,R1AZ,R2AX,R2AY,R2AZ,R1BX,R1BY,R1BZ,R2BX,R2BY,R2BZ, &
  &              DMIN,DMAX,DINT,G1MAX,G2MIN,G1INT,G2INT,NOINT,.FALSE.)
!
! Need to include both DMIN and DMAX contributions if they are both outside tolerance.
! Otherwise we get discontinuities if they are very close and swap over.
!
! terms for image J1 - non-zero derivatives only for J1
!
   IF (ABS(DMIN-CONDISTREFLOCAL(J2)).GT.CONCUT) THEN 
      DUMMY=DMIN-CONDISTREFLOCAL(J2)  
      ECON=ECON+INTCONSTRAINTDEL*(DUMMY**2-CONCUT**2)**2/(2.0D0*CONCUT**2)
   ENDIF
!
! terms for image J1-1 - non-zero derivatives only for J1-1
!
   IF (ABS(DMAX-CONDISTREFLOCAL(J2)).GT.CONCUT) THEN  
      DUMMY=DMAX-CONDISTREFLOCAL(J2)  
      ECON=ECON+INTCONSTRAINTDEL*(DUMMY**2-CONCUT**2)**2/(2.0D0*CONCUT**2)
   ENDIF
   IF ((.NOT.NOINT).AND.(ABS(DINT-CONDISTREFLOCAL(J2)).GT.CONCUT)) THEN
      DUMMY=DINT-CONDISTREFLOCAL(J2)  
      ECON=ECON+INTCONSTRAINTDEL*(DUMMY**2-CONCUT**2)**2/(2.0D0*CONCUT**2)
   ENDIF
ENDDO

DO J2=1,NNREPULSIVE
!  INTCONST=NREPCUT(J2)**13
   INTCONST=NREPCUT(J2)**3
   NI=3*(NREPI(J2)-1)
   NJ=3*(NREPJ(J2)-1)
   R1AX=COORDS1(NI+1); R1AY=COORDS1(NI+2); R1AZ=COORDS1(NI+3)
   R1BX=COORDS1(NJ+1); R1BY=COORDS1(NJ+2); R1BZ=COORDS1(NJ+3)
   R2AX=COORDS2(NI+1); R2AY=COORDS2(NI+2); R2AZ=COORDS2(NI+3)
   R2BX=COORDS2(NJ+1); R2BY=COORDS2(NJ+2); R2BZ=COORDS2(NJ+3)
   CALL MINMAXD2R(R1AX,R1AY,R1AZ,R2AX,R2AY,R2AZ,R1BX,R1BY,R1BZ,R2BX,R2BY,R2BZ, &
  &                 DMIN,DMAX,DINT,DSQ0,DSQP,DSQI,G1MAX,G2MIN,G1INT,G2INT,NOINT,.FALSE.,NREPCUT(J2))
   DUMMY=0.0D0 
   IF (DMIN.LT.NREPCUT(J2)) THEN ! terms for image J1 - non-zero derivatives only for J1
!     D12=DSQ0**6
      D12=DSQ0
!     DUMMY=INTCONSTRAINTREP*(1.0D0/D12+(12.0D0*DMIN-13.0D0*NREPCUT(J2))/INTCONST)
      DUMMY=INTCONSTRAINTREP*(1.0D0/D12+(2.0D0*DMIN-3.0D0*NREPCUT(J2))/INTCONST)
      EREP=EREP+DUMMY
   ENDIF
   DUMMY=0.0D0
   IF (DMAX.LT.NREPCUT(J2)) THEN ! terms for image J1-1 - non-zero derivatives only for J1-1
!     D12=DSQP**6
      D12=DSQP
!     DUMMY=INTCONSTRAINTREP*(1.0D0/D12+(12.0D0*DMAX-13.0D0*NREPCUT(J2))/INTCONST)
      DUMMY=INTCONSTRAINTREP*(1.0D0/D12+(2.0D0*DMAX-3.0D0*NREPCUT(J2))/INTCONST)
      EREP=EREP+DUMMY
   ENDIF
   DUMMY=0.0D0
   IF ((.NOT.NOINT).AND.(DINT.LT.NREPCUT(J2))) THEN
!     D12=DSQI**6
      D12=DSQI
!     DUMMY=INTCONSTRAINTREP*(1.0D0/D12+(12.0D0*DINT-13.0D0*NREPCUT(J2))/INTCONST)
      DUMMY=INTCONSTRAINTREP*(1.0D0/D12+(2.0D0*DINT-3.0D0*NREPCUT(J2))/INTCONST)
      EREP=EREP+DUMMY
   ENDIF
ENDDO

ETOTAL=EREP+ECON

END SUBROUTINE CONPOT

